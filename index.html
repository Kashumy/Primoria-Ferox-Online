 <!--

                 PRIMORIA FEROX


FULL Release                    1.5.+


       Copyright©  Kashumy Krystian 2024  

-->



<!DOCTYPE html>
<html lang="pl" ondblclick="document.querySelector('html').requestFullscreen()">
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <script>
  /*  
  
      GAMEVERSION  
      
      
  
  */
var gameversion = " 1.5.7.8"

let experimentalmultiplayer=0;
let gametest=0;
    var yourItems = [];  // Ekwipunek
  </script>
      <style>
html {
    
    position:fixed; width:100vw; height: 100vh; overflow: hidden;;
}
::-webkit-scrollbar {
    width: 5px; /* Szerokość paska przewijania */
    background-color: rgba(0, 0, 0, 0.3); /* Tło paska przewijania z przezroczystością */
    height:5px;
}
::-webkit-scrollbar-track {
  background-color: #00000000; 
}
 
::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.15); 
}

 
      *{
        user-select: none;
      }

        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color:  #FFFFFF ;
            display: flex;
            justify-content: center;
            align-items: center;
            
            z-index: 9999; /* Na wierzchu */
        }
        /* Logo */
        .logo {
            display: none;
            animation: fadeIn 0.4s forwards; /* Fade-in dla logo */
           
          
           
        }
        /* Animacja wygaszania */
        @keyframes fadeOut {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        /* Animacja wchodzenia logo */
        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
@keyframes rainbow {
            0% {
                filter: hue-rotate(0deg);
            }
            100% {
                filter: hue-rotate(180deg);
            }
        }
        @keyframes slidebg {
            0% {
                background-position: 0% 0;
            }
            100% {
                background-position: 100% 0;
            }
        }
        #MainMenu{
          position: absolute;
          z-index: 999;
          width:100vw;
          height:100vh;
          background: url('./skybg.png');
          background-size: 100% 100%;
        }
        #bg1_1 {
          position: absolute;
          
          width: 100vw;
          height: 200px;
          bottom: 0;
          image-rendering: pixelated; 
          background: url('./pfbg.png');
          background-size: 300px 200px ;
          background-repeat: repeat-x;
          animation: 30s slidebg infinite linear;
        } 
         #bg1_2 {
          position: absolute;
          width: 100vw;
          height: 180px;
          bottom: 20px;
          image-rendering: pixelated;
          background: url('./pfbg2.png');
          background-size: 280px 180px;
          background-repeat: repeat-x;
          filter: brightness(0.8);
        }
         .bg2_2 {
          position: absolute;
          width: 100px;
          height: 80px;
          top: 30vh;
          image-rendering: pixelated;
          background: url('./cloud1.png');
          background-size: 100% 100%;
        }
          .bg0_0 {
           position: absolute;
           width: 100px;
           height: 80px;
           top: 30vh;
           image-rendering: pixelated;
           background: url('./bgclouds.png');
           background-size: 100% 100%;
         }
        .bg2_3 {
           position: absolute;
           width: 100px;
           height: 80px;
           top: 30vh;
           image-rendering: pixelated;
           background: url('./cloud2.png');
           background-size: 100% 100%;
         }
       .bg3_3 {
          position: absolute;
          width: 250px;
          height: 200px;
          top: 20px;
          left: 50vw;
          image-rendering: pixelated;
          background: url('./gamename.png');
          background-size: 100% 100%;
          transform: translate(-50%,0);
        }
       .bg4_4 {
         position: absolute;
         width: 200px;
         height: 150px;
         top: 20px;
         left: 50vw;
         image-rendering: pixelated;
         background: url('./sun.png');
         background-size: 100% 100%;
         transform: translate(-50%, 0);
         animation: 80s sun infinite linear;
       }
 .bg5_5 {
         position: absolute;
         width: 300px;
         height: 280px;
         bottom: 0px;
         left: 50vw;
         image-rendering: pixelated;
         background: url('./mountain1.png');
         background-size: 100% 100%;
         transform: translate(-50%, 0);
         animation: 170s mountain infinite linear;
       }
        .bg5_6 {
   position: absolute;
   width: 300px;
   height: 280px;
   bottom: 0px;
   left: 50vw;
   image-rendering: pixelated;
   background: url('./mountain2.png');
   background-size: 100% 100%;
   transform: translate(-50%, 0);
   animation: 170s mountain infinite linear;
 }
        @keyframes clouds{
          0%{
            transform : translate(-90px,0);
          }
          
          100%{
            transform : translate(100vw,0);
          }
        }
   @keyframes mountain {
          0% {
            transform: translate(-100vw, 0);
          }

          100% {
            transform: translate(100vw, 0);
          }
        }
        @keyframes sun {
          0%{
            transform : translate(-100vw,0);
          }
          100%{
            transform : translate(50vw,0);
          }
        }
        #startbtn{
          position: absolute;
          top: calc(50vh - 10px); left:50vw;
          width:10px; height:10px; padding:5px 20vw;
          background:#323232;
          color:#FFFFFF;font-size: 10px;
          transform: translate(-50%,-50%);
        }
                #continuebtn{
          position: absolute;
          top: calc(50vh + 40px); left:50vw;
          width:10px; height:10px; padding:5px 20vw;
          background:#323232;
          color:#FFFFFF; font-size: 10px;
          transform: translate(-50%,-50%);
        }
                #aboutbtn{
          position: absolute;
          top: calc(50vh + 15px); left:50vw;
          width:10px; height:10px; padding:5px 20vw;
          background:#323232;
          color:#FFFFFF;font-size: 10px;
          transform: translate(-50%,-50%);
        }
    </style>

<script>
var cancontinue=0
 function playgamenew(){
   
   document.getElementById('loadingMenu').style.display = 'flex';
   setTimeout(function (){
     abletostart=1;
   document.getElementById('loadingMenu').style.display='none' ;
   document.getElementById('MainMenu').style.display='none' ;
   if(paused==1){document.getElementById('advanced').style.display='block';}
   isUpdating=0
   update()
   paused = 1
  setTimeout(function(){paused=0; update() },1000);
   },1500);
 }
 setTimeout(function (){
     if(gametest==1){
         playgamenew()
         document.getElementById("loader").style.display="none";
     }
 },100)
 function playgameslot(slot) {
  
  document.getElementById('loadingMenu').style.display = 'flex';
  document.getElementById('loadingMenu').innerHTML=""
  slot=(slot)||"";
  loadGameState3(slot)
  abletostart = 1;
  setTimeout(function() {
    
    document.getElementById('savename').value=slot
    
    document.getElementById('MainMenu').style.display = 'none';
    document.getElementById('loadingMenu').style.display = 'none';
    
    if(paused==1){document.getElementById('advanced').style.display='block';}
    isUpdating = 0
update()
   paused = 1
  setTimeout(function(){paused=0; update() },1000);
  }, 2000);
 }

  let dat=""
async function upadtegameslots(){
 document.getElementById('loadingMenu').innerHTML="is loading please wait ..."
 
 const saveNames = [];

try {
  const db = await initDB(); 
  const transaction = db.transaction("gameStates", "readonly"); 
  const store = transaction.objectStore("gameStates");
  const allSavesRequest = store.getAll();
  allSavesRequest.onsuccess = function(event) {
    const gameStates = event.target.result;
    gameStates.forEach(gameState => {
      const slot = gameState.slot;
      
      if (slot !== undefined) {
        saveNames.push(slot);
        dat+=`<div onclick="playgameslot('${slot}');" style="width:80%; height:20px; margin-top:5px;  background: rgb(50,50,50); color:white; ">Continue ? : Slot "${slot}" </div>`;
        document.getElementById('slotgames').innerHTML=dat
      }
    });
  };
  allSavesRequest.onerror = function(error) {
    console.log("Failed to fetch saved games from IndexedDB", error);
  };
} catch (error) {
}
  
}

</script>
<div id="MainMenu">
  <div style="opacity:0.5;">
    <obb class="bg0_0" style="top:35vh;  animation: 15s clouds linear infinite;"></obb>
    <obb class="bg0_0" style="top:30vh;  animation: 20s clouds linear infinite; left:10px"></obb>
    <obb class="bg0_0" style="top:10vh;  animation: 40s clouds linear infinite; left:30px"></obb>
    <obb class="bg0_0" style="top:20vh;  animation: 30s clouds linear infinite; left:3px"></obb>
    <obb class="bg0_0" style="top:15vh;  animation: 45s clouds linear infinite; left:30px"></obb>
  </div>
  
  <obb class="bg4_4" ></obb>
  <obb class="bg5_6" style="left:-100px; width: 350px;
height: 330px; " ></obb>
  <obb class="bg5_5" ></obb>

  <obb id="bg1_1" ></obb>
  <obb class="bg3_3" ></obb>

  <obb class="bg2_2" style="top:35vh;  animation: 15s clouds linear infinite;"></obb>
  <obb class="bg2_2" style="top:30vh;  animation: 20s clouds linear infinite;"></obb>
  
  <obb class="bg2_3" style="top:65vh;  animation: 40s clouds linear infinite; width: 150px; height: 120px;"></obb>
  <obb class="bg2_3" style="top:10vh;  animation: 36s clouds linear infinite; width: 80px; height: 60px; "></obb>
  
  <obb class="bg2_3" style="top:25vh;  animation: 12s clouds linear infinite;"></obb>
  <obb class="bg2_3" style="top:40vh;  animation: 23s clouds linear infinite;"></obb>
  <obb class="bg2_2" style="top:20vh;  animation: 14s clouds linear infinite;"></obb>
  <obb class="bg2_3" style="top:60vh; animation: 30s clouds linear infinite;"></obb>
  <obb class="bg2_3" style="top:10vh;  animation: 32s clouds linear infinite;"></obb>
  <obb class="bg2_3" style="top:60vh; animation: 35s clouds linear infinite;"></obb>
  
  <div id="startscreen" style="position: absolute">
   <div id="continuebtn" style="display: none;" onclick=" document.getElementById('MainMenu').style.display = 'none'; document.getElementById('loadingMenu').style.display = 'none'; document.getElementById('advanced').style.display='block'; ">
    continue? 
  </div>
  <div id="startbtn" onclick=" document.getElementById('gamescontainer').style.display='block' ; ">
    start
  </div>
   <div id="aboutbtn" onclick=" document.getElementById('aboutcontainer').style.display='block' ; ">
    about
  </div>
  
  </div>
    <div id="gamescontainer" style="display:none;  position: absolute; top:50vh ; left:50vw; transform: translate(-50%,-50%); width: 75vw; height: 80vh ; background: grey; border:3px solid rgb(50,50,50) ; ">
    <div style="padding: 10px 50%; background: rgb(50,50,50); color:white;  " > Play <fds onclick=" document.getElementById('gamescontainer').style.display='none' ; " style="color: red; position: absolute ; right:20px; top:5px" >X</fds></div>
    <div id="slotgames" style="white-space: pre-wrap; color:white; margin: 5px; height: 100% width :100% ;">
    </div>
      <div style="width: 100px; position: absolute; bottom: 10px; height: 20px; left:20px;  background: rgb(200,200,200);" onclick="playgamenew()">
          new game
      </div>
  </div>

    <pre id="gameversion1" style="position:absolute; z-index:9; top:0; left:0; color:grey;"> commit </pre>
    <script>
        
    </script>
  <div id="aboutcontainer" style="display:none;  position: absolute; top:50vh ; left:50vw; transform: translate(-50%,-50%); width: 75vw; height: 80vh ; background: grey; border:3px solid rgb(50,50,50) ; overflow: hidden scroll ; ">
    <div style="padding: 10px 50%; background: rgb(50,50,50); color:white;  " > About <fds onclick=" document.getElementById('aboutcontainer').style.display='none' ; " style="color: red; position: absolute ; right:20px; top:5px" >X</fds></div>
    <pre style="white-space: pre-wrap; color:white; margin: 5px; height: 100% width :100% ; overflow: hidden scroll;">
Howdy im Krystian Popiolek a game developer from Poland 
who like survival games . 
i spend ± 11 months . so this is my biggest game for now.
i maded every music every sprite everything. 

i hope you like this game 

     game is maded with full javascript no engine no libraries etc 
     i dont spend money on fl to make music when jummbox is better and free  :) .  
     
     
if you have an idea for this game you can tell me it to add at awlie8518@gmail.com or Kashumy Github Primoria ferox issues


kashumy.github.io copyright © all rights reserved 
dat : 24.21.12,

Im now working on multiplayer 


** chesz zmienić język na polski proszę bardzo 
<select id="languageSelect" onchange="changeLanguage()"> <option value="en">English</option>
      <option value="pl">Polski</option>
</select>
 
    </pre>
  </div>
</div>
<div id="loadingMenu" style="display:none; width: 100vw; height:100vh; background: black; color:white; position:absolute; align-items: center; justify-content: center; position: absolute; z-index:999; opacity: 0.5">
this isn't a fake loading screen !
</div>
<script></script>
    <div class="loader" id="loader">
        <img src="./logo.png" alt="Logo" class="logo" id="logo" style="width: 42%; image-rendering: pixelated ;">
    </div>



    <script>
function changeLanguage() {
const selectElement = document.getElementById('languageSelect');
const selectedValue = selectElement.value;
    if (selectedValue === 'pl') {
        langPlactive = 1; // Ustaw na 1 dla języka polskiego
    } else {
        langPlactive = 0; // Ustaw na 0 dla języka angielskiego
    }
}
    setTimeout(function(){
      document.getElementById("gameversion1").innerHTML = gameversion
    },1000);
            const loader = document.getElementById('loader');
            const logo = document.getElementById('logo');
            

            // Wyświetlenie logo
            setTimeout(function (){
            logo.style.display = 'block';
logo.style.animation = 'fadeIn 2s forwards rainbow 10s forwards infinite ';
            // Po 5 sekundach zaczynamy wygaszać logo
            setTimeout(() => {
                logo.style.animation = 'fadeOut 4s forwards rainbow 10s forwards infinite'; 
            }, 1000);

setTimeout(()=>{
  logo.style.animation = 'fadeOut 0.5s forwards';
},2000)
            setTimeout(() => {
              loader.style.animation = 'fadeOut 4s forwards';
              loader.style.pointerEvents = 'none';
              upadtegameslots()
            }, 2500);  
setTimeout(() => {
  loader.style.display = 'none';
  
}, 10000);
},5000)
    </script>

      <style>
      .health-bar-container {
        position: fixed;
z-index: 0;
        right: 5px;
        top: 0;
        width: 100px;
        height: 5px;
        background-color: #2E0000;
        /* Ciemnoczerwone tło - pasek straconego życia */
opacity: 0.8

      }
      .stamina-bar-container {
        position: fixed;
z-index: 0;
        right: 5px;
        top: 7px;
        width: 100px;
        height: 5px;
        background-color: #2E2A00;
        /* Ciemnoczerwone tło - pasek straconego życia */
opacity: 0.8

      }

.hunger-bar-container {
        position: fixed;
        display: none;
        z-index: 1;
        right: 0;
        top: 24px;
        width: 100px;
        height: 10px;
        background-color: #002E05;
}
.hunger-bar {
  height: 100%;
  background-color: #00C846;
  /* Czerwony - aktualne życie */
  width: 100%;
  /* Domyślnie pełne zdrowie */
}
      .health-bar {
        height: 100%;
        background-color: #FF0000;
        /* Czerwony - aktualne życie */
        width: 100%;
        /* Domyślnie pełne zdrowie */
      }
.stamina-bar {
        height: 100%;
        background-color: #DDD600;
        /* Czerwony - aktualne życie */
        width: 100%;
        /* Domyślnie pełne zdrowie */
      }
    </style>
 

    <div class="health-bar-container">
      <div id="healthBar" class="health-bar"></div>
    </div>
    <div class="stamina-bar-container">
      <div id="staminaBar" class="stamina-bar"></div>
    </div>
<div class="hunger-bar-container">
      <div id="hungerBar" class="hunger-bar"></div>
    </div>
    <script>
    let takedamage = new Audio('./hit.mp3');
let deathsound = new Audio('./dead.mp3');
let collectsound = new Audio('./collect.mp3');
    function playdeathsound() {
  deathsound.play();
}
let thundersound= new Audio('./tunder.mp3');
thundersound.volume=0.3
    function playthundersound() {
  thundersound.play();
}
let rainsound= new Audio('./rain1.mp3');
var rainsoundavailable=true;
rainsound.loop=true
rainsound.volume=0.3

    function playRain() {
      if(inhell!==1){
  rainsound.play();
}}
function stopRain() {
  rainsound.pause();
}
function playcollectsound() {
  collectsound.play();
}
function playhitmp3() {
  takedamage.play();
}
function checkIfItems(item, amount) {
            let count = yourItems.filter(i => i === item).length;
            return parseInt(count) >= amount;
        }

      let maxHP = 100; // Maksymalne HP
      let currentHP = 100; // Aktualne HP
      let currentStamina = 100; // Aktualna Stamina
      function updateHealth(amount) {
        // Aktualizacja HP, ograniczenie do wartości od 0 do maxHP
         if(checkIfItems("dracobuff",1)){
          if(amount<1){
          amount=amount/1.25
        }}else if(checkIfItems("hellbuff",1)){
          if(amount<1){
          amount=amount/1.10
        }} else if(checkIfItems("titaniumbuff",1)){
          if(amount<1){
          amount=amount/1.3
        }}
        currentHP = Math.max(0, Math.min(maxHP, currentHP + amount));
playhitmp3()
if(currentHP<50){
}

        const healthBar = document.getElementById('healthBar');
        const healthPercentage = (currentHP / maxHP) * 100;
        healthBar.style.width = healthPercentage + '%';
        if(currentHP<=1){
          currentHP=100;
          if(options.creativemode!==1){
          playdeathsound();
          options.dropany=1
          for(let i =0; i< yourItems.length; i++){
           if(yourItems[i]!==""&&yourItems[i]!==" "&&yourItems[i]!==undefined){
           dropItemAtPlayerPosition(yourItems[i])
          }}
          yourItems=[] 
       /*   chunks={}
          caveChunks={}
          abysschunks={}
          seachunks={}
          housechunks={}*/
          
if (isunderwater == 1) {
    seachunks = { ...chunks };
    chunks = overworldChunks;
    isunderwater = 0;

}if (generateChunk == 1) {
    caveChunks = { ...chunks };
    chunks = caveChunks;
    generateChunk = 0;

}  if (inhell == 1) {
    seachunks = { ...chunks };
    chunks = overworldChunks;
    inhell = 0;
    
}if (inabyss == 1) {
    abysschunks = { ...chunks };
    chunks = overworldChunks;
    inabyss = 0;
    
}if (isinhouse == 1) {
    housechunks = { ...chunks };
    chunks = overworldChunks;
    isinhouse = 0;
}
if(player.savedinworld=="house"){
    isinhouse=1
overworldChunks = { ...chunks };
chunks = housechunks;
}
 

offsetX = player.spawnX;
offsetY = player.spawnY;

renderedEnemies = [];
 
 
 



paused=0
          
          achievementget("You died LMFAO ",0)
         showTextInCanvas("YOU DIED")
         
          }
         const healthBar = document.getElementById('healthBar');
const healthPercentage = (currentHP / maxHP) * 100;
healthBar.style.width = healthPercentage + '%';
setTimeout(function (){
renderedEnemies=[]
//loadGameState(document.getElementById('savename').value || '');
playRandomMusic();
},200);
nightpower=nightpower-1 
if(nightpower<0){
 nightpower=0
}
        }
      }
      

      function updateHealth2(amount) {
        // Aktualizacja HP, ograniczenie do wartości od 0 do maxHP
         if(checkIfItems("dracobuff",1)){
          if(amount<1){
          amount=amount/1.25
        }}else if(checkIfItems("hellbuff",1)){
          if(amount<1){
          amount=amount/1.10
        }} else if(checkIfItems("titaniumbuff",1)){
          if(amount<1){
          amount=amount/1.3
        }}
        currentHP = Math.max(0, Math.min(maxHP, currentHP + amount));
//playhitmp3()
if(currentHP<50){
}

        const healthBar = document.getElementById('healthBar');
        const healthPercentage = (currentHP / maxHP) * 100;
        healthBar.style.width = healthPercentage + '%';
        if(currentHP<=1){
          currentHP=100;
          if(options.creativemode!==1){
          playdeathsound();
          options.dropany=1
          for(let i =0; i< yourItems.length; i++){
           if(yourItems[i]!==""&&yourItems[i]!==" "&&yourItems[i]!==undefined){
           dropItemAtPlayerPosition(yourItems[i])
          }}
          yourItems=[] 
       /*   chunks={}
          caveChunks={}
          abysschunks={}
          seachunks={}
          housechunks={}*/
 if (generateChunk == 1) {
    caveChunks = { ...chunks };
    chunks = caveChunks;
    generateChunk = 0;

}
if(isunderwater==1){
seachunks = { ...chunks };
chunks = overworldChunks;
isunderwater = 0;

}  if (inhell == 1) {
    seachunks = { ...chunks };
    chunks = overworldChunks;
    inhell = 0;
    
}if (inabyss == 1) {
    abysschunks = { ...chunks };
    chunks = overworldChunks;
    inabyss = 0;
    
}if (isinhouse == 1) {
    housechunks = { ...chunks };
    chunks = overworldChunks;
    isinhouse = 0;
}
if(player.savedinworld=="house"){
    isinhouse=1
overworldChunks = { ...chunks };
chunks = housechunks;
}
 

offsetX = player.spawnX;
offsetY = player.spawnY;

renderedEnemies = [];
 
 
paused=0
          
          achievementget("You died LMFAO ",0)
         showTextInCanvas("YOU DIED")
         
          }
         const healthBar = document.getElementById('healthBar');
const healthPercentage = (currentHP / maxHP) * 100;
healthBar.style.width = healthPercentage + '%';
setTimeout(function (){
renderedEnemies=[]
//loadGameState(document.getElementById('savename').value || '');
playRandomMusic();
},200);
nightpower=nightpower-1 
if(nightpower<0){
 nightpower=0
}
        }
      }
      

function updateStamina(amount) {
        // Aktualizacja HP, ograniczenie do wartości od 0 do maxHP
        if (amount > 0 && currentStamina<maxHP ) {
  if (currentHP > 90) {
    currentHP -= 0.15
    currentStamina += 0.8
    
const healthBar = document.getElementById('healthBar');
const healthPercentage = (currentHP / maxHP) * 100;
healthBar.style.width = healthPercentage + '%';
  }
}
        currentStamina= Math.max(0, Math.min(maxHP, currentStamina + amount));
        // Aktualizacja szerokości paska życia w procentach
        const staminaBar = document.getElementById('staminaBar');
        const staminaprocentage = (currentStamina / maxHP) * 100;
        staminaBar.style.width = staminaprocentage + '%';
        
        if(currentStamina<=1){
            if (checkIfItems("dracobuff", 1)) {
    updateHealth(-0.50)
        }else if (checkIfItems("hellbuff", 1)) {
           updateHealth(-0.35)
          }
          showTextInCanvas(" you are tried ")
          updateHealth(-0.25)
        }
      }

      // Inicjalizacja: ustawienie paska życia
      updateHealth(0);
    </script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> primoria ferox </title>
    <style>
    html{
      position:fixed; width:100%; height:100%;
    }
    *{
      user-select: none;
    }
        body {
            margin: 0;
            overflow: hidden;
            background:#000000;
        }
        canvas {
            display: block;
            position: absolute;
            top:50vh;
            left:50vw;
            width:calc(auto + 100px);
            height:calc(100% + 50px);
           transform: translate(-50%,-50%) scale(123%,100%);
            background-color: #87CEEB00; /* Niebo */
            image-rendering: pixelated; /* Wyłącz antyaliasing */
            z-index: -1;
        }
        .controls {
            position: absolute;
             
            bottom: 12vh;
            width: 70px;
            height: 70px;
            
            background: url('./joystick.png') ;
            background-size: 100%;
            opacity:0.5;
            image-rendering: pixelated;
            font-family: Arial, Helvetica, sans-serif;
            border-radius: 20%;
            
            display: flex;
            justify-content: center;
            align-items: center;
            
        }
        @media (min-width: 1024px) {
  .controls {
    display: none;
  }
}

        .thumb {
            width: 70px; margin: -50px;
            height: 70px;
            background: url('./thumb.png') ;
            background-size: 100%;
            opacity:1;
            filter: hue-rotate(40deg) , brightness(0.5);
            border-radius: 15%;
            position: absolute;
            pointer-events: none; /* Ignorowanie zdarzeń dotykowych dla thumb */
            image-rendering: pixelated;
            font-family: Arial, Helvetica, sans-serif;
        }
        .inventory {
            position: absolute;
            right: 10px;
            top: 10px;
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>

<div style="position: absolute; top:0; left:0; z-index: 9999999999999999999999999999999999999999; background: black; color: white;" id="ggsvbdnfnnfnnxkrgjgmvmfjrhf">
</div><script>function scanvarible(data){document.getElementById('ggsvbdnfnnfnnxkrgjgmvmfjrhf').innerText=data }</script>
<!--
<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script> 
-->
<style>

</style>
<canvas id="gameCanvas" width="420" height="350"></canvas>



    <style>
        #controller {
          position: absolute; bottom:20px ; left:20px ; 
            display: grid;
            grid-template-columns: repeat(3, 20px);
            grid-template-rows: repeat(3, 20px);
            gap: 3px;
        }
        .button {
            width: 20px;
            height: 20px;
            background-color: #19191959;
            color: #00DEFF8F;
            border: none;
            font-size: 10px;
            cursor: pointer;
        }
        .button:active {
            background-color: #0056b3;
        }
    </style>
<div id="controller" style="display:none;">
    <button class="button" data-direction="up-left">1</button>
    <button class="button" data-direction="up">2</button>
    <button class="button" data-direction="up-right">3</button>
    <button class="button" data-direction="left">4</button>
    <button class="button" data-direction="empty">5</button>
    <button class="button" data-direction="right">6</button>
    <button class="button" data-direction="down-left">7</button>
    <button class="button" data-direction="down">8</button>
    <button class="button" data-direction="down-right">9</button>
</div>
<div class="controls" id="joystick" style="display:block;">
    <div class="thumb" id="thumb" style="display: none;"></div>
</div>

<div class="inventory">


</div>

<script>
var paused=0;
 
// Obiekt przechowujący stany zmiennych
// Function to create and display a custom customAlert
function customAlert(message) {
    // Create a unique modal ID
    const modalId = `customAlertModal_${Date.now()}`;

    // Create the modal container
    const modal = document.createElement('div');
    modal.id = modalId;
    Object.assign(modal.style, {
        display: 'flex',
        position: 'fixed',
        zIndex: '99999',
        left: '0',
        top: '0',
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        overflow: 'scroll'
    });

    // Create the modal content box
    const modalContent = document.createElement('div');
    Object.assign(modalContent.style, {
        backgroundColor: '#1a1a1a', // Slightly lighter black
        color: 'white', // White text color
        fontFamily: '"Courier New", monospace', // Courier New font
        padding: '20px',
        border: '1px solid rgba(255, 255, 255, 0.1)', // Very subtle border
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.4)', // Soft shadow effect
        width: '300px',
        borderRadius: '8px',
        textAlign: 'center',
        position: 'relative',
        height: '200px',
        overflow: 'hidden scroll',
        overflowX: 'hidden scroll',
        whiteSpace : 'pre-wrap'
    });

    // Create the close button
    const closeButton = document.createElement('span');
    closeButton.innerHTML = '&times;';
    Object.assign(closeButton.style, {
      
        color: 'white', // White color for the close button
        fontSize: '24px',
        position: 'absolute',
        
        top: '10px',
        right: '10px',
        cursor: 'pointer'
    });
    closeButton.onclick = () => document.body.removeChild(modal);

    // Create the message paragraph
    const messageParagraph = document.createElement('p');
    messageParagraph.innerHTML = message;
    Object.assign(messageParagraph.style, {
        marginBottom: '20px',
        width: '300px',
        overflow: ' scroll',
  overflowX: ' scroll',
        
    });

    // Create the OK button
    const okButton = document.createElement('button');
    okButton.innerText = 'OK';
    Object.assign(okButton.style, {
        backgroundColor: '#4CAF50',
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer'
    });
    okButton.onclick = () => document.body.removeChild(modal);

    // Append elements to the modal content
    modalContent.appendChild(closeButton);
    modalContent.appendChild(messageParagraph);
    modalContent.appendChild(okButton);

    // Append modal content to the modal container
    modal.appendChild(modalContent);

    // Append the modal to the body
    document.body.appendChild(modal);
}

 var nocliping=0

let options = {
  autoclose: 0,
  dontbreakfloor:0,
  dropany:0,
  creativemode:0,
  autopause:1,
  fightmode:0,
  fancygraphic:0,
  quickinventory:1,
  noclip:0,
  zoomout:0,
  biggerzoomout:0,
  Fskipping:0,
  hideBlocksnumber:0,
  showEveryBlocksNumber:0,
  invertControls:0,
};
var blockSize = 32;
var playerX = 0
var playerY = 0
let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // Wyłącz antyaliasing
const inventory = {
    items: [], // Tablica przechowująca przedmioty
    maxSlots: 4, // Maksymalna liczba slotów w ekwipunku
};
const waterBuilder = ["stone_floor", "fiber_floor","grasslayer","yellow","violet","thistle","clayblock","clayblock1","dandelion","toadstool","sandblock2","gypsumblock","glass","fern","planks_floor","log_floor","ashblock","ashfloor","brickfloor","dirt","daffodil","flax" ,"myosotis" ,"fiber_floor","bed1","magnetite","nettle","stone_floor","emeraldfloor","sapphirefloor","rubyfloor","opalblock","opalblock","violetfloor","gypsum_dirt","gypsumfloor","gelfloor","gelblock","fiber_floor", "grasslayer", "yellow", "violet", "clayblock", "clayblock1", "dandelion", "toadstool", "sandblock2", "gypsumblock", "glass", "fern", "planks_floor", "log_floor", "ashblock", "ashfloor", "brickfloor", "daffodil", "fiber_floor", "bed1", "magnetite", "nettle", "stone_floor", "emeraldfloor", "sapphirefloor", "rubyfloor", "clayblock1", "clayblock","violetfloor","toadstool","stones","thistle","ryeroof","houseroof","housewall","brickhouse","gelblock","gypsum_dirt","roadfloor","gypsumblock","gypsumfloor","brickfloor2","grass2","forestgrasslayer","deadgrassfloor2","deadgrassfloor","forestgrasslayer","hill","climbhill","hellplank","abyssplank","polishedfloor","snowgrass2","dandelion","dandelion2"];
function isPlayerInWater() {
    let isInWater = false;

    // Najpierw sprawdzamy, czy gracz jest w bloku wody
    for (const block of renderedBlocks) {
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;

        if (
            playerCenterX >= block.x && playerCenterX <= block.x + blockSize &&
            playerCenterY >= block.y && playerCenterY <= block.y + blockSize
        ) {
            if (block.type === 'water'||block.type === 'underwaterentrance'||block.type === 'water1') {
                isInWater = true;
            }
            // Jeśli gracz jest na bloku z waterBuilder, zwróć false
            if (waterBuilder.includes(block.type)) {
                return false;
            }
        }
    }
    return isInWater;
}

let waterspeed = 3.1;
let norspeed = 5;
let playerSpeed = 5;
let Aplayerid=0;
let pvpactive=0; 
function updateTabCount(delta) {
    const currentCount = parseInt(localStorage.getItem('tabCount')) || 0;
    localStorage.setItem('tabCount', currentCount + delta);
}
function getOpenTabCount() {
    return parseInt(localStorage.getItem('tabCount')) || 0;
}
updateTabCount(1);
window.addEventListener('unload', () => {
    const currentCount = getOpenTabCount();
    if (currentCount > 0) {
        localStorage.setItem('tabCount', 0);
    }
});
window.addEventListener('storage', (event) => {
    if (event.key === 'tabCount' && parseInt(event.newValue) === 0) {
        localStorage.removeItem('tabCount');
    }
});
Aplayerid = getOpenTabCount();

let worldsdimensions = {
    "currentdim": "ovw",
    "ovw": {},
    "hll": {},
    "abs": {},
    "hse": {},
    "sea": {}
}
//alert(AplayerOnserver)
function multiplayerLoop(){
    
    asynchronousHostUpdate()
}
function asynchronousHostUpdate(){
    
    asynchronousClientUpdate()
}
function asynchronousClientUpdate() {

}

/*

i will add in full 1.5.8.5 

*/
let hostData={
    updatedKEYS:[] // {x,y, type , atbtm - atbottom no push use unshift etc , remove } 
    // for example {x:0,y:0, type:"grass" , remove:1}
    // {x:1,y:0,type:"wood",atbtm:1}  
    
}
let clientData={
    updatedKEYS:[]
}
function localStorageSET(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
}
function localStorageGET(key) {
    return JSON.parse(localStorage.getItem(key)) || [];
}
let yourname = "name";
let players = {
    "name":{x:0,y:0,items:[],currentAnimation:"moveleft",speed:2,frameIndex:0,frameCounter:0,savedinworld:"", visibleinworld:"", texture: new Image(), hp:200 , frameIndex: 0, currentAnimation: "movedown", items: [], width: 32, height: 32, frameIndex: 0,  frameSpeed: 2,},
  //  "test":{x:0,y:0,items:[],currentAnimation:"moveleft",speed:2,frameIndex:0,frameCounter:0,savedinworld:"", visibleinworld:"", texture: new Image(), hp:200 , frameIndex: 0, currentAnimation: "movedown", items: [], width: 32, height: 32, frameIndex: 0,  frameSpeed: 2, }
}
function drawPlayerInfo(playerData,name) {
    ctx.fillStyle = "white"; 
    ctx.font = "12px Arial"; 
    
    // Drawing nick above player   ( who reads comments btw ? )
    ctx.fillText(name, playerData.x - offsetX, playerData.y - offsetY - 10);
    ctx.font = "9px Arial";
    // Rysuj HP gracza
    ctx.fillStyle = "red";
    ctx.fillText(`${playerData.hp}/200`, playerData.x - offsetX-2, playerData.y - offsetY + 1);
}

function updateOthersAnimation() {
    for (const playerName in players) {
        if(playerName!==yourname){
        const playerData = players[playerName];
if(!playerData.frameCounter){
playerData.frameCounter=0;}if(!playerData.currentAnimation){
            playerData.currentAnimation="staydown"}
 if (!playerData.frameIndex || playerData.frameIndex == 0) {
    playerData.frameIndex = 0
}
const inWater = false
if (inWater) {
    updateStaminaForOtherPlayer(playerData, -0.2);
}     if (inWater || (checkIfItemsForPlayer(playerData, "broom", 1) && playerData.isflying == 1)) {
            if (playerData.currentAnimation=="moveright") playerData.currentAnimation = 'inwater_moveright';
            else if (playerData.currentAnimation=="moveleft") playerData.currentAnimation = 'inwater_moveleft';
            else if (playerData.currentAnimation=="moveup") playerData.currentAnimation = 'inwater_moveup';
            else if (playerData.currentAnimation=="movedown") playerData.currentAnimation = 'inwater_movedown';
        } else {
             
        }

        // Obsługa animacji klatek
        playerData.frameCounter++;
if (playerData.frameCounter >= playerData.frameSpeed) {

        playerData.frameIndex = (playerData.frameIndex + 1) % player.textures[playerData.currentAnimation].length;
        playerData.frameCounter = 0;
    }
let newTexture
 if (playerData.frameIndex +1 > player.textures[playerData.currentAnimation].length) {
 playerData.frameIndex -=1
 }
newTexture = player.textures[playerData.currentAnimation][playerData.frameIndex];


        // Wybór tekstury na podstawie buffów
        if (checkIfItemsForPlayer(playerData, "broom", 1) && playerData.isflying == 1) {
            newTexture = armourstextures.broom[playerData.currentAnimation][playerData.frameIndex];
        } else if (checkIfItemsForPlayer(playerData, "dracobuff", 1)) {
            newTexture = armourstextures.dracobuff[playerData.currentAnimation][playerData.frameIndex];
        } else if (checkIfItemsForPlayer(playerData, "hellbuff", 1)) {
            newTexture = armourstextures.hellbuff[playerData.currentAnimation][playerData.frameIndex];
        } else if (checkIfItemsForPlayer(playerData, "titaniumbuff", 1)) {
            newTexture = armourstextures.titaniumbuff[playerData.currentAnimation][playerData.frameIndex];
        }
        playerData.texture = newTexture;
         
    }}
    
}

 
function checkIfItemsForPlayer(playerData, itemName, quantity) {
    return false;
}

 

let player = {
    x: canvas.width / 2 -2,
    y: canvas.height / 2 +6.7,
    spawnX:0,spawnY:0,
    savedinworld:"",
    width: 32,
    height: 32,
    speed: 2,
    currentAnimation: 'staydown', // Domyślna animacja
    frameIndex: 0, // Indeks klatki
    frameSpeed: 2, // Szybkość zmiany klatek
    frameCounter: 0, // Licznik klatek
    texture: new Image(), // Obraz gracza
    textures: {
        staydown: ['./staydown.png'],
        stayup: ['./stayup.png'],
        moveup: ['./moveup0.png', './moveup1.png'],
        stayupright: ['./upright0.png'],
        stayupleft: ['./upleft0.png'],
        stayleft: ['./moveleft0.png'],
        stayright: ['./moveright0.png'],
        moveleft: ['./moveleft0.png', './moveleft1.png'],
        moveright: ['./moveright0.png', './moveright1.png'],
        
        movedown: ['./movedown0.png', './movedown1.png'],
        moveupright: ['./upright0.png','./upright1.png'],
        moveupleft: ['./upleft0.png','./upleft1.png'],
        stayupleft: ['./upleft0.png'],
        stayupright: ['./upright0.png'],
        
  
  inwater_moveleft: ['./swimleft0.png', './swimleft1.png'],
  inwater_moveright: ['./swimright0.png', './swimright1.png'],

  inwater_movedown: ['./swimdown0.png', './swimdown1.png'],
  inwater_moveup: ['./swimup0.png', './swimup1.png'],
  

        
    },
        
};
let armourstextures={
      "dracobuff": {
      staydown: ['./dracostaydown.png'],
      stayup: ['./dracostayup.png'],
      moveup: ['./dracoup1.png', './dracoup2.png'],
      stayupleft: ['./dracoleft1.png'],
      stayupright: ['./dracoright1.png'],
      stayright: ['./dracoright1.png'],
      stayleft: ['./dracoleft1.png'],
      moveright: ['./dracoright1.png', './dracoright2.png'],
      moveleft: ['./dracoleft1.png', './dracoleft2.png'],
      movedown: ['./dracodown1.png', './dracodown2.png'],
      moveupleft: ['./dracoleft1.png', './dracoleft2.png'],
      moveupright: ['./dracoright1.png', './dracoright2.png'],
      stayupleft: ['./dracoleft1.png'],
      stayupright: ['./dracoright1.png'],

      inwater_moveleft: ['./swimleft0.png', './swimleft1.png'],
      inwater_moveright: ['./swimright0.png', './swimright1.png'],
      inwater_movedown: ['./swimdown0.png', './swimdown1.png'],
      inwater_moveup: ['./swimup0.png', './swimup1.png'],
  },
  "titaniumbuff":{
    staydown: ['./titaniumstaydown.png'],
        stayup: ['./titaniumstayup.png'],
        moveup: ['./titaniummoveup1.png', './titaniummoveup2.png'],
        stayupright: ['./titaniummoveright1.png'],
        stayupleft: ['./titaniummoveleft1.png'],
        stayleft: ['./titaniummoveleft1.png'],
        stayright: ['./titaniummoveright1.png'],
        moveleft: ['./titaniummoveleft1.png', './titaniummoveleft2.png'],
        moveright: ['./titaniummoveright1.png', './titaniummoveright2.png'],
        movedown: ['./titaniummovedown1.png', './titaniummovedown2.png'],
        moveupright: ['./titaniummoveright1.png','./titaniummoveright2.png'],
        moveupleft: ['./titaniummoveleft1.png','./titaniummoveleft2.png'],
        stayupleft: ['./titaniummoveleft1.png'],
        stayupright: ['./titaniummoveright1.png'],
        
  inwater_moveleft: ['./swimleft0.png', './swimleft1.png'],
  inwater_moveright: ['./swimright0.png', './swimright1.png'],
  inwater_movedown: ['./swimdown0.png', './swimdown1.png'],
  inwater_moveup: ['./swimup0.png', './swimup1.png'],
  },
  "hellbuff": {
    staydown: ['./hellarmourstaydown.png'],
    stayup: ['./hellarmourstayup.png'],
    moveup: ['./hellarmourmoveup1.png', './hellarmourmoveup2.png'],
    stayupleft: ['./hellarmourmoveright1.png'],
    stayupright: ['./hellarmourmoveleft1.png'],
    stayright: ['./hellarmourmoveleft1.png'],
    stayleft: ['./hellarmourmoveright1.png'],
    moveright: ['./hellarmourmoveleft1.png', './hellarmourmoveleft2.png'],
    moveleft: ['./hellarmourmoveright1.png', './hellarmourmoveright2.png'],
    movedown: ['./hellarmourmovedown1.png', './hellarmourmovedown2.png'],
    moveupleft: ['./hellarmourmoveright1.png', './hellarmourmoveright2.png'],
    moveupright: ['./hellarmourmoveleft1.png', './hellarmourmoveleft2.png'],
    stayupleft: ['./hellarmourmoveright1.png'],
    stayupright: ['./hellarmourmoveleft1.png'],

    inwater_moveleft: ['./swimleft0.png', './swimleft1.png'],
    inwater_moveright: ['./swimright0.png', './swimright1.png'],
    inwater_movedown: ['./swimdown0.png', './swimdown1.png'],
    inwater_moveup: ['./swimup0.png', './swimup1.png'],
  },
    "smoking": {
      staydown: ['./smoking0.png',"./smoking3.png"],
      stayup: ['./smoking0.png',"./smoking3.png"],
      moveup: ['./smoking1.png',"./smoking3.png"],
      stayupleft: ['./smoking0.png',"./smoking3.png"],
      stayupright: ['./smoking0.png',"./smoking3.png"],
      stayright: ['./smoking0.png',"./smoking3.png"],
      stayleft: ['./smoking0.png',"./smoking3.png"],
      moveright: ['./smoking1.png',"./smoking3.png"],
      moveleft: ['./smoking1.png',"./smoking3.png"],
      movedown: ['./smoking1.png',"./smoking3.png"],
      moveupleft: ['./smoking1.png',"./smoking3.png"],
      moveupright: ['./smoking1.png',"./smoking3.png"],
      stayupleft: ['./smoking0.png',"./smoking3.png"],
      stayupright: ['./smoking0.png',"./smoking3.png"],

      inwater_moveleft: ['./swimleft0.png', './swimleft1.png'],
      inwater_moveright: ['./swimright0.png', './swimright1.png'],
      inwater_movedown: ['./swimdown0.png', './swimdown1.png'],
      inwater_moveup: ['./swimup0.png', './swimup1.png'],
  },
    "broom": {
    staydown: ['./broomdown.png','./broomdown2.png'],
    stayup: ['./broomup.png','./broomup2.png'],
    moveup: ['./broomup.png', './broomup2.png'],
    stayupright: ['./broomright.png','./broomright2.png'],
    stayupleft: ['./broomleft.png','./broomleft2.png'],
    stayright: ['./broomright.png','./broomright2.png'],
    stayleft: ['./broomleft.png','./broomleft2.png'],
    moveright: ['./broomright.png', './broomright2.png'],
    moveleft: ['./broomleft.png', './broomleft2.png'],
    movedown: ['./broomdown.png', './broomdown2.png'],
    moveupleft: ['./broomleft.png', './broomleft2.png'],
    moveupright: ['./broomright.png', './broomright2.png'],
    stayupleft: ['./broomleft.png','./broomleft2.png'],
    stayupright: ['./broomright.png', './broomright2.png'],

    inwater_moveleft: ['./broomleft.png', './broomleft2.png'],
    inwater_moveright: ['./broomright.png', './broomright2.png'],
    inwater_movedown: ['./broomdown.png', './broomdown2.png'],
    inwater_moveup: ['./broomup.png', './broomup2.png'],
  }
}
// Na początku ustaw teksturę na domyślną animację
//player.texture = player.textures[player.currentAnimation][0];
function loadTextures2(textures) {
    const loadedTextures = {};
    for (const key in textures) {
        loadedTextures[key] = textures[key].map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });
    }
    return loadedTextures;
}

// Ładowanie tekstur gracza
player.textures = loadTextures2(player.textures);

// Ładowanie tekstur zbroi
for (const armour in armourstextures) {
    armourstextures[armour] = loadTextures2(armourstextures[armour]);
}
 
 
player.texture = player.textures[player.currentAnimation][0];

let footstepSound = new Audio('./step2.mp3');
let windsound = new Audio('./wind.mp3');
footstepSound.loop = true; // Ustawienie pętli dla dźwięku
let swimSound = new Audio('./swim.mp3');
swimSound.loop = true; // Ustawienie pętli dla dźwięku
let noucant = new Audio('./block.wav');
noucant.volume=0.1
let craftsound = new Audio('./crafted.mp3');
let slashsound = new Audio('./slash.mp3');
let hitenemysound = new Audio('./hit (1).mp3');
let slashsound3 = new Audio('./slash2.mp3');
let slashsound4 = new Audio('./slash3.mp3');
function playFootstepSound() {
    if (footstepSound.paused) {
        footstepSound.play();
    }
}

function playslash() {
  let slashsound2 = new Audio();
  if(Math.random()<0.3){
   slashsound2.src = slashsound.src
  }else if (Math.random() < 0.5) {
  slashsound2.src = slashsound3.src
}else {
  slashsound2.src = slashsound4.src
}
  slashsound2.volume=0.5
    slashsound2.play();
}
function playslash2() {
  let slashsound2 = new Audio();
  if (Math.random() < 0.3) {
    slashsound2.src = slashsound.src
  } else if (Math.random() < 0.5) {
    slashsound2.src = slashsound3.src
  } else {
    slashsound2.src = slashsound4.src
  }
  slashsound2.volume = 0.32
  slashsound2.play();
}
function blockedsound() {
    noucant.play();
}
function playswimsound() {
  if (swimSound.paused) {
    swimSound.play();
  }
}
function playwindsound() {
  if (windsound.paused) {
    windsound.volume=0.15;
    windsound.play();
  }
}
function stopswimsound() {
  if (!swimSound.paused) {
    swimSound.pause();
    swimSound.currentTime = 0; // Resetowanie dźwięku po zatrzymaniu
  }
}
function stopFootstepSound() {
    if (!footstepSound.paused) {
        footstepSound.pause();
        footstepSound.currentTime = 0; // Resetowanie dźwięku po zatrzymaniu
    }
}
var issmoking=0;
let lastDirection = 'down'; // Domyślny kierunek patrzenia
function updatePlayerAnimation() {
  
    const inWater = isPlayerInWater(); // Sprawdzenie, czy gracz jest w wodzie
if(inWater ){
  if(checkIfItems("broom", 1) && isflying==1){
  }else{
  updateStamina(-0.2)
}}
    // Logika wyboru animacji
    if (inWater || (checkIfItems("broom", 1) && isflying == 1)) {
        if (moveRight) {player.currentAnimation = 'inwater_moveright';lastDirection="right"}
        else if (moveLeft){ player.currentAnimation = 'inwater_moveleft';lastDirection="left"}
        else if (moveUp) {player.currentAnimation = 'inwater_moveup';lastDirection="up"}
        else if (moveDown) {player.currentAnimation = 'inwater_movedown';lastDirection="down"}
        playerSpeed = waterspeed;
    } else {
        playerSpeed = norspeed;
        if (moveRight && moveUp) {player.currentAnimation = 'moveupright';lastDirection="up";}
        else if (moveLeft && moveUp) {player.currentAnimation = 'moveupleft';lastDirection="left";}
        else if (moveRight) {player.currentAnimation = 'moveright';lastDirection="right";}
        else if (moveLeft) {player.currentAnimation = 'moveleft';lastDirection="left";}
        else if (moveUp) {player.currentAnimation = 'moveup';lastDirection="up";}
        else if (moveDown){ player.currentAnimation = 'movedown';lastDirection="down";}
        else {
            if (player.currentAnimation.includes('move')) {
                if (player.currentAnimation === 'moveup'){ player.currentAnimation = 'stayup';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveupright'){ player.currentAnimation = 'stayupright';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveupleft'){ player.currentAnimation = 'stayupleft';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveleft'){ player.currentAnimation = 'stayleft';
                lastDirection="left"
                }
                if (player.currentAnimation === 'moveright'){ player.currentAnimation = 'stayright';
                lastDirection="right"
                }
                if (player.currentAnimation === 'movedown'){ player.currentAnimation = 'staydown';
                lastDirection="down"
                  
                }
            }
        }
    }

    if ((moveLeft || moveRight || moveUp || moveDown) && !inWater && !(checkIfItems("broom", 1) && isflying==1)) {
      
        playFootstepSound();
        stopswimsound()
    } else if((moveLeft || moveRight || moveUp || moveDown)&& !(checkIfItems("broom", 1) && isflying==1)) {
        stopFootstepSound();
        playswimsound()
    }else{
      stopswimsound()
      stopFootstepSound()
    }

    // Obsługa animacji klatek
    player.frameCounter++;
    if (player.frameCounter >= player.frameSpeed) {

        player.frameIndex = (player.frameIndex + 1) % player.textures[player.currentAnimation].length;
        player.frameCounter = 0;
    }

    // Ładowanie nowej tekstury gracza
    let newTexture 
            if (player.frameIndex +1 > player.textures[player.currentAnimation].length) {
            player.frameIndex -=1
        }
newTexture = player.textures[player.currentAnimation][player.frameIndex];
if (issmoking !== 0) {
     
    newTexture = armourstextures.smoking[player.currentAnimation][player.frameIndex];
// alert("_")
}else if (checkIfItems("broom", 1) && isflying == 1) {
  newTexture = armourstextures.broom[player.currentAnimation][player.frameIndex];
  
}else if (checkIfItems("dracobuff", 1)) {
    newTexture = armourstextures.dracobuff[player.currentAnimation][player.frameIndex];

} else   if (checkIfItems("hellbuff", 1)) {
  newTexture=armourstextures.hellbuff[player.currentAnimation][player.frameIndex];
  
}else if( checkIfItems("titaniumbuff",1)){
      newTexture = armourstextures.titaniumbuff[player.currentAnimation][player.frameIndex];
      
}else{
    
}

  //  newTexture.onload = function() {
        player.texture = newTexture;
  //  };

     
    nocliping = 0
if (isflying == 1) {
  nocliping = 1
}
if (options.noclip == 1) {
  nocliping = 1
}
}

function drawPlayer() {
    if (player.texture && player.texture.complete && player.texture.naturalWidth > 0) {
        ctx.drawImage(player.texture, player.x, player.y, player.width, player.height);
    } else {
        console.warn('Player texture not available.');
        // Opcjonalnie narysuj teksturę zastępczą
        // ctx.drawImage(defaultTexture, player.x, player.y, player.width, player.height);
    }
}
var cannotmove=0

const musicTracks = [
  "./primoria ferox 1.mp3",
  "./primoria ferox 3.mp3",
  "./new horizons above.mp3",
  "./tonight.mp3",
  "./Remember The Stars - Primoria.mp3",
  "./prime primoria (1).mp3",
  "./feroxia star.mp3",
  "./dayflow.mp3",
  "./Overflow drain.mp3",
  "./primoria resonance (1).mp3", 
  "./PrimoriaFerox.mp3",
  "./primoria-lunatic.mp3",
  "./sleeping over.mp3",
];
const musicTracks2 = [
  "./nightstand.mp3",
  "./unionworld.mp3",
  "./coldnight.mp3",
  "./ovw3.mp3",
  "./go-ahead.mp3",
  "./key1.mp3",
  "./chiptune2.mp3",
"./springstring.mp3",
"./Overflow drain.mp3",
"./chickenchip.mp3",
];
const nightmusicTracks = [
  "./night.mp3",
 "./night5.mp3",
 "./night4.mp3",
 "./%4NIGHTP - BBS -.mp3",
 "./tonight.mp3",
"./Comfortable Night.mp3",
"./Comfortable Night.mp3"
];
 
const audioInstances = musicTracks.map(track => new Audio(track));
const audioInstances2 = musicTracks2.map(track => new Audio(track));
const audioInstances3 = nightmusicTracks.map(track => new Audio(track));
 
const boss2 = new Audio('./boss2.mp3');
const boss3 = new Audio('./fleshbe2winus.mp3');
const boss4 = new Audio('./soulreinforcement.mp3');
const boss1 = new Audio('./electric force.mp3');
const trueTrack = new Audio('./TRUE.mp3');
const desertTrack = new Audio('./SandInEyes.mp3');
const snowyTrack = new Audio('./snowy.mp3');
const snowyTrack2 = new Audio('./Ethernia cold.mp3');
const abyssumTrack = new Audio('./abyssum.mp3');
const hellTrack = new Audio('./The Magma.mp3');
const aquamarine = new Audio('./aquamarine.mp3');
let currentTrack = null;

function playRandomMusic() {
    if(currentTrack){
    currentTrack.pause();
    currentTrack.currentTime = 0;
currentTrack = null
}
 if(!(checkIfHasEnemy("trueuniversehead",1)) && inabyss!==1 && inhell!==1 ){
  let randomIndex = getRandomInt(0, audioInstances.length - 1);
  
let randomTrack = audioInstances[randomIndex];
if(Math.random()<0.5){
 randomIndex = getRandomInt(0, audioInstances2.length - 1);
 randomTrack = audioInstances2[randomIndex];
}
if( nightpower>2.3){
randomIndex = getRandomInt(0, audioInstances3.length - 1 );
randomTrack = audioInstances3[randomIndex];
}
  if (currentTrack) {
    currentTrack.pause();
    currentTrack.currentTime = 0;
  }
if(randomTrack){
randomTrack.pause();
randomTrack.currentTime = 0;
}
  
  
  currentTrack = randomTrack;
currentTrack.play()//.catch(() => {
//});
  currentTrack.onended = function () {
      currentTrack.pause();
    currentTrack = null;
    const randomDelay = getRandomInt(1000, 2000);
    setTimeout(playMusic, randomDelay);
  };

  currentTrack.onerror = function () {
   currentTrack.pause();
   
currentTrack.currentTime = 0;
currentTrack=null
   setTimeout(playMusic, randomDelay);
/*    currentTrack.pause();
currentTrack.currentTime = 0;
    playRandomMusic(); // Próbuje odtworzyć inny utwór, jeśli wystąpi błąd
    */
  };
}}

function playMusic() {
  
  if(!(checkIfHasEnemy("trueuniversehead",1))&&!(checkIfHasEnemy("deepgodhead",1))&&!(checkIfHasEnemy("flesh",1))&&!(checkIfHasEnemy("insaneuniversegod",1)) &&!(checkIfHasEnemy("2medusa",1)) &&!(checkIfHasEnemy("darkeye",1)) ){
   
  if (isStayOn("water") && isPlayingSnowyMusic) {
  stopSnowyMusic();
  isPlayingSnowyMusic = false
}else if (((isStayOn("grass") || isStayOn("water"))&& !isStayOn("snowgrass")&&!isStayOn("snowgrass2"))) {
    isPlayingDesertMusic = false
    
  stopDesertMusic();
  
}else{
  if (isStayOn("desertsand")) {
    playDesertMusic();
    return;
  }else if (isPlayingDesertMusic) {
  stopDesertMusic();
}
if (isStayOn("snowgrass")||isStayOn("snowgrass2")) {
  playSnowyMusic();
  return;
} else if (isPlayingSnowyMusic) {
  stopSnowyMusic();
}
if(inhell!==1&& inabyss!==1){
 playRandomMusic();
}

}
if(inhell==1){
  playHelltrack();
} 
if (isunderwater === 1 && (!checkIfHasEnemy("trueuniversehead", 1))) {
    playAquaMarine()
}
if (inabyss === 1 && (!checkIfHasEnemy("trueuniversehead", 1))) {
    playAbyssumTrack()
  } else if (checkIfHasEnemy("trueuniversehead", 1)) {
    playTrueTrack();
  } else {
    
  }
   
}else if((checkIfHasEnemy("trueuniversehead",1))){
  playTrueTrack()
}else if ((checkIfHasEnemy("deepgodhead", 1))) {
 playBoss1()
}else if ((checkIfHasEnemy("insaneuniversegod", 1))) {
 playBoss4()
}else if ((checkIfHasEnemy("flesh", 1))) {
 playBoss3()
}else if ((checkIfHasEnemy("darkeye", 1))) {
  playBoss4()
}else if ((checkIfHasEnemy("2medusa", 1))) {
  playBoss4()
}
}
function playBoss4() {
  if (currentTrack) {
    currentTrack.pause();
    currentTrack.currentTime = 0;
  }
  // boss1.loop = true ;
  currentTrack = boss4
  currentTrack.play().catch(() => {
    playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
  });

  currentTrack = boss4
  // currentTrack.loop = true;
  boss4.onended = function() {
    setTimeout(playMusic, 1000);
  };

  boss4.onerror = function() {
    playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
  };
}
function playBoss3() {
 if (currentTrack) {
  currentTrack.pause();
  currentTrack.currentTime = 0;
 }
 // boss1.loop = true ;
 currentTrack = boss3
 currentTrack.play().catch(() => {
  playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
 });

 currentTrack = boss3;
 // currentTrack.loop = true;
 boss3.onended = function() {
  setTimeout(playMusic, 1000);
 };

 boss3.onerror = function() {
  playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
 };
}
function playBoss1() {
 if (currentTrack) {
  currentTrack.pause();
  currentTrack.currentTime = 0;
 }
// boss1.loop = true ;
 currentTrack = boss1
 currentTrack.play().catch(() => {
  playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
 });

 currentTrack = boss1;
// currentTrack.loop = true;
 boss1.onended = function() {
  setTimeout(playMusic, 1000);
 };

 boss1.onerror = function() {
  playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
 };
}
function playTrueTrack() {
  if (currentTrack) {
    currentTrack.pause();
    currentTrack.currentTime = 0;
  }
currentTrack= trueTrack
  currentTrack.play().catch(() => {
    playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
  });
  
  currentTrack = trueTrack;
  
  trueTrack.onended = function () {
    setTimeout(playMusic, 1000);
  };

  trueTrack.onerror = function () {
//    playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
  };
}
function playAbyssumTrack() {
  if (currentTrack) {
    currentTrack.pause();
    currentTrack.currentTime = 0;
  }

  abyssumTrack.play().catch(() => {
    playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
  });

  currentTrack = abyssumTrack;

  abyssumTrack.onended = function() {
    setTimeout(playMusic, 1000);
  };

  abyssumTrack.onerror = function() {
    playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
  };
}
function playAquaMarine() {
    if (currentTrack) {
        currentTrack.pause();
        currentTrack.currentTime = 0;
    }

    
    currentTrack = aquamarine;
currentTrack.play().catch(() => {
        playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
    });

    currentTrack.onended = function() {
        setTimeout(playMusic, 1000);
    };

    currentTrack.onerror = function() {
        playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
    };
}
function playHelltrack() {
  if (currentTrack) {
    currentTrack.pause();
    currentTrack.currentTime = 0;
  }

  hellTrack.play().catch(() => {
    playRandomMusic(); // Jeśli TRUE.mp3 nie odtwarza się, wybiera losowy utwór
  });

  currentTrack = hellTrack;

  hellTrack.onended = function() {
    setTimeout(playMusic, 1000);
  };

  hellTrack.onerror = function() {
    playRandomMusic(); // Próbuje odtworzyć losowy utwór, jeśli TRUE.mp3 ma błąd
  };
}
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

document.getElementById("gameCanvas").addEventListener("click", () => {

});

document.querySelector("html").addEventListener("click", () => {
  if (!currentTrack || currentTrack.paused) {
    playMusic();
  }

  if (isStayOn("desertsand")) {
    checkPlayerOnDesertSand();
  }
});



let isPlayingDesertMusic = false;
let isPlayingSnowyMusic =false;
function playDesertMusic() {
  if (currentTrack === desertTrack) return; // Jeśli już odtwarzamy pustynną muzykę, nic nie rób

  if (currentTrack) {
    fadeOut(currentTrack, () => {
      currentTrack.pause();
      currentTrack.currentTime = 0;
      startDesertTrack();
    });
  } else {
    startDesertTrack();
  }
}
function playSnowyMusic() {
  if (currentTrack === snowyTrack ||currentTrack === snowyTrack2 ) return; // Jeśli już odtwarzamy pustynną muzykę, nic nie rób

  if (currentTrack) {
    fadeOut(currentTrack, () => {
      currentTrack.pause();
      currentTrack.currentTime = 0;
      startSnowyTrack();
    });
  } else {
    startSnowyTrack();
  }
}

function startDesertTrack() {
  if(!(checkIfHasEnemy("trueuniversehead",1))){
  currentTrack = desertTrack;
  currentTrack.volume = 0;
  currentTrack.play().then(() => fadeIn(desertTrack));

  isPlayingDesertMusic = true;

  currentTrack.onended = () => {
    currentTrack = null;
    isPlayingDesertMusic = false;
  };
}}
function startSnowyTrack() {
  if(!(checkIfHasEnemy("trueuniversehead",1))){
      if(nightpower<1){
  currentTrack = snowyTrack;
  currentTrack.volume = 0;
  currentTrack.play().then(() => fadeIn(snowyTrack));
}else{
 currentTrack = snowyTrack2;
currentTrack.volume = 0;
currentTrack.play().then(() => fadeIn(snowyTrack2));
}
  isPlayingSnowyMusic = true;

  currentTrack.onended = () => {
    currentTrack = null;
    isPlayingSnowyMusic = false;
  };
}}
function checkPlayerOnDesertSand() {
  
   if (((isStayOn("grass") || isStayOn("water"))&& !isStayOn("snowgrass")) &&!isStayOn("snowgrass2") && isPlayingDesertMusic || isPlayingSnowyMusic) {
     stopSnowyMusic();
    stopDesertMusic();  // Zatrzymaj pustynną muzykę
  }else if (( isStayOn("snowgrass") ||isStayOn("snowgrass2") )&& !isPlayingSnowyMusic) {
      achievementget("Cold island",0)
    playSnowyMusic();
  }else if (isStayOn("desertsand") && !isPlayingDesertMusic) {
  playDesertMusic();
  achievementget("Hot island",0)
}
}

function stopDesertMusic() {
  if (currentTrack === desertTrack) {
    fadeOut(desertTrack, () => {
      desertTrack.pause();
      desertTrack.currentTime = 0;
      isPlayingDesertMusic = false;

      // Po zakończeniu wyciszenia pustynnej muzyki uruchom losową
        if (inabyss === 1) {
    playAbyssumTrack();
  } else if (checkIfHasEnemy("trueuniversehead", 1)) {
    playTrueTrack();
  } else {
    playRandomMusic();
  }
    });
  }
}
function stopSnowyMusic() {
  if ((isStayOn("water")||isStayOn("grass"))&& !isStayOn("snowgrass") &&!isStayOn("snowgrass2")) {
  if (currentTrack === snowyTrack) {
    fadeOut(snowyTrack, () => {
      snowyTrack.pause();
      snowyTrack.currentTime = 0;
      isPlayingDesertMusic = false;
      isPlayingSnowyMusic = false;

      // Po zakończeniu wyciszenia pustynnej muzyki uruchom losową
      if (inabyss === 1) {
        playAbyssumTrack();
      } else if (checkIfHasEnemy("trueuniversehead", 1)) {
        playTrueTrack();
      } else {
        playRandomMusic();
      }
    });
  }
}}

function fadeOut(audio, callback) {
  let volume = audio.volume;
  const interval = setInterval(() => {
    volume -= 0.05;
    if (volume <= 0) {
      clearInterval(interval);
      audio.volume = 0;
      if (callback) callback();
    } else {
      audio.volume = Math.max(volume, 0); // Zapewnia, że głośność nie spadnie poniżej 0
    }
  }, 100);
}

function fadeIn(audio) {
  let volume = 0;
  audio.volume = volume;
  const interval = setInterval(() => {
    volume += 0.05;
    if (volume >= 1) {
      clearInterval(interval);
      audio.volume = 1;
    } else {
      audio.volume = Math.min(volume, 1); // Zapewnia, że głośność nie przekroczy 1
    }
  }, 100);
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Wywoływanie funkcji co klatkę (np. w grze)





const textures = {};

// Definicja nazw tekstur i ich ścieżek
const textureSources = {
    rainbowbow: "./rainbowbow.png",
    quantumbow: "./quantumbow.png", 
    moltenbow: "./moltenbow.png",
    
carrot: "./carrot.png",
    sushi: "./sushi.png",
    shell1: "./shell1.png",
    shell2: "./shell2.png",
    shell3: "./shell3.png",
    wildcarrot: "./wildcarrot1.png",
carrot2: "./carrot1.png",

    soup: "./soup.png",
    
    plantmaker: "./plantmaker.png" ,
    cauldron: "./cauldron1.png" ,
    fountain: "./fountain1.png" ,
    textstone: "./textstone.png" ,
    nametag: "./nametag.png" ,
bottle: "./bottle.png" , bow: "./bow.png", arrows: "./arrow.png", hellbow: "./hellbow.png",  
nightbow: "./nightbow.png",
darkbow: "./darkbow.png",
powerfullarrows: "./powerfullarrow.png",
    goodarrows: "./goodarrow.png",
mercurybottle: "./mercurybottle.png",
mercuryliquid: "./mercuryliquid.png",
eggs: "./eggs.png",
eggshells: "./eggshells.png",
friedegg: "./friedegg.png",
feather: "./feather.png",
rarefeather: "./rarefeather.png",
mythicfeather: "./mythicfeather.png",
calciumacetylide: "./calciumacetylide.png",
cigarettes: "./cigarettes.png",
 
diamante: "./diamante.png",
diamante1: "./diamante.png",
cinnabargeode: "./cinnabargeode.png",

warporb: "./warporb1.png",
palm1: "./palm1.png",
palm3: "./palm1.png",
palm2: "./palm21.png",
palmlog: "./palm1.png",

palm12: "./palm1.png",
    palm32: "./palm1.png",
    coconutpalm: "./palm31.png",
    
coconut: "./coconut.png",

palmsapling: "./palmsapling.png",
stonesing: "./stonesing.png",

hallucinate: "./hallucinate1.png",
    candle: "./candle.png",
    a1bed: "./1bed.png",
    a2bed: "./2bed.png",
    can: "./can.png",
    carpet: "./carpet.png",
    polishedfloor: "./polishedfloor.png",
    road2: "./road2.png",
    abysslog: "./abysstree0.png",
    helllog: "./helltree0.png",
 hellsapling:"./hellsapling.png",
 abysssapling:"./abysssapling.png",
 helltree0:"./helltree1.png",
 helltree1:"./helltree1.png",
 helltree2:"./helltree2.png",
 hellwood:"./hellwood.png",
 hellgrass:"./hellgrass1.png",
 hellplank:"./hellplank1.png",
 abyssgrass: "./abyssgrass1.png",
abyssplank: "./abyssplank1.png",

 abyssgel:"./abyssgel.png",
 abysswood:"./abysswood.png",
 abysstree0:"./abysstree0.png",
 abysstree1:"./abysstree0.png",
 abysstree2:"./abysstree2.png",
  
 hell_boomerang:"./hell_boomerang.png",
 draco_boomerang:"./draco_boomerang.png",
 good_boomerang:"./good_boomerang.png",
 titanium_boomerang:"./titanium_boomerang.png",
 boomerang: './boomerang.png',
 dracobuff: './dracobuff.png',
 
 extinguished_campfire: './extinguished_campfire1.png',
 algae1: './algae1.png',
 algae0: './algae1.png',
 algae2: './algae3.png',
 goldnugget: './goldnugget.png',
 leafbowl: './leafbowl.png',
 leafbowlwithwater: './leafbowlwithwater.png',
 leafbowlwithcleanwater: './leafbowlwithcleanwater.png',
 briarempty: './briarempty.png',
 deepblues: './deepblues.png',
 climbhill: './climbhill.png',
 blueflower2: './blueflower2.png',
 redflower2: './redflower2.png',
 lightwhite: './lightwhite.png',
 hill_climber: './hill_climber.png',
 iron_shovel: './iron_shovel.png',
 statue1_1: './statue1_1.png',
 statue1_2: './statue1_2.png',
 statue2_1: './statue2_1.png',
 statue2_2: './statue2_2.png',
 blower: './blower.png',
 kiln: './kiln.png',
 lit_kiln: './lit_kiln1.png',
 iron_shovel: './iron_shovel.png',
 hill1: './hill_d.png',
 grassdeco: './grassdeco1.png',
 coast: './coast1.png',
 cactusempty: './cactusempty.png',
  godwand: './godwand.png',
  statueofgods: './statueofgods1.png',
  log0: './log0.png',
  deadgrassfloor: './deadgrass.png',
  deadgrassfloor2: './deadgrass.png',
  deadgrass: './dead grass.png',
  itemroad: './road.png',
  road: './road0.png',
  leaves: './leaves.png',
  grass2:"./grass2none.png",
  
  healthregenerator: './healthregenerator.png',
  staminaregenerator: './staminaregenerator.png',
  redanvil: './redanvil.png',
  magicwand: './magicwand.png',
  greenwand: './greenwand.png',
  magicwandofsharp: './wandofsharp.png',
  hyperblastwand: './hyperblastwand.png',
  forestgrass: './forestgrass.png',
  blush: './forestblush.png',
  forestleaf: './forestleaf.png',
  gravestone: './gravestone.png',
  forestgrasslayer:"./forestgrass.png",
  
  moltensword: './moltensword.png',
  broom: './broom.png',
  hellsword: './hellsword.png',
  knive: './knive.png',
  hellknive: './hellknive.png',
  
  hellwall: './hellwall2.png',
  fleshblock1: './fleshwall1.png',
  myosotis:"./Myosotis.png",
  granite: './granite.png',
  basalt: './basalt.png',
  hellbuff: './hellbuff.png',
  aquagem: './aquagem.png',
  darkore: './darkore.png',
  hellessence: './hellessence.png',
  celestialfragment: './celestialfragment.png',
  celestialspawner: './celestialspawner.png',
  darkore: './darkore.png',
  daffodil: './daffodil.png',
  flax:"./flax0.png",
  fleshblock2: './fleshblock1.png',
  lava: './lava1.png',
hell_entrance: './cave-entrance.png',
hell_escape: './cave-escape.png',
hellgem:"./hellgem.png",
hellwall:"./hellwall2.png",
moltenstone:"./moltenstone1.png",
hellcavestone:"./hellcavestone.png",

  titaniumbuff:"./titaniumbuff.png",
  lamp:"./lamp1.png",
  lamp2:"./lamp2.png",
  truegodsword:"./truegodsword.png",
  table:"./table.png",
  roadfloor:"./roadfloor.png",
  compass:"./compass.png",
  defensering:"./defensering.png",
  sing:"./sing.png",
  deepgodspawner:"./deepgodspawner.png",
  itemfence:"./itemfence.png",
fence:"./fence.png",
emptyblackberry:"./emptyblackberry.png",
brickfloor2:"./brickfloor2.png",
godstatue:"./godstatue.png",

geyser:"./geyser1.png",
magiclanter:"./magiclantern.png",
magicgem:"./magicgem.png",
desertcore:"./desertcore.png",
skull:"./skull.png",
bush:"./bush.png",
icemedalion:"./icemedalion.png",
speedmedalion:"./speedmedalion.png",
healmedalion:"./cursedmedalion.png",
icesword:"./icesword.png",
desertsand: './sandblock.png',
frozeningot:"./frozeningot.png",
snowflower:"./snowflower.png",
snowgrass:"./snowgrass.png",
snowgrass2:"./snowgrass.png",
snowpine1:"./snowpine1.png",
snowpine2:"./snowpine2.png",
snowpine3:"./snowpine3.png",
thistleseeds:"./thistleseeds.png",

abysscore:"./coreofabyss.png",
gel:"./gel.png",
abyssgem:"./abyssgem.png",
gelblock:"./gelfloor.png",
abyssfloor:"./abyssfloor.png",
abyssblock:"./abyssblock.png",
crystal1:"./crystal1.png",
crystal2:"./crystal2.png",
crystal3: "./crystal3.png",
abyssentrance: "./abyssportal1.png",
abyssescape: "./cave-escape.png",
universeechoes:"./universeechoes.png",
trueuniverseorb:"./trueuniverseorb.png",
trueuniversesword:"./trueuniversesword.png",
trueuniversespawner:"./trueuniversespawner.png",
seaweed:"./seaweed1.png",
seashiny:"./seashiny.png",
aquacore:"./aquacore.png",
aquagodshell:"./aquagodshell.png",

  universesword:"./universesword.png",
  universefragment:"./universefragment.png",
  shell:"./shell.png",
  corruptioncore:"./corruptioncore.png",
  underwaterescape:"./underwaterescape.png",
  underwaterentrance:"./underwaterentrance.png",
  coral1:"./coral1.png",
  coral2:"./coral2.png",
  underwatersand:"./underwatersand.png",
  underwatersandblock:"./underwatersandblock.png",
  aquawall:"./aquawall1.png",
  echofabric:"./echofabric.png",
  echorocks:"./echorocks.png",
  aquaspear:"./aquaspear.png",
  blossomblock:"./blossomblock.png",
  glowblossom:"./glowblossom.png",
  aquaore:"./aquaore.png",
  aquacaveblock:"./aquacaveblock.png",
  corruptedchalcopyrite:"./corruptedchalcopyrite.png",
  corruptedgrass:"./corruptedgrass.png",
  
  
  fleshvolume:"./fleshvolume.png",
  fleshdumbass:"./fleshdumbass.png",
  fleshsaber:"./fleshsaber.png",
  coloressence:"./colorsessence.png",
rainbow:"./rainbow.png",
  
  titaniumsword:"./titaniumsword.png",
  evileye:"./evileye.png",
  nightgem:"./nightgem.png",
  nightsword:"./nightsword.png",
  goodmace:"./godmace.png",
  goodsword:"./godsword.png",
  thundersword:"./thundersword.png",
  
  evileye:"./evileye.png",
  evileye:"./evileye.png",
  
  evilsummoner:"./evilsummoner.png",
  soulofsharp:"./soulofsharp.png",
  aquaticevent:"./aquaticevent.png",
  soulofsharp:"./soulofsharp.png",
  sharpsaw:"./sharpsaw.png",
  sharpmace:"./sharpmace.png",
  
  titaniummace:"./titaniummace.png",
  dandelion2:"./dandelion2.png",
dandelionseeds:"./dandelionseeds.png",
  candy:"./candy.png",
  energybowl:"./energybowl.png",
  healthbowl:"./healthbowl.png",
  
  salt: './salt.png',
  titaniumbar: './titaniumbar.png',
  titaniumdioxide: './titaniumdioxide.png',
  iron_mace: './iron-mace.png',
  iron_sword: './iron-sword.png',
  voltary_essence: './voltaryspawner.png',
 spikegod_essence: './spikegodspawner.png',
  unknown: './unknown1.png',
  violetfloor: './violetfloor.png',
   
  
  bread_sample: './bread_sample.png',
  gypsumhouse: './gypsumhouse.png',
  gypsumdoor: './gypsumdoor.png',
  gypsumroof: './gypsumroof.png',
  house_wall: './housewall.png',
heavybag: './heavybag.png',
  ryeroof: './ryeroof.png',
  poppy: './poppy.png',
  brickhouse: './brickhouse.png',
  rockhouse: './rockhouse.png',
  table: './table.png',
  
  voidblock: './void.png',
  housegrass: './housefloor.png',
  houseroof: './rooftop.png',
  door: './door.png',
  door2: './door2.png',
  yeast: './yeast.png',
  beer: './beer.png',
  rye_seeds: './rye_seeds.png',
  black_elderberry: './black_elderberry.png',
  black_elderberry_tree: './black_elderberry_tree.png',
  empty_black_elderberry: './empty_black_elderberry.png',
  black_elderberry2: './black_elderberry2.png',
  empty_black_elderberry2: './empty_black_elderberry2.png',
  mycelium: './mycelium.png',
  black_elderberries: './black_elderberries.png',
  fermentator: './fermentator.png',
  flour: './flour.png',
  sugar: './sugar.png',
  waterdrop: './waterdrop.png',
  fermentator: './fermentator.png',
  smoother: './smoother.png',
  bread: './bread.png',
  smooth_stone: './smooth-stone.png',
  
  
  emerald: './emerald.png',
  cave_entrance: './cave-entrance.png',
  gypsumfloor: './gypsumfloor.png',
  opal: './opal1.png',
  opalblock: './opalblock1.png',
  emeraldblock: './emeraldblock.png',
  sapphireblock: './sapphireblock.png',
  rubyblock: './rubyblock.png',
  sapphirefloor: './sapphirefloor.png',
  emeraldfloor: './emeraldfloor.png',
  rubyfloor: './rubyfloor.png',
  cinnabar: './cinnabar.png',
  mercury: './mercury.png',
  pipette: './pipete.png',
  ilmenite: './ilmenite.png',
  hook: './hook1.png',
  salmon: './salmon.png',
  cooked_salmon: './cooked_salmon.png',
  trout: './trout.png',
  cooked_trout: './cooked_trout.png',
  
  
  catchhook: './catchhook1.png',
  fishing_rod:"./fishing_rod.png",
  rye1: './rye.png',
  cavemakingpickaxe: './great-cave-making-pickaxe.png',
  customcaveentrance: './custom-cave-entrance.png',
  cave_escape: './cave-escape.png',
  cave_wall: './cavewall.png',
  cave_floor: './cavefloor.png',
  pickaxe: './pickaxe.png',
  ruby: './ruby.png',
  sapphire: './sapphire.png',
  pyrite : './pyrite.png',
  pyritestone : './pyritestone.png',
  cavewallwithsalt: './cavewallwithsalt.png',
  
stonewithgypsum: './cavewallwithgypsum.png',
  broken_cavewall:"./cavewall2.png",
water1: './water.png',
bed1: './fiberbed.png',
gypsumblock: './gypsumblock.png',
  copper: './copper.png',
  anvil: './anvil.png',
  stonedirt: './dirt-with-stones.png.png',
  larger_bag: './larger-bag.png',
  lit_furnace: './lit_furnace.png',
  furnace: './furnace.png',
  bunnmeat: './bunnmeat.png',
  cooked_bunnmeat: './cooked_bunnmeat.png',
  
  alchemy_table: './alchemy_table.png',
  gypsum: './gypsum.png',
  wood_manipulator: './wood_manipulator.png',
  sulfur: './sulfur.png',
  grains_of_sand: './sand2.png',
  planks: './planks.png',
  planks_floor: './planks_floor.png',
  gypsum_dirt: './gypsum_dirt.png',
  bone: './bone.png',
  bone_sword: './bone_sword.png',
  bowl: './bowl.png',
  bowl_with_seawater: './bowl_with_seawater.png',
  bowl_with_water: './bowl_with_water.png',
  sandblock2: './sandblock.png',
  sand2: './sandblock.png',
  glass: './glass.png',
  cactus: './cactus.png',
  cactus_fruit: './cactus-fruit.png',
  rye: './rye.png',
  flour: './flour.png',
  honey_mushrooms : './honey-mushroom.png',
iron: './iron.png',
iron_bar: './iron-bar.png',
copper_bar: './copper-bar.png',
copper: './copper.png',
extrabag: './extra-bag.png',
fiber_fabric: './fiber-fabric.png',
magnetite_powder: './magnetite-powder.png',
coal: './coal.png',
iron_spear: './iron-spear.png',
copper_spear: './copper-spear.png',

  long_spear: './long-spear.png',
  hand_torch: './hand-torch.png',
  magnetite: './magnetite.png',
  raw_sharkmeat: './raw_sharkmeat.png',
  cooked_sharkmeat: './cooked_sharkmeat.png',
    grass: './grass.png',
    coal: './coal.png',
    sapling: './sapling.png',
pointed_stick: './pointed_stick.png',
    clay: './clay.png',
  clayblock1: './clayblock.png',
  clayblock: './clayblock.png',
  brick: './brick.png',
  brickwall: './brickwall.png',
  brickfloor: './brickfloor.png',
  ash: './ash1.png',
  ashfloor: './ashblock.png',
    dirt: './dirt.png',
    tree0: './tree0.png',
    tree1: './tree1.png',
    tree2: './tree2.png',
    birch0: './birch0.png',
    birch1: './birch1.png',
    birch2: './birch2.png',
    tallgrass: './grass2.png',
    rock: './rock.png',
    yellow: './yellow.png',
    dirty_water: './dirty-water.png',
    water: './water.png',
    stones: './stones.png',
    sticks: './sticks.png',
    briar: './briar.png',
    kite1: './kite.png',
    kite: './kite.png',
    nettle: './nettle.png',
    thistle: './thistle.png',
    thistle1: './thistle.png',
    yew0: './yew0.png',
    yew1: './yew1.png',
    pine0: './pine0.png',
    pine1: './pine1.png',
    pine2: './pine2.png',
    violet: './violet.png',
    treebark: './treebark.png',
    shiny: './shine.png',
    toadstool: './toadstool.png',
    fern: './fern.png',
    blackberry: './blackberry.png',
    dandelion: './dandelion.png',
    sand: './sandblock.png',
    chalcopyrite: './chalcopyrite.png',
    stone_floor: './stone_floor.png',
    stone_wall: './stone_wall.png',
    fiber_floor: './fiber_floor.png',
    log_wall: './woodblock.png',
    thistleroot: './thistleroot.png',
  cooked_thistleroot: './cooked_thistleroot.png',
"blackberry-fruit": './blackberry-fruit.png',

    "fiber": "./fiber.png",
            "bigrock": "./largerock.png",
            "stone": "./stones.png",
            "sharpstone": "./sharpstone.png",
            "stick": "./sticks.png",
            "longstick": "./longstick.png",
            "woodboard": "./board.png",
            "treebark": "./treebark.png",
            "yew": "./yew-fruit.png",
            "briar-fruit": "./briar-fruit.png",
            "resin": "./resin.png",
         
"handdrill-kit": "./handdrill.png",
"fireroll": "./fireroll.png",
"cordage": "./cordage.png",
"dowel": "./dowel.png",
"log": "./tree0.png",
"stone_axe": "./stone_axe.png",
"stone_scyte": "./stone_scyte.png",
"fireplow": "./fireplow.png",
"birch-powder": "./birch-powder.png",
torch:"./torch.png", 
campfire:"./campfire.png",
ignited_fiber  :"./embered_fiber.png",
log_floor  :"./log_floor.png",
stoneshovel  :"./shovel.png",
grasslayer  :"./grass.png",
decrafter  :"./decrafter.png",
};
 

function loadWeaponTextures() {
   
}

 


const animatedTextures = {
    hallucinate: {
        frames : ["./hallucinate1.png","./hallucinate2.png","./hallucinate3.png","./hallucinate4.png","./hallucinate5.png","./hallucinate6.png",],
        speed:0.5
    },
warporb: {
    frames: ['./warporb1.png', './warporb2.png'],
    speed: 1.5
},
wildcarrot: {
    frames: ['./wildcarrot1.png', './wildcarrot2.png'],
    speed: 1.5
},
carrot2: {
    frames: ['./carrot1.png', './carrot2.png'],
    speed: 1.5
},

palm2: {
    frames: ['./palm21.png', './palm22.png'],
    speed: 1.5
},

cauldron: {
    frames: ['./cauldron1.png', './cauldron2.png'],
    speed: 1.5
},
fountain: {
    frames: ['./fountain1.png', './fountain2.png'],
    speed: 0.5
},
coconutpalm: {
    frames: ['./palm31.png', './palm32.png'],
    speed: 1.5
},
hellplank: {
    frames: ['./hellplank1.png', './hellplank2.png'],
    speed: 1.5
},
abyssplank: {
    frames: ['./abyssplank1.png', './abyssplank2.png'],
    speed: 1.5
},
 abyssgrass: {
    frames: ['./abyssgrass2.png', './abyssgrass1.png'], 
    speed: 0.7
},
hellgrass: {
    frames: ['./hellgrass2.png', './hellgrass1.png'],
    speed: 0.7
},
abysstree1: {
    frames: ['./abysstree1.png', './abysstree0.png'],
    speed: 1.7
},
abysstree0: {
    frames: ['./abysstree1.png', './abysstree0.png'],
    speed: 1.7
},
helltree1: {
    frames: ['./helltree1.png', './helltree0.png'],
    speed: 1.7
},
helltree0: {
    frames: ['./helltree1.png', './helltree0.png'],
    speed: 1.7
},
 algae1: {
 frames: ['./algae1.png', './algae2.png'],
 speed: 0.5
},
algae0: {
 frames: ['./algae1.png', './algae2.png'],
 speed: 0.5
},
 statueofgods: {
  frames: ['./statueofgods1.png', './statueofgods2.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
    torch: {
        frames: ['./torch.png', './torch2.png'], // Klatki animacji
        speed: 0.2  // Czas trwania jednej klatki (w sekundach)
    },
lamp2: {
  frames: ['./lamp2.png', './lamp3.png'], // Klatki animacji
  speed: 0.1 // Czas trwania jednej klatki (w sekundach)
},
hellwall: {
  frames: ['./hellwall1.png', './hellwall2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
lava: {
  frames: ['./lava1.png', './lava1.png'], // Klatki animacji
  speed: 0.3 // Czas trwania jednej klatki (w sekundach)
},
hellwall2: {
  frames: ['./hellwall1.png', './hellwall2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
moltenstone: {
  frames: ['./moltenstone1.png', './moltenstone2.png'], // Klatki animacji
  speed: 5 // Czas trwania jednej klatki (w sekundach)
},
abyssentrance: {
  frames: ['./abyssportal1.png', './abyssportal2.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
seaweed: {
      frames: ['./seaweed1.png', './seaweed2.png'], // Klatki animacji
      speed: 1.5 // Czas trwania jednej klatki (w sekundach)
    },
    geyser: {
  frames: ['./geyser2.png', './geyser3.png', './geyser4.png', './geyser5.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
aquawall: {
  frames: ['./aquawall1.png', './aquawall2.png'], // Klatki animacji
  speed: 0.3 // Czas trwania jednej klatki (w sekundach)
},
    unknown: {
  frames: ['./unknown1.png', './unknown2.png'], // Klatki animacji
  speed: 0.1 // Czas trwania jednej klatki (w sekundach)
},
water: {
  frames: ['./water.png', './water2.png'], // Klatki animacji
  speed: 0.9 // Czas trwania jednej klatki (w sekundach)
},
coast: {
 frames: ['./coast1.png', './coast2.png'], // Klatki animacji
 speed: 0.9 // Czas trwania jednej klatki (w sekundach)
},
water1: {
  frames: ['./water.png', './water2.png'], // Klatki animacji
  speed: 0.9 // Czas trwania jednej klatki (w sekundach)
},
rye: {
  frames: ['./rye.png', './rye2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
grassdeco: {
 frames: ['./grassdeco1.png', './grassdeco2.png'], // Klatki animacji
 speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
opalblock: {
  frames: ['./opalblock1.png', './opalblock2.png', './opalblock3.png', './opalblock4.png', './opalblock5.png', './opalblock6.png', './opalblock7.png', './opalblock8.png', './opalblock9.png', './opalblock10.png', './opalblock11.png','./opalblock12.png','./opalblock13.png'], // Klatki animacji
  speed: 0.1 // Czas trwania jednej klatki (w sekundach)
},
opal: {
  frames: ['./opal1.png', './opal2.png', './opal3.png', './opal4.png', './opal5.png', './opal6.png', './opal7.png', './opal8.png', './opal9.png', './opal10.png', './opal11.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
    lit_furnace: {
  frames: ['./lit_furnace.png', './lit_furnace1.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
lit_kiln: {
 frames: ['./lit_kiln1.png', './lit_kiln2.png'], // Klatki animacji
 speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
tallgrass: {
  frames: ['./grass2.png', './grass3.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
    campfire: {
  frames: ['./campfire.png', './campfire2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
   },
 extinguished_campfire: {
 frames: ['./extinguished_campfire1.png', './extinguished_campfire2.png'], // Klatki animacji
 speed: 0.3 // Czas trwania jednej klatki (w sekundach)
},

   hook: {
  frames: ['./hook1.png', './hook2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},
catchhook: {
  frames: ['./catchhook1.png', './catchhook2.png'], // Klatki animacji
  speed: 0.2 // Czas trwania jednej klatki (w sekundach)
},
};

// Funkcja do ładowania tekstur, w tym animowanych
function loadTextures() {
    // Ładowanie statycznych tekstur
    

    // Ładowanie animowanych tekstur
    for (const [key, animData] of Object.entries(animatedTextures)) {
        const frames = animData.frames.map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });
        animatedTextures[key] = {
            frames: frames,
            speed: animData.speed,
            currentFrame: 0,
            lastFrameTime: 0
        };
    }
}
loadTextures()

// Tworzenie nowych obiektów Image i przypisanie źródeł
for (const [name, src] of Object.entries(textureSources)) {
    textures[name] = new Image();
    textures[name].src = src;
}

var offsetX = 0;
var offsetY = 0;

let chunks = {};

// Zmienne ruchu
let moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
var worldseed="83455AB5CC2092";










let caveChunks = {};
let overworldChunks = null;
let generateCave = 0; // 0 - tryb normalny, 1 - w jaskini
let allCaveEntrances = [];
let allHellCaveEntrances = [];
let delayChangeDimension=0
function checkCaveEntranceOrExit(playerX, playerY) {
  }
/*

Gdy dodajesz struktury i losowe elementy pamietaj by dać to do json object
*/
  
// cavesempty cavesempty3 cavesempty4 cavesempty5 cavesempty6 cavesempty2 deadlands grassroad islands
let cavesempty = [];
function generateCaves(x, y) {
    const islandChance = 0.05; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 100) + 10;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false; }
let cavesempty3 = [];
function generateCaves3(x, y) {
    const islandChance = 0.05; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty3) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 100) + 10;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty3.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false; }

let cavesempty4 = [];
function generateFlesh(x, y) { 
    const islandChance = 0.005; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty4) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 200) + 10;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty4.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false;
}
let cavesempty5 = [];
function generateGranite(x, y) { 
    const islandChance = 0.005; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty5) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 200) + 10;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty5.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false;
}
let cavesempty6 = [];
function generateBasalt(x, y) { 
    const islandChance = 0.005; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty6) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 200) + 10;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty6.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false;
}

let cavesempty2 = [];
function generateCaves2(x, y) {
    const islandChance = 0.05; 
    const minDistance = 500;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of cavesempty2) {
        const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
        const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 200) + 40;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
cavesempty2.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
        if(dta<=radius){ return true; }else{ return false;}
    }
return false; }


let deadlands = [];
function generateDeadLand(x, y) {
    const islandChance = 0.0015; 
    const minDistance = 1000;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of deadlands) {
const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 100) + 80;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
deadlands.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
if(dta<=radius){ return true; }else{ return false;}}
return false; }

let grassroad = [];
function generategrassroad(x, y) {
    const islandChance = 0.05; 
    const minDistance = 1000;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    for (const island of grassroad) {
const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);
        if (distToIslandCenter <= island.radius) {
if (distanceFromEdge < 30) {return true;
} else { return true;}}}
if (distanceFromCenter > minDistance && Math.random() < islandChance) {
const radius = Math.floor(Math.random() * 60) + 30;
const islandX = x + Math.floor(Math.random() * 300) - 250; 
const islandY = y + Math.floor(Math.random() * 300) - 250;
grassroad.push({ x: islandX, y: islandY, radius: radius });
let dta=Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2)
if(dta<=radius){ return true; }else{ return false;}}
return false; }

let islands = [];

function generateRandomIsland(x, y) {
  const islandChance = 0.012; // Szansa na wygenerowanie nowej wyspy
  let addchance=0.015
  const snowIslandChance = 0.020+addchance;
  const desertIslandChance = 0.010+addchance;
  const ForestIslandChance = 0.080+addchance;
  const minDistance = 750; // Minimalna odległość, po której mogą zacząć się generować wyspy
  const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
  for (const island of islands) {
    const distToIslandCenter = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
    const distanceFromEdge = Math.abs(distToIslandCenter - island.radius);

    if (distToIslandCenter <= island.radius) {
      if (island.isSnowy) {
        return distanceFromEdge < 30 ? 'snowgrass' : 'snowgrass'; // Śnieżna wyspa
      } else if (island.isDesert) {
       
        return 'desertsand'; // Pustynia
       
      }else if (island.isForest) {
       
        return 'forestgrass'; // Las
       
      }
      if( distanceFromEdge < 65){
       return "coast"
      }else if(distanceFromEdge < 120){
       return Math.random()<0.05 ? "magnetite" : "sand"
      }else {
 return "grass"
}
     // return distanceFromEdge < 30 ? 'sand' : 'grass'; // Normalna wyspa
    }
  }

  if (distanceFromCenter > minDistance && Math.random() < islandChance) {
    const randomType = Math.random();
    const isSnowy = randomType < snowIslandChance;
    const isDesert = randomType >= snowIslandChance && randomType < (snowIslandChance + desertIslandChance);
    const isForest = randomType < ForestIslandChance;
    
    let radius;
    if (isSnowy) {
      radius = Math.floor(Math.random() * 500) + 300; // Duże śnieżne wyspy (300–800)
    } else if (isDesert) {
      radius = Math.floor(Math.random() * 750) + 450; // Pustynne wyspy (450–1200)
    }else if (isForest) {
      radius = Math.floor(Math.random() * 750) + 500; // Pustynne wyspy (450–1200)
    }else {
      radius = Math.floor(Math.random() * 375) + 150; // Normalne wyspy (50–425)
    }

    const islandX = x + Math.floor(Math.random() * 300) - 250; // Losowe przesunięcie wyspy
    const islandY = y + Math.floor(Math.random() * 300) - 250;

    islands.push({ x: islandX, y: islandY, radius, isSnowy, isDesert , isForest });

    const distToNewIsland = Math.sqrt((x - islandX) ** 2 + (y - islandY) ** 2);
    if (distToNewIsland <= radius) {
      if (isSnowy) return 'snowgrass';
      if (isDesert) return 'desertsand';
      if (isForest) return 'forestgrass';
      return 'grass';
    }
  }

  return 'water';
}
let hills = [];



function generateHills(x, y) {
    const islandChance = 0.004;
    const minDistance = 400;
    const distanceFromCenter = Math.sqrt(x ** 2 + y ** 2);
    
    // Sprawdzenie odległości między nowym wzgórzem a istniejącymi
    for (const island of hills) {
        const distToIslandCenterX = Math.abs(x - island.x);
        const distToIslandCenterY = Math.abs(y - island.y);
        const minRequiredDistance = (island.width)  // 
        const minRequiredDistance2 = (island.width)-34
        if (distToIslandCenterX < minRequiredDistance2 && distToIslandCenterY < minRequiredDistance2 && distToIslandCenterX > 1*34 && distToIslandCenterY > 1*34 ) {
            console.log(minRequiredDistance);
            return "inside";
        }

        // Sprawdzanie, czy nowe wzgórze nachodzi na istniejące
        if (distToIslandCenterX < minRequiredDistance && distToIslandCenterY < minRequiredDistance) {
            return "hill"; // Punkt znajduje się w zasięgu istniejącego wzgórza
        }
    }

    // Generowanie wzgórza, jeśli spełnione są warunki
    if (distanceFromCenter > minDistance && Math.random() < islandChance) {
     let scale =(Math.random()*6)+5
        const width = scale * 32;  // Szerokość: 4 bloki
        const height = scale * 32; // Wysokość: 4 bloki
        const islandX = x;
        const islandY = y;

        hills.push({ x: islandX, y: islandY, width: width, height: height });

        return true; // Wzgórze zostało dodane pomyślnie
    }

    return false; // Wzgórze nie zostało dodane
}




var dataChunksStructures = {
  cavesempty: cavesempty,
  cavesempty3: cavesempty3,
  cavesempty4: cavesempty4,
  cavesempty5: cavesempty5,
  cavesempty6: cavesempty6,
  cavesempty2: cavesempty2,
  deadlands: deadlands,
  grassroad: grassroad,
  islands: islands,
  hills:hills
}
let hellchunks = {};
let housechunks = {};
let abysschunks = {};
let seachunks = {};
let alldoors = [];
let doorsisthere = [];
let allunderwater = [];
let allabyssportals = [];
let isinhouse = 0;
let isunderwater = 0;
let inabyss = 0;
let isflying=0
 
let inhell = 0;
function generateChunk(chunkX, chunkY) {
  const chunkKey = `${Math.floor(chunkX)},${Math.floor(chunkY)}`;
 // if(!isinhouse){
  if (chunks[chunkKey]) return;
// }

  const blocks = [];
  for (let i = 0; i < 1; i++) {
    for (let j = 0; j < 1; j++) {
      const blockPosX = chunkX * blockSize + i * blockSize;
      const blockPosY = chunkY * blockSize + j * blockSize;
      const distanceFromSpawn = Math.sqrt(blockPosX ** 2 + blockPosY ** 2);

      // Inicjalizacja typu bloku w zależności od odległości
      let blockType;
      const isInSpawnArea = Math.abs(chunkX-5) <= 4 && Math.abs(chunkY-5) <= 4;
      if(isinhouse!==1){
if (generateCave === 1|| isunderwater==1|| inabyss==1|| inhell==1) {
if(inabyss==1){
  
}
}else if (distanceFromSpawn > 890) {
        blockType = generateRandomIsland(blockPosX, blockPosY) // Generowanie wysp
        if(blockType=="water"){
         if (Math.random() < 0.002) {
         blockType = 'underwaterentrance';
         allunderwater.push([blockPosX, blockPosY])
        } else {
         blockType = 'water'; // Woda poza 1600 bloków
        }
        }
      } else if (distanceFromSpawn > 830) {
        
        if(Math.random()<0.005){
          blockType = 'underwaterentrance';
          allunderwater.push([blockPosX, blockPosY])
        }else{
          blockType = 'water'; // Woda poza 1600 bloków
        }
      }else if (distanceFromSpawn > 686 && distanceFromSpawn < 760) {
        blockType =  Math.random() < 0.1 ? 'magnetite' : 'sand'; // Piasek między 1000 a 1600 bloków
      }else if (distanceFromSpawn > 700) {
 blockType = 'coast';
} else {
        
      }
       
 if (blockType === 'desertsand') {

  if (Math.random() < 0.003) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'skull' });
}else if (Math.random() < 0.002) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell1' });
}else if (Math.random() < 0.002) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell2' });
}else if (Math.random() < 0.002) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell3' });
}else if (Math.random() < 0.005) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: (j ) * blockSize, type: 'palm1' });
    blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'palm3' });
blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'palm2' });
  }else if (Math.random() < 0.004) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'bone' });
} else if (Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'magnetite' });
  } else if (Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'bush' });
  } else {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'desertsand' });
  }

}else if (blockType === 'forestgrass') {
if (blockType == "forestgrass") {
  let data123 = generateDeadLand(blockPosX, blockPosY)
  if (data123) {
    blockType = "deadgrass";
  }
}
if (blockType === 'forestgrass') {
  if (Math.random() < 0.15) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
     blocks.push({ x: i * blockSize, y: j * blockSize, type: 'pine0' });
 blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'pine1' });
 blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'pine2' });
 blocks.push({ x: i * blockSize, y: (j - 3) * blockSize, type: 'pine2' });
  } else if (Math.random() < 0.08) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestleaf' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'bigrock' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'longstick' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'log0' });
} else if (Math.random() < 0.02) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sticks' });
  } else if (Math.random() < 0.01) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'stones' });
}else if (Math.random() < 0.03) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'blackberry' });
}else if (Math.random() < 0.2) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'blush' });
}else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'kite1' });
}else {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'forestgrass' });
  }
}else{
  
  blockType = "deadgrassfloor"
  if (Math.random() < 0.008) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrassfloor' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'bone' });
  } else if (Math.random() < 0.2) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrassfloor' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'gravestone' });
  } else if (Math.random() < 0.4) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrassfloor' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'road' });
  } else if (Math.random() < 0.4) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrassfloor' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrass' });
  } else {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deadgrassfloor' });
  }


}
}else if (blockType === 'snowgrass') {

    if (Math.random() < 0.1) {
      blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
        blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowpine1' });
        blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'snowpine2' });
        blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'snowpine3' });
        blocks.push({ x: i * blockSize, y: (j - 3) * blockSize, type: 'snowpine3' });
    } else if (Math.random() < 0.08) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowflower' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'longstick' });
}else if (Math.random() < 0.01) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sticks' });
}else if (Math.random() < 0.01) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'stones' });
} else {
        blocks.push({ x: i * blockSize, y: j * blockSize, type: 'snowgrass' });
    }
} else if (blockType === 'dirt'  ||blockType === 'sand' || blockType === 'water' || blockType=="underwaterentrance" || blockType === 'coast') {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: blockType });
  if (blockType === 'sand') {
 if (Math.random() < 0.004) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell1' });
} else if (Math.random() < 0.004) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell2' });
} else if (Math.random() < 0.004) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sand' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shell3' });
}else if (Math.random() < 0.022) {
     
blocks.push({ x: i * blockSize, y: (j ) * blockSize, type: 'palm12' });
blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'palm32' });
blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'coconutpalm' });
}
  if (Math.random() < 0.02) {

    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'bone' });

  }else if (Math.random() < 0.04) {

  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cactus' });

}
}
} else {
  // Default behavior for grass
  if(generateCave!==1&& isunderwater!==1&& inabyss!==1&& inhell!==1){
    
 
if(!isInSpawnArea){
 let data123 = generateHills(blockPosX, blockPosY)
 if (data123) {
  if(data123=="hill"){
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blockType = "hill1";
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'hill1' });
  } else if (data123=="inside"){
   blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
   blockType = "hill1";
   blocks.push({ x: i * blockSize, y: j * blockSize, type: 'hill1' });
   if (Math.random() < 0.11) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'tree0' });
 blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'tree1' });
 blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'tree2' });
} else if (Math.random() < 0.05) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'pine0' });
 blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'pine1' });
 blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'pine2' });
 blocks.push({ x: i * blockSize, y: (j - 3) * blockSize, type: 'pine2' });
}else if (Math.random() < 0.2) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grassdeco' });
}else if (Math.random() < 0.22) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'deepblues' });
}else if (Math.random() < 0.22) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sticks' });
}else if (Math.random() < 0.22) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'lightwhite' });
}else if (Math.random() < 0.22) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'stones' });
}else if (Math.random() < 0.32) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'blueflower2' });
}else if (Math.random() < 0.32) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'redflower2' });
}
  }}
 }
 



if (blockType!=="hill1"){
if (!isInSpawnArea && Math.random() < 0.009) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass2' });
}else if (!isInSpawnArea && Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'tree0' });
    blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'tree1' });
    blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'tree2' });
  }else if (!isInSpawnArea && Math.random() < 0.01) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'birch0' });
  blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'birch1' });
  blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'birch2' });
}else if (!isInSpawnArea && Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'pine0' });
  blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'pine1' });
  blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'pine2' });
blocks.push({ x: i * blockSize, y: (j - 3) * blockSize, type: 'pine2' });
}else if (!isInSpawnArea && Math.random() < 0.02) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'rock' });
}else if (!isInSpawnArea && Math.random() < 0.005) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'wildcarrot' });
}else if (Math.random() < 0.03) {
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sticks' });
            }else if (Math.random() < 0.05) {
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'stones' });
            } else if (Math.random() < 0.15) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'yellow' });
}else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'daffodil' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'myosotis' });
}else if (Math.random() < 0.015) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'flax' });
}else if (Math.random() < 0.03) {
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'kite1' });
            } else if (Math.random() < 0.01) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'briar' });
}else if (Math.random() < 0.003) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'poppy' });
}else if (Math.random() < 0.002) {
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'black_elderberry' });
blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'black_elderberry2' });
          }else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'nettle' });
}else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'thistle1' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'violet' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'treebark' });
} else if (Math.random() < 0.2) {
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
                blocks.push({ x: i * blockSize, y: j * blockSize, type: 'tallgrass' });
            }else if (Math.random() < 0.12) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grassdeco' });
}else if (Math.random() < 0.01) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
    if (Math.random() < 0.3) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'hallucinate' });
  }
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'toadstool' });
} else if (Math.random() < 0.07) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'fern' });
}else if (Math.random() < 0.03) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'shiny' });
}else if (Math.random() < 0.005) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'blackberry' });
}else if (Math.random() < 0.04) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'dandelion' });
}else if (Math.random() < 0.004) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'chalcopyrite' });
}else if (Math.random() < 0.002) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_entrance' });

  allCaveEntrances.push([blockPosX, blockPosY])

}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'rye1' });
}else if (Math.random() < 0.02) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'blueflower2' });
} else if (Math.random() < 0.03) {
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
 blocks.push({ x: i * blockSize, y: j * blockSize, type: 'redflower2' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'honey_mushrooms' });
}else {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'grass' });
  
                blocks.push({ x: Math.floor( i * blockSize), y: Math.floor( j * blockSize), type: blockType });
                
            }
            
        }}else if(isunderwater!==1 && generateCave==1 && inabyss!==1&& inhell!==1){
          

/* 
CAVE GENERATOR
 
*/
let entranceX2;
let entranceY2;
const isCaveEntrance = allCaveEntrances.some(([entranceX, entranceY]) => {
  entranceX2=entranceX ; entranceY2=entranceY
  return entranceX === blockPosX && entranceY === blockPosY;
});
const isNearCaveEntrance = allCaveEntrances.some(([entranceX, entranceY]) => {
  return Math.abs(entranceX - blockPosX) <= blockSize * 3 && Math.abs(entranceY - blockPosY) <= blockSize * 3;
});
const shouldPlaceHole = Math.random() < 0.05; // Ustal prawdopodobieństwo tworzenia dziury

if (generateCaves(blockPosX, blockPosY)) {
  blocks.push({ x: 0, y: 0, type: 'cave_floor' });
  
}else if (generateGranite(blockPosX, blockPosY)) {
  blocks.push({ x: 0, y: 0, type: 'cave_floor' });
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'granite' });
}else {
if (shouldPlaceHole) {
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_floor' });
}else
if(isNearCaveEntrance){
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_floor' });
}else{
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_floor' });
if(Math.random()<0.05){
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sapphire' });
}else if (Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'ruby' });
}else if (Math.random() < 0.002) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'diamante1' });
}else if (Math.random() < 0.005) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'abyssentrance' });
  allabyssportals.push([blockPosX, blockPosY])
}else if (Math.random() < 0.005) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'hell_entrance' });
  allHellCaveEntrances.push([blockPosX, blockPosY])
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cinnabar' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'ilmenite' });
}else if (Math.random() < 0.02) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'opal' });
}else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'emerald' });
}else if (Math.random() < 0.09) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'pyritestone' });
}else if (Math.random() < 0.05) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'stonewithgypsum' });
}else if (Math.random() < 0.02) {
  
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cavewallwithsalt' });
}else {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'cave_wall' });
  
}
}
          if (isCaveEntrance) {
            //kładzie cave escape na pozycji cave entrance 
  blocks.push({ x: 0, y: 0, type: 'cave_escape' });
  
}
        }}else if(isunderwater!==1 && generateCave!==1 && inabyss!==1 && inhell==1 ){
          

/* 
hell CAVE GENERATOR
 
*/
let entranceX2;
let entranceY2;
const isCaveEntrance = allHellCaveEntrances.some(([entranceX, entranceY]) => {
  entranceX2=entranceX ; entranceY2=entranceY
  return entranceX === blockPosX && entranceY === blockPosY;
});
const isNearCaveEntrance = allHellCaveEntrances.some(([entranceX, entranceY]) => {
  return Math.abs(entranceX - blockPosX) <= blockSize * 3 && Math.abs(entranceY - blockPosY) <= blockSize * 3;
});
const shouldPlaceHole = Math.random() < 0.05; // Ustal prawdopodobieństwo tworzenia dziury
if (generateFlesh(blockPosX, blockPosY)) {
  if (generateCaves3(blockPosX, blockPosY)) {
  if (Math.random() < 0.2) {
    blocks.push({ x: 0, y: 0, type: 'fleshblock1' });
  } else {
    blocks.push({ x: 0, y: 0, type: 'fleshblock1' });
  }
}else{
    blocks.push({ x: 0, y: 0, type: 'fleshblock2' });
}
}else if (generateBasalt(blockPosX, blockPosY)){
blocks.push({ x: 0, y: 0, type: 'moltenstone' });
blocks.push({ x: i * blockSize, y: j * blockSize, type: 'basalt' });
}else if (generateCaves3(blockPosX, blockPosY)) {
  if(Math.random()<0.2){
  blocks.push({ x: 0, y: 0, type: 'moltenstone' });
  
  }else{
  blocks.push({ x: 0, y: 0, type: 'hellcavestone' });
if (Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'helltree0' });
    blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'helltree1' });
    blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'helltree2' });
} else if (Math.random() < 0.002) {
    blocks.push({ x: 0, y: 0, type: 'hellwood' });
}else if (Math.random() < 0.020) {
    blocks.push({ x: 0, y: 0, type: 'hellgrass' });
}
  }
} else {
  if (isNearCaveEntrance) {
    if (Math.random() < 0.5) {
  blocks.push({ x: 0, y: 0, type: 'moltenstone' });
} else {
  blocks.push({ x: 0, y: 0, type: 'hellcavestone' });
}
  } else {
    blocks.push({ x: 0, y: 0, type: 'moltenstone' });
    if (Math.random() < 0.010) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'basalt' });
}else{
    blocks.push({ x: 0, y: 0, type: 'hellwall' });} 
    if (Math.random() < 0.012) {
  blocks.push({ x: 0, y: 0, type: 'hellgem' });
} 
  if (Math.random() < 0.02) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'ilmenite' });
  } else if (Math.random() < 0.08) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'ruby' });
}else if (Math.random() < 0.08) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'emerald' });
}else if (Math.random() < 0.08) {
  blocks.push({ x: i * blockSize, y: j * blockSize, type: 'sapphire' });
}else if (Math.random() < 0.005) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'opal' });
    
  }
  }


}
if (isCaveEntrance) {
  blocks.push({ x: 0, y: 0, type: 'hell_escape' });
}

        }else if(isunderwater==1 && inhell!==1  ){
          

          
let entranceX2;
let entranceY2;
const isCaveEntrance = allunderwater.some(([entranceX, entranceY]) => {
  entranceX2=entranceX ; entranceY2=entranceY
  return entranceX === blockPosX && entranceY === blockPosY;
});
const isNearCaveEntrance = allunderwater.some(([entranceX, entranceY]) => {
  return Math.abs(entranceX - blockPosX) <= blockSize * 3 && Math.abs(entranceY - blockPosY) <= blockSize * 3;
});
const shouldPlaceHole = Math.random() < 0.10; 

if(isNearCaveEntrance){
  blocks.push({ x: 0, y: 0, type: 'underwatersand' });
  
}else{
  if(shouldPlaceHole){
    blocks.push({ x: 0, y: 0, type: 'underwatersand' });
    blocks.push({ x: 0, y: 0, type: 'underwatersandblock' })
    if (Math.random() < 0.0002) {
  blocks.push({ x: 0, y: 0, type: 'aquaore' });
};


if (Math.random() < 0.05) {
  blocks.push({ x: 0, y: 0, type: 'echorocks' });
}
if (Math.random() < 0.05) {
  blocks.push({ x: 0, y: 0, type: 'aquaore' });
}
  }else{
    blocks.push({ x: 0, y: 0, type: 'underwatersand' });
    if (Math.random() < 0.04) {
 blocks.push({ x: 0, y: 0 , type: 'algae1' });
 blocks.push({ x: 0, y: -( 1 * blockSize), type: 'algae0' });
 blocks.push({ x: 0, y: -( 2 * blockSize), type: 'algae2' });
}
    if(Math.random()<0.05){
blocks.push({ x: 0, y: 0, type: 'coral1' });
    }else if (Math.random() < 0.05) {
  blocks.push({ x: 0, y: 0, type: 'coral2' });
}
if (Math.random() < 0.005) {
  blocks.push({ x: 0, y: 0, type: 'geyser' });
}
if (Math.random() < 0.00010) {
  blocks.push({ x: 0, y: 0, type: 'aquagodshell' });
};
if (Math.random() < 0.022) {
  blocks.push({ x: 0, y: 0, type: 'seaweed' });
};
  }
}
if (isCaveEntrance) {
  blocks.push({ x: 0, y: 0, type: 'underwaterescape' });
}
}else if(inabyss==1 && inhell!==1){
let entranceX2;
let entranceY2;
const isCaveEntrance = allabyssportals.some(([entranceX, entranceY]) => {
  entranceX2=entranceX ; entranceY2=entranceY
  return entranceX === blockPosX && entranceY === blockPosY;
});
const isNearCaveEntrance = allabyssportals.some(([entranceX, entranceY]) => {
  return Math.abs(entranceX - blockPosX) <= blockSize * 3 && Math.abs(entranceY - blockPosY) <= blockSize * 3;
});
if (generateCaves2(blockPosX, blockPosY)) {
  blocks.push({ x: 0, y: 0, type: 'abyssfloor' });
  

  if (Math.random() < 0.03) {
    blocks.push({ x: 0, y: 0, type: 'crystal1' });
  } else if (Math.random() < 0.03) {
    blocks.push({ x: 0, y: 0, type: 'crystal2' });
  } else if (Math.random() < 0.03) {
    blocks.push({ x: 0, y: 0, type: 'crystal3' });
  } else if (Math.random() < 0.2) {
    blocks.push({ x: 0, y: 0, type: 'glowblossom' });
  } else if (Math.random() < 0.01) {
    blocks.push({ x: 0, y: 0, type: 'echorocks' });
  }else if (Math.random() < 0.05) {
    blocks.push({ x: i * blockSize, y: j * blockSize, type: 'abysstree0' });
    blocks.push({ x: i * blockSize, y: (j - 1) * blockSize, type: 'abysstree1' });
    blocks.push({ x: i * blockSize, y: (j - 2) * blockSize, type: 'abysstree2' });
} else if (Math.random() < 0.002) {
    blocks.push({ x: 0, y: 0, type: 'abysswood' });
}else if (Math.random() < 0.020) {
    blocks.push({ x: 0, y: 0, type: 'abyssgrass' });
}


}else{
if (isNearCaveEntrance) {
  blocks.push({ x: 0, y: 0, type: 'abyssfloor' });
    if (Math.random() < 0.002) {
    blocks.push({ x: 0, y: 0, type: 'crystal1' });
  } else if (Math.random() < 0.002) {
    blocks.push({ x: 0, y: 0, type: 'crystal2' });
  } else if (Math.random() < 0.002) {
    blocks.push({ x: 0, y: 0, type: 'crystal3' });
  } else if (Math.random() < 0.005) {
    blocks.push({ x: 0, y: 0, type: 'glowblossom' });
  } else if (Math.random() < 0.0005) {
    blocks.push({ x: 0, y: 0, type: 'echorocks' });
  }
} else {
    blocks.push({ x: 0, y: 0, type: 'abyssfloor' });
    if (Math.random() < 0.008) {
  blocks.push({ x: 0, y: 0, type: 'crystal1' });
} else if (Math.random() < 0.008) {
  blocks.push({ x: 0, y: 0, type: 'crystal2' });
} else if (Math.random() < 0.008) {
  blocks.push({ x: 0, y: 0, type: 'crystal3' });
}else if (Math.random() < 0.011) {
  blocks.push({ x: 0, y: 0, type: 'glowblossom' });
}else if (Math.random() < 0.006) {
  blocks.push({ x: 0, y: 0, type: 'echorocks' });
}
    blocks.push({ x: 0, y: 0, type: 'abyssblock' })
}


}
}
  
}}else {
          

          
  blocks.push({ x: 0, y: 0, type: 'housegrass' });
  blocks.push({ x: 0, y: 0, type: 'voidblock' });
   
}
      
    } 
    }
    
    chunks[chunkKey] = blocks;
}

// Funkcja do dodawania sąsiednich bloków wody
function addSurroundingWater(blocks, x, y) {
    const directions = [
        { dx: blockSize, dy: 0 },   // Prawo
        { dx: -blockSize, dy: 0 },  // Lewo
        { dx: 0, dy: blockSize },   // Dół
        { dx: 0, dy: -blockSize },  // Góra
    ];

    // Licznik bloków wody
    let waterCount = 0;

    // Losowo wybieraj kierunki
    for (const direction of directions) {
        if (waterCount >= 12) break; // Nie dodawaj więcej niż 8 bloków wody

        // Oblicz nową pozycję
        const newX = x + direction.dx;
        const newY = y + direction.dy;

        // Sprawdź, czy w tym miejscu można dodać wodę
        if (canPlaceWater(blocks, newX, newY)) {
            blocks.push({ x: newX, y: newY, type: 'water' });
            waterCount++;
        }
    }
}

// Funkcja do sprawdzania, czy można umieścić wodę w danej pozycji
function canPlaceWater(blocks, x, y) {
    // Sprawdź istniejące bloki w danej pozycji
    for (const block of blocks) {
        if (block.x === x && block.y === y) {
            // Jeśli jest inny blok, który nie jest 'grass', nie umieszczaj wody
            return block.type === 'grass';
        }
    }
    return true; // Można umieścić wodę
}

function drawTreesBelowPlayer(trees) {
    trees.forEach(tree => {
        if (textures[tree.type].complete && textures[tree.type].naturalWidth > 0) { // Sprawdzenie, czy tekstura istnieje
            ctx.drawImage(textures[tree.type], tree.x, tree.y, blockSize, blockSize);
        } else {
             
        }
    });
}

function drawTreesAbovePlayer(trees) {
    trees.forEach(tree => {
//if (textures[tree.type].complete && textures[tree.type].naturalWidth > 0) { // Sprawdzenie, czy tekstura istnieje
let x =tree.x
let y =tree.y
if (animatedTextures[tree.type] ) {
        const anim = animatedTextures[tree.type];
    const currentTime = performance.now() / 1000; 
    if (currentTime - anim.lastFrameTime > anim.speed) {
      anim.currentFrame = (anim.currentFrame + 1) % anim.frames.length; anim.lastFrameTime = currentTime;}
    if (anim.frames[anim.currentFrame] && anim.frames[anim.currentFrame].complete && anim.frames[anim.currentFrame].naturalWidth > 0) {
      ctx.drawImage(anim.frames[anim.currentFrame], x, y, blockSize, blockSize); }  } else  {
    if (textures[tree.type] && textures[tree.type].complete && textures[tree.type].naturalWidth > 0) { ctx.drawImage(textures[tree.type], x, y, blockSize, blockSize); } }
         //   ctx.drawImage(textures[tree.type], tree.x, tree.y, blockSize, blockSize);
        /*} else {
             
        }*/
    });
    for(let i=0 ; i<textarr.length; i++){
 ctx.font = ' 10px Arial';
ctx.fillStyle = 'white';
ctx.textAlign = 'center';
let x =textarr[i].dx ; let y=textarr[i].dy;
ctx.fillText(textarr[i].text, x + blockSize / 2, y - 5);
        }
}



let renderedBlocks = []; // Przechowywanie bloków widocznych na ekranie
let nightpower = 0;  // Początkowa wartość (dzień)
const maxNightpower = 3;  // Maksymalna wartość (pełna noc)
let dayNightCycleSpeed = 0.0001;  // Prędkość cyklu dnia i nocy (można dostosować)
let dayNightCycleSpeed2 = 0.0002;  // Prędkość cyklu dnia i nocy (można dostosować)
let increasing = true;  // Kontroluje, czy nightpower wzrasta (noc) czy maleje (dzień)
var surviveddays=0
function updateDayNightCycle() {
    if (increasing) {
        nightpower += dayNightCycleSpeed;
        if (nightpower >= maxNightpower) {
            nightpower = maxNightpower;
            increasing = false;  // Zacznij zmniejszać (dzień)
        }
    } else {
        nightpower -= dayNightCycleSpeed2;
        achievementget("Its Night Now !",0)
        if (nightpower <= 0) {
            nightpower = 0;
            increasing = true;  // Zacznij zwiększać (noc)
            surviveddays++
            if( surviveddays>10){
                achievementget("Survive 10 days !",1)
            }
if (surviveddays > 50) {
    achievementget("Old man live survive 50 days !", 1)
}
if (surviveddays > 100) {
    achievementget("<span style='color: purple;'>100 days !</span>", 1)
}
if (surviveddays > 500) {
    achievementget("Man you're playing really long <span style='color: yellow;'>500 days !</span>", 1)
}
        }
    }
}
function isNearTorch2(blocks, x, y) {
  
  const rad = 1.5 * blockSize; // Promień dla pochodni trzymanej przez gracza

  // Filtrowanie bloków znajdujących się w promieniu `radiusTorch` od punktu `(x, y)`
  const nearbyBlocks = blocks.filter(block => {
    const distX = Math.abs(block.x - x);
    const distY = Math.abs(block.y - y);
    return distX <= rad && distY <= rad;
  });

  // Sprawdzanie bloki pochodni i innych typów
  for (const block of nearbyBlocks) {
    const distX = Math.abs(block.x - x);
    const distY = Math.abs(block.y - y);

    if ((block.type === 'torch' && distX <= 2 * blockSize && distY <=  blockSize) ||
  (  block.type === 'lamp' && distX <= 3 * blockSize && distY <=  blockSize) ||
      (block.type === 'cave_escape' && distX <= blockSize && distY <=blockSize) ||
      (block.type === 'glowblossom' && distX <= blockSize && distY <=blockSize) ||
      (block.type === 'lit_furnace' && distX <= 4 * blockSize && distY <= blockSize) ||
      (block.type === 'campfire' && distX <= blockSize && distY <=  blockSize) ||
      (block.type === 'ignited_fiber' && distX === 0 && distY === 0)) {
      return true; // Jest źródło światła w pobliżu
    }
  }

  // Sprawdzanie pochodni trzymanej przez gracza, jeśli istnieje
  if (yourItems !== undefined) {
    if (checkIfItems("hand_torch", 1)) {
      const radius5 = 1.5 * blockSize;
      const playerCenterX = offsetX + canvas.width / 2 * 32 * blockSize;
      const playerCenterY = offsetY + canvas.height / 2 * 32 * blockSize;
      const distX2 = Math.abs(playerCenterX / 32 / 32 - x);
      const distY2 = Math.abs(playerCenterY / 32 / 32 - y);
      if (distX2 <= rad && distY2 <= rad) {
        return true; // Pochodnia jest w pobliżu
      }
    }
    if (checkIfItems("magiclanter", 1)) {
  const radius5 = 3 * blockSize;
  const playerCenterX = offsetX + canvas.width / 2 * 32 * blockSize;
  const playerCenterY = offsetY + canvas.height / 2 * 32 * blockSize;
  const distX2 = Math.abs(playerCenterX / 32 / 32 - x);
  const distY2 = Math.abs(playerCenterY / 32 / 32 - y);
  if (distX2 <= radius5 && distY2 <= radius5) {
    return true; // Pochodnia jest w pobliżu
  }
}
      
    
  }

  return false; // Brak źródła światła w pobliżu
}
var blocksGlow = {
    "torch": { "x": 1, "y": 1, "d": 1 }, 
    "candle": { "x": 1, "y": 1, "d": 0 },
    "lamp2": { "x": 2, "y": 2, "d": 1 },
    "cave_escape": { "x": 0, "y": 0, "d": 1 },
    "glowblossom": { "x": 0, "y": 0, "d": 1 },
    "lit_furnace": { "x": 3, "y": 3, "d": 1 },
    "lit_kiln": { "x": 3, "y": 2, "d": 1 },
    "campfire": { "x": 0, "y": 0, "d": 1 },
    "extinguished_campfire": { "x": 0, "y": 0, "d": 0 },
    "ignited_fiber": { "x": 0, "y": 0, "d": 1 },
    "statueofgods": { "x": 2, "y": 2, "d": 2 },
    "abysstree2": { "x": 0, "y": 0, "d": 1 },
    "abysstree0": { "x": 0, "y": 0, "d": 1 },
    "abysstree1": { "x": 0, "y": 0, "d": 1 },
    "helltree0": { "x": 0, "y": 0, "d": 0 },
    "helltree1": { "x": 0, "y": 0, "d": 0 },
    "helltree2": { "x": 0, "y": 0, "d": 0 },
};


function isNearTorch(blocks, x, y) {
    const radiusTorch = 4 * blockSize;  // Największy promień dla wszystkich źródeł światła
    const nearbyBlocks = blocks.filter(block => {
        const distX = Math.abs(block.x - x);
        const distY = Math.abs(block.y - y);
        return distX <= radiusTorch && distY <= radiusTorch;
    });
if(generateCave!==0 || nightpower>1.5){
    for (const block of nearbyBlocks) {
        const distX = Math.abs(block.x - x);
        const distY = Math.abs(block.y - y);
          if ((block.type in blocksGlow) && 
            (distX <= (blocksGlow[block.type].x) * blockSize && distY <= (blocksGlow[block.type].y) * blockSize)) {
            return true; 
        }
    }

    if (yourItems !== undefined) {
        if (checkIfItems("hand_torch", 1)) {
const radius5 = 0.5 * blockSize;
const radius6 = 1.5 * blockSize;
const playerCenterX = offsetX + canvas.width / 2 * 32 *32* blockSize;
const playerCenterY = offsetY + canvas.height / 2 * 32 *32 * blockSize;
const distX2 = Math.abs(playerCenterX / 32 / 32 /32- x);
const distY2 = Math.abs(playerCenterY / 32 / 32 /32- y);
if (distX2 <= radius5 && distY2 <= radius5) {
  return true;
}
if ((distX2 <= radius6 && distY2 <= radius6)) {
  return 0.5;
}
}

        if (checkIfItems("magiclanter", 1)) {
const radius5 = 1.5 * blockSize;
const radius6 = 2.5 * blockSize;
const playerCenterX = offsetX + canvas.width / 2 * 32*32 * blockSize;
const playerCenterY = offsetY + canvas.height / 2 * 32*32 * blockSize;
const distX2 = Math.abs(playerCenterX / 32 / 32 /32 - x);
const distY2 = Math.abs(playerCenterY / 32 / 32 /32- y);
if (distX2 <= radius5 && distY2 <= radius5) {
  return true;
}
if ((distX2 <= radius6 && distY2 <= radius6)) {
  return 0.5;
}
        }
    }
    for (const block of nearbyBlocks) {
  const distX = Math.abs(block.x - x);
  const distY = Math.abs(block.y - y);
  if ((block.type in blocksGlow) &&
    (distX <= (blocksGlow[block.type].x + blocksGlow[block.type].d ) * blockSize && distY <= (blocksGlow[block.type].y + blocksGlow[block.type].d ) * blockSize)) {
    return 0.5;
    }
  }
}else{
  for (const block of nearbyBlocks) {
  const distX = Math.abs(block.x - x);
  const distY = Math.abs(block.y - y);
  if ((block.type in blocksGlow) &&
    (distX <= (blocksGlow[block.type].x) * blockSize && distY <= (blocksGlow[block.type].y) * blockSize)) {
    return true;
  }
}

if (yourItems !== undefined) {
  if (checkIfItems("hand_torch", 1)) {
    const radius5 = 0.5 * blockSize;
    const radius6 = 1.5 * blockSize;
    const playerCenterX = offsetX + canvas.width / 2 * 32 * 32 * blockSize;
const playerCenterY = offsetY + canvas.height / 2 * 32 * 32 * blockSize;
const distX2 = Math.abs(playerCenterX / 32 / 32 / 32 - x);
const distY2 = Math.abs(playerCenterY / 32 / 32 / 32 - y);
if (distX2 <= radius5 && distY2 <= radius5) {
    return true;
}
if ((distX2 <= radius6 && distY2 <= radius6)) {
    return 0.5;
}
  }

  if (checkIfItems("magiclanter", 1)) {
    const radius5 = 1.5 * blockSize;
    const radius6 = 2.5 * blockSize;
    const playerCenterX = offsetX + canvas.width / 2 * 32*32 * blockSize;
    const playerCenterY = offsetY + canvas.height / 2 * 32 *32* blockSize;
    const distX2 = Math.abs(playerCenterX / 32 / 32 /32- x);
    const distY2 = Math.abs(playerCenterY / 32 / 32 /32- y);
    if (distX2 <= radius5 && distY2 <= radius5) {
      return true;
    }
    if ((distX2 <= radius6 && distY2 <= radius6)) {
      return 0.5;
    }
  }
}
}
    return false; // Brak źródła światła w pobliżu
}


let chunkPositions = []; // Dodajemy do przechowywania pozycji chunków
var dontcount = ["dirt", "grass", "tallgrass", "yellow", "dandelion", "violet","tree0","pine0","birch0","tree1","pine1","birch1","tree2","pine2","birch2","grasslayer","clayblock","ashfloor","shine","shiny","log_floor","log_wall","log","stone_floor","stone_wall","brickwall","brickfloor","clayblock1","glass","gypsumblock","abyssfloor","abyssescape","snowpine1","snowpine2","snowpine3","stone_floor", "fiber_floor", "grasslayer", "yellow", "violet", "clayblock", "clayblock1", "dandelion", "toadstool", "sandblock2", "gypsumblock", "glass", "fern", "planks_floor", "log_floor", "ashblock", "ashfloor", "brickfloor", "daffodil","flax","myosotis", "fiber_floor", "bed1", "magnetite", "nettle", "stone_floor", "emeraldfloor", "sapphirefloor", "rubyfloor", "clayblock1", "clayblock","violetfloor","grass","toadstool","stones","thistle","ryeroof","houseroof","housewall","brickhouse","gelblock","gypsum_dirt","roadfloor","gypsumblock","gypsumfloor","torch","brickfloor2","door","door2","housegrass","lamp","lamp2","hellwall2","forestgrass","forestleaf","blush","hill1","climbhill","statue1_1","statue1_2","kiln","algae1","algae2","algae0","statue2_2","statue2_1","helltree0","helltree1","helltree2","abysstree2","abysstree1","abysstree0","helllog","abysslog","abyssgrass","hellgrass" ,"gypsumhouse","gypsumroof","gypsumdoor","carpet","polishedfloor","sing","palm1","palm2","coconutpalm","palm12","palm32","stonesing","cauldron","textstone","fountain"];
let waveTick = 0;
var fenceconnections={
  "none": "./fence.png",
  "ud": "./fence_u_d.png",
  "u": "./fence_u.png",
  "ul": "./fence_u_r.png" ,
  "ur": "./fence_u_l.png",
  "lr": "./fence_l_r.png",
  "rd": "./fence_l_d.png",
  "ld": "./fence_r_d.png",
  "d": "./fence_u_d.png",
  "r": "./fence_r.png",
  "l": "./fence_l.png"
}
var fencetextures ={};
for (const [name, src] of Object.entries(fenceconnections)) {
  fencetextures[name] = new Image();
  fencetextures[name].src = src;
}
/*water: {
  frames: ['./water.png', './water2.png'], // Klatki animacji
  speed: 0.5 // Czas trwania jednej klatki (w sekundach)
},*/
var waterconnections = {
  "u1": "./water_up1.png",
  "u2": "./water_up2.png",
  "d1": "./water_down1.png",
  "d2": "./water_down2.png",
  "l1": "./water_left1.png",
  "l2": "./water_left2.png",
  "r1": "./water_right1.png",
  "r2": "./water_right2.png",
 
  "1": "./water.png",
  "2": "./water2.png"
}
var watertextures = {};
for (const [name, src] of Object.entries(waterconnections)) {
  watertextures[name] = new Image();
  watertextures[name].src = src;
}
var waterconnections2 = {
 "u1": "./water_up12.png",
 "u2": "./water_up22.png",
 "d1": "./water_down12.png",
 "d2": "./water_down22.png",
 "l1": "./water_left12.png",
 "l2": "./water_left22.png",
 "r1": "./water_right12.png",
 "r2": "./water_right22.png",

 "1": "./water.png",
 "2": "./water2.png"
}
var watertextures2 = {};
for (const [name, src] of Object.entries(waterconnections2)) {
 watertextures2[name] = new Image();
 watertextures2[name].src = src;
}
var roadconnections = {
  "none": "./road0.png",
  "ud": "./roadud.png",
  "u": "./roadd.png",
  "ul": "./roadlu.png",
  "ur": "./roadur.png",
  "lr": "./roadlr.png",
  "rd": "./roaddr.png",
  "ld": "./roadld.png",
  "d": "./roadu.png",
  "l": "./roadr.png",
  "r": "./roadl.png",
  "ldr": "./roadldr.png",
  "lur": "./roadlur.png",
  "full": "./road1.png", 
}
var grass2connections = {
  "none": "./grass2none.png",
  "udl": "./grass2ud-l.png",
  "udr": "./grass2ud-r.png",
  "ul": "./grass2lu.png",
  "ur": "./grass2ru.png",
  "rlu": "./grass2rl-u.png",
  "rld": "./grass2rl-d.png",
  "rd": "./grass2rd.png",
  "ld": "./grass2ld.png",
  "lu": "./grass2lu.png",
  "ru": "./grass2ru.png",
  "full": "./grass2full.png",
}
var roadtextures = {};
for (const [name, src] of Object.entries(roadconnections)) { 
  roadtextures[name] = new Image();
  roadtextures[name].src = src;
}
var grasstextures = {};
for (const [name, src] of Object.entries(grass2connections)) {
  grasstextures[name] = new Image();
  grasstextures[name].src = src;
}

var hill1connections = {
 "none": "./hill_none.png",
 "u": "./hill_u.png",
 "ul": "./hill_ul.png",
 "ur": "./hill_ur.png",
 "dl": "./hill_dl.png",
 "dr": "./hill_dr.png",
 "Cul":"./hillC_ul.png",
 "Cur":"./hillC_ur.png",
 "Cdr":"./hillC_dr.png",
 "Cdl":"./hillC_dl.png",
 "Culdr":"./hillC_ul_dr.png",
 "Curdl":"./hillC_ur_dl.png",
 "r": "./hill_r.png",
 "l": "./hill_l.png",
 "d": "./hill_d.png",
 "full": "./hill_grass.png",
}
var hill1textures = {};
for (const [name, src] of Object.entries(hill1connections)) {
 hill1textures[name] = new Image();
 hill1textures[name].src = src;
}
var climbhill1 = {
 "none": "./climbhill.png",
 "u": "./climbhill.png",
 "d": "./climbhill2.png",
}
var climbhill1textures = {};
for (const [name, src] of Object.entries(climbhill1)) {
 climbhill1textures[name] = new Image();
 climbhill1textures[name].src = src;
}

// to map Image() 
var watertickcount=0
function getFenceConnection(chunkX, chunkY, typeZ) {
  if(typeZ==-1){
    let connection = "none";
    const hasAbove = checkBlockAtPosition2(chunkX, chunkY - 32, "hill1");
    const hasBelow = checkBlockAtPosition2(chunkX, chunkY + 32, "hill1");
if (hasAbove) {
  connection = "u"
}
if (hasBelow) {
  connection = "d"; // Oba, górne i dolne
}
     return connection;
  } else   if(typeZ==1){
    let connection = "none";
    const hasLeft = checkBlockAtPosition2(chunkX - 32, chunkY, "fence");
    const hasRight = checkBlockAtPosition2(chunkX + 32, chunkY, "fence");
    const hasAbove = checkBlockAtPosition2(chunkX, chunkY - 32, "fence");
    const hasBelow = checkBlockAtPosition2(chunkX, chunkY + 32, "fence");
if (hasBelow) {
  connection = "ud"; // Oba, górne i dolne
}
    if (hasLeft && hasRight) {
        connection = "lr";
    } else if (hasLeft) {
        if (!checkBlockAtPosition2(chunkX , chunkY+32, "fence")) {
            connection = "l"; 
        } else {
            connection = "ld"; 
        }
    } else if (hasRight) {
        if (!checkBlockAtPosition2(chunkX , chunkY+32, "fence")) {
            connection = "r"; // tylko prawo
        } else {
            connection = "rd"; // prawo z dołem
        }
    }if (hasAbove && hasBelow) {
        connection = connection === "none" ? "ud" : connection; // Oba, górne i dolne
    } else if (hasAbove) {
        connection = connection === "none" ? "u" : connection; // Tylko góra
    } else if (hasBelow) {
        connection = connection === "none" ? "d" : connection; // Tylko dół
    }if (hasAbove) {
        if (hasLeft && !checkBlockAtPosition2(chunkX - 32, chunkY - 32, "fence")) {
            connection =  "ul" ; // Jeśli jest tylko połączenie w górę-lewo
        }
        if (hasRight && !checkBlockAtPosition2(chunkX + 32, chunkY - 32, "fence")) {
            connection = "ur"; 
        }
    }if (hasAbove && hasBelow) { connection = "ud" ; } return connection;
  } else if (typeZ == 2) {
    let connection = "none";
    const hasLeft = checkBlockAtPosition2(chunkX - 32, chunkY, "grass2");
    const hasRight = checkBlockAtPosition2(chunkX + 32, chunkY, "grass2");
    const hasAbove = checkBlockAtPosition2(chunkX, chunkY - 32, "grass2");
    const hasBelow = checkBlockAtPosition2(chunkX, chunkY + 32, "grass2");
 /*  
...............................................
.                                 +y          .
.             ^  vec+                         .
.             |                               .
.   vec-  < – * – > vec+      -x   *   +x     .
.             |                               .
.             v  vec-                         .
.                                  -y         .
.                                             .
...............................................
 */
 if ((hasLeft || hasRight || hasAbove || hasBelow)) {
  connection = "full"; // Pełne połączenie
} if (hasLeft && hasRight && hasAbove && hasBelow) {
      connection = "full"; // Pełne połączenie
    } else if ((hasAbove && hasBelow) && hasLeft) {
      connection = "udl"; // Połączenie góra-dół-lewo
    } else if ((hasAbove && hasBelow) && hasRight) {
      connection = "udr"; // Połączenie góra-dół-prawo
    } else if ((hasLeft && hasRight) && hasAbove) {
      connection = "rlu"; // Połączenie lewo-prawo-góra
    } else if ((hasLeft && hasRight) && hasBelow) {
      connection = "rld"; // Połączenie lewo-prawo-dół
    } else if (hasAbove && hasLeft) {
      connection = "ul"; // Tylko góra
    } else if (hasAbove && hasRight) {
      connection = "ur"; 
    } else if (hasRight && hasBelow) {
      connection = "rd"; // Tylko lewo
    } else if (hasLeft && hasBelow) {
      connection = "ld"; // Tylko prawo
    }

    return connection;
  }else if (typeZ == 5) {
let connection = "none";
const hasLeft = checkBlockAtPosition2(chunkX - 32, chunkY, "hill1")||checkBlockAtPosition2(chunkX - 32, chunkY, "climbhill");
const hasRight = checkBlockAtPosition2(chunkX + 32, chunkY, "hill1")||checkBlockAtPosition2(chunkX + 32, chunkY, "climbhill");
const hasAbove = checkBlockAtPosition2(chunkX, chunkY - 32, "hill1")||checkBlockAtPosition2(chunkX, chunkY - 32, "climbhill");
const hasBelow = checkBlockAtPosition2(chunkX, chunkY + 32, "hill1")||checkBlockAtPosition2(chunkX, chunkY + 32, "climbhill");

 const hasCUR = checkBlockAtPosition2(chunkX + 32 , chunkY + 32, "hill1")|| checkBlockAtPosition2(chunkX + 32 , chunkY + 32, "climbhill")  ;
 const hasCDR = checkBlockAtPosition2(chunkX + 32 , chunkY - 32, "hill1")|| checkBlockAtPosition2(chunkX + 32 , chunkY - 32, "climbhill");
 const hasCUL = checkBlockAtPosition2(chunkX - 32 , chunkY + 32, "hill1")|| checkBlockAtPosition2(chunkX - 32 , chunkY + 32, "climbhill");
 const hasCDL = checkBlockAtPosition2(chunkX - 32 , chunkY - 32, "hill1")|| checkBlockAtPosition2(chunkX - 32 , chunkY - 32, "climbhill");
 
 if (!(hasLeft && hasRight && hasAbove && hasBelow)) {
 connection = "none"; // Pełne połączenie
}
 if ((hasLeft || hasRight || hasAbove || hasBelow)) {
 connection = "none"; // Pełne połączenie
 } 
 if (hasBelow && !hasAbove && ( hasLeft || hasRight )) {
 connection = "u";
}
if ((hasAbove && !hasBelow && ( hasLeft || hasRight ))) {
 connection = "d";
}

if ( hasLeft && (hasAbove && hasBelow) ) {
 connection = "r"; 
}if ( hasRight && (hasAbove && hasBelow)) {
 connection = "l"; 
}
if (hasBelow && hasLeft && !hasAbove) {
 connection = "ur"; 
 } if (hasBelow && hasRight && !hasAbove) {
 connection = "ul"; 
}
 if (hasBelow && !hasAbove && hasLeft && hasRight) {
  connection = "u";
 }
if ((hasAbove && !hasBelow && hasLeft)) {
 connection = "dr";
}
if ((hasAbove && !hasBelow && hasRight)) {
 connection = "dl";
}
if ((hasAbove && !hasBelow && hasLeft && hasRight )) {
 connection = "d";
}
if (hasLeft && hasRight && hasAbove && hasBelow) {
 connection = "full"; // Pełne połączenie
 
 if ((hasAbove && hasBelow && hasLeft && !hasCDR)) {
 connection = "Cur";
}
if ((hasAbove && hasBelow && hasRight && !hasCDL)) {
 connection = "Cul";
}
if ((hasAbove && hasBelow && hasRight && !hasCUL)) {
 connection = "Cdl";
}
if ((hasAbove && hasBelow && hasLeft && !hasCUR)) {
 connection = "Cdr";
}
 if ((hasAbove && hasBelow && hasLeft && !hasCDR && !hasCUL)) {
  connection = "Curdl";
 }
  if ((hasAbove && hasBelow && hasLeft && !hasCDL && !hasCUR)) {
  connection = "Culdr";
 }
}

 return connection;
 }else if (typeZ == 3) {
    let connection = "none";
    
    const offsets = [
        { x: 0, y: -32, conn: "u1" , conn2:"u2" }, // powyżej
        { x: 0, y: 32, conn: "d1" , conn2:"d2" },  // poniżej
        { x: 32, y: 0, conn: "r1" , conn2:"r2" },  // po prawej
        { x: -32, y: 0, conn: "l1" , conn2:"l2" }   // po lewej
    ];
    const blockTypes = ["sand", "grass", "forestgrass", "grasslayer"];

    for (const offset of offsets) {
        const { x, y, conn , conn2 } = offset;
        const hasBlock = blockTypes.some(type => checkBlockAtPosition2(chunkX + x, chunkY + y, type)&&! checkBlockAtPosition2(chunkX + x, chunkY + y, "water1"));
        
        if (hasBlock) {
            connection = conn;
            if (watertickcount > 20) {
              connection = conn2;
            }
            break; // Przerywamy pętlę, gdy znajdziemy pierwszy blok
        }
    }

    return connection;
}
else{
    let connection = "none";
    const hasLeft = checkBlockAtPosition2(chunkX - 32, chunkY, "road");
    const hasRight = checkBlockAtPosition2(chunkX + 32, chunkY, "road");
    const hasAbove = checkBlockAtPosition2(chunkX, chunkY - 32, "road");
    const hasBelow = checkBlockAtPosition2(chunkX, chunkY + 32, "road");
if (hasBelow) {
  connection = "ud"; // Oba, górne i dolne
}
if (hasAbove && hasBelow) {
  connection = connection === "none" ? "ud" : connection; // Oba, górne i dolne
} else if (hasBelow) {
  connection = "d"; // Tylko dół
} else if (hasAbove) {
  connection = "u"; // Tylko góra
}
    if (hasLeft && hasRight) {
        connection = "lr";
    } else if (hasLeft) {
        if (!checkBlockAtPosition2(chunkX , chunkY+32, "road")) {
            connection = "l"; 
        } else {
            connection = "ld"; 
        }
    } else if (hasRight) {
        if (!checkBlockAtPosition2(chunkX , chunkY+32, "road")) {
            connection = "r"; // tylko prawo
        } else {
            connection = "rd"; // prawo z dołem
        }
    } if (hasAbove) {
        if (hasLeft && !checkBlockAtPosition2(chunkX - 32, chunkY - 32, "road")) {
            connection =  "ul" ; // Jeśli jest tylko połączenie w górę-lewo
        }
        if (hasRight && !checkBlockAtPosition2(chunkX + 32, chunkY - 32, "road")) {
            connection = "ur"; 
        }
    }if (hasAbove && hasBelow) { connection = "ud" ; }
    // Sprawdzamy nowe połączenia
if (hasLeft && hasAbove && hasRight) {
  connection = "lur"; // Połączenie lewo-góra-prawo
}
if (hasLeft && hasBelow && hasRight) {
  connection = "ldr"; // Połączenie lewo-dół-prawo
}
if (hasLeft && hasAbove && hasBelow && hasRight) {
  connection = "full"; // Pełne połączenie
}return connection;
  }
}

let textarr=[]

function drawChunks() {
 textarr=[]
    let startX = Math.floor(offsetX / blockSize)  ;
    let startY = Math.floor(offsetY / blockSize)  ;
    if( zoomedDELTA >0 ){
     startX = Math.floor(offsetX / blockSize)-1  ;
     startY = Math.floor(offsetY / blockSize)-1  ;
    }
    const endX = startX + Math.ceil(canvas.width / blockSize / 1) + 1;
    const endY = startY + Math.ceil(canvas.height / blockSize / 1) + 3;
 
    let treesBelowPlayer = [];
    let treesAbovePlayer = [];
    renderedBlocks = []; // Resetowanie renderedBlocks na początku rysowania
    chunkPositions = []; // Resetowanie chunkPositions

    for (let chunkX = startX; chunkX < endX; chunkX++) {
        for (let chunkY = startY; chunkY < endY; chunkY++) {
            generateChunk(chunkX, chunkY);
            const chunkKey = `${chunkX},${chunkY}`;
            const blocks = chunks[chunkKey];

            // Zbieranie pozycji chunków
            const chunkPosition = {
                x: chunkX * blockSize - offsetX +zoomedDELTA/2,
                y: chunkY * blockSize - offsetY+zoomedDELTA/2,
                width: blockSize,
                height: blockSize
            };
            chunkPositions.push(chunkPosition);

            // Rysowanie bloków
            blocks.forEach((block, index) => {
                const x = block.x + chunkX * blockSize - offsetX +zoomedDELTA/2;
                const y = block.y + chunkY * blockSize - offsetY +zoomedDELTA/2;
renderedBlocks.push({ type: block.type, x: x, y: y }); // Zbieranie bloków


if(block.type !== 'fence'&&block.type !== 'road' && block.type !== 'grass2' && block.type !== 'coast'&& block.type !== 'water' && block.type !== "hill1"&& block.type !== "climbhill"){
                if (animatedTextures[block.type]) {
                    // Animowana tekstura
                    const anim = animatedTextures[block.type];
                    const currentTime = performance.now() / 1000; // Aktualny czas w sekundach
                    if (currentTime - anim.lastFrameTime > anim.speed) {
                        anim.currentFrame = (anim.currentFrame + 1) % anim.frames.length;
                        anim.lastFrameTime = currentTime;
                    }
                    if (anim.frames[anim.currentFrame] && anim.frames[anim.currentFrame].complete && anim.frames[anim.currentFrame].naturalWidth > 0) {
                        // Rysowanie animowanej tekstury
                        ctx.drawImage(anim.frames[anim.currentFrame], x, y, blockSize, blockSize);
                    }
                } else {
                    if (textures[block.type] && textures[block.type].complete && textures[block.type].naturalWidth > 0) {
                        ctx.drawImage(textures[block.type], x, y, blockSize, blockSize);
                    }
                }
}else if ( block.type == 'coast' ) {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 3);
const texture = watertextures[connection];
if (texture && texture.complete && texture.naturalWidth > 0) {
  ctx.drawImage(texture, x, y, blockSize, blockSize);
  return;
}
  if (animatedTextures[block.type] && connection=="none") {
    const anim = animatedTextures[block.type];
    const currentTime = performance.now() / 1000; 
    if (currentTime - anim.lastFrameTime > anim.speed) {
      anim.currentFrame = (anim.currentFrame + 1) % anim.frames.length; anim.lastFrameTime = currentTime;}
    if (anim.frames[anim.currentFrame] && anim.frames[anim.currentFrame].complete && anim.frames[anim.currentFrame].naturalWidth > 0) {
      ctx.drawImage(anim.frames[anim.currentFrame], x, y, blockSize, blockSize); }  } else  {
    if (textures[block.type] && textures[block.type].complete && textures[block.type].naturalWidth > 0) { ctx.drawImage(textures[block.type], x, y, blockSize, blockSize); } }
}else if ( block.type == 'water' ) {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 3);
const texture = watertextures2[connection];
if (texture && texture.complete && texture.naturalWidth > 0) {
  ctx.drawImage(texture, x, y, blockSize, blockSize);
  return;
}
  if (animatedTextures[block.type] && connection=="none") {
    const anim = animatedTextures[block.type];
    const currentTime = performance.now() / 1000; 
    if (currentTime - anim.lastFrameTime > anim.speed) {
      anim.currentFrame = (anim.currentFrame + 1) % anim.frames.length; anim.lastFrameTime = currentTime;}
    if (anim.frames[anim.currentFrame] && anim.frames[anim.currentFrame].complete && anim.frames[anim.currentFrame].naturalWidth > 0) {
      ctx.drawImage(anim.frames[anim.currentFrame], x, y, blockSize, blockSize); }  } else  {
    if (textures[block.type] && textures[block.type].complete && textures[block.type].naturalWidth > 0) { ctx.drawImage(textures[block.type], x, y, blockSize, blockSize); } }
} else if (block.type === 'fence') {
 if (block.type === 'fence') {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
  const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
  const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 1);
  const texture = fencetextures[connection];

  if (texture && texture.complete && texture.naturalWidth > 0) {
   ctx.drawImage(texture, x, y, blockSize, blockSize);

   return;
  }
 }
}else if (block.type === 'climbhill') {
 if (block.type === 'climbhill') {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
  const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
  const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), -1);
  const texture = climbhill1textures[connection];

  if (texture && texture.complete && texture.naturalWidth > 0) {
   ctx.drawImage(texture, x, y, blockSize, blockSize);

   return;
  }
 }
}else if (block.type === 'grass2') {
 if (block.type === 'grass2') {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
  const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
  const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 2);
  const texture = grasstextures[connection];
  if (texture && texture.complete && texture.naturalWidth > 0) {
   ctx.drawImage(texture, x, y, blockSize, blockSize);
   return;
  }
 }
}else if (block.type === 'hill1') {
 if (block.type === 'hill1') {
  const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
  const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
  const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 5);
  const texture = hill1textures[connection];
  if (texture && texture.complete && texture.naturalWidth > 0) {
   ctx.drawImage(texture, x, y, blockSize, blockSize);
   return;
  }
 }
}else if (block.type === 'road') {
  if (block.type === 'road') {
    const x2 = block.x + chunkX * blockSize - Math.floor(offsetX)
    const y2 = block.y + chunkY * blockSize - Math.floor(offsetY)
    const connection = getFenceConnection(Math.floor(x2), Math.floor(y2), 0);
    const texture = roadtextures[connection];
    if (texture && texture.complete && texture.naturalWidth > 0) {
      ctx.drawImage(texture, x, y, blockSize, blockSize);
      return;
    }
  }
}
                // Warunek: jeśli więcej niż 2 bloki w chunku, wyświetl tekst nad ostatnim blokiem,
                // ale pomijamy bloki, których typ jest w tablicy `dontcount`
                if (block.text) {
                    textarr.push({text:block.text,dx:x,dy:y});
                    
                }else if (blocks.length > 3 && index === blocks.length - 1 && !dontcount.includes(block.type) && options.hideBlocksnumber!==1) {
                    // Ustawienia tekstu
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';

                    // Rysowanie tekstu nad blokiem (przesunięcie y o 5 pikseli w górę)
                    ctx.fillText(`x${blocks.length - 2}`, x + blockSize / 2, y - 5);
                }

                // Sprawdzanie typów bloków dla drzew, aby je później odpowiednio narysować
                if (block.type === 'tree0' || block.type === 'yew0' || block.type === 'pine0') {
                    treesBelowPlayer.push({ type: block.type, x: x, y: y });
                }
                if (block.type === 'tree1' || block.type === 'tree2'|| block.type === 'voidblock'|| block.type === 'birch1' || block.type === 'birch2' || block.type === 'yew1' || block.type === 'pine1' || block.type === 'pine2'|| block.type === 'black_elderberry2'|| block.type === 'empty_black_elderberry2'|| block.type === 'houseroof'||block.type === 'ryeroof'||block.type === 'snowpine2'||block.type === 'snowpine3'||block.type === 'lamp2'||block.type === 'statue1_2'||block.type === 'statue2_2'||block.type === 'algae0'||block.type === 'algae2' ||block.type === 'helltree1'||block.type === 'helltree2'||block.type === 'abysstree1'||block.type === 'abysstree2'||block.type === 'gypsumroof'||block.type === 'palm2'||block.type === 'coconutpalm'||block.type === 'palm3'||block.type === 'palm32') {
                    treesAbovePlayer.push({ type: block.type, x: x, y: y });
                }
            });
        }
        
    }

ctx.translate(0,0);
function updateWaveEffect() {
  if (options.fancygraphic !== 0 && isunderwater === 1) {
    if(oned==0){
      oned=1
    ctx.save()
    }
    waveTick++;
    
    const time = waveTick / 15; 
    const waveOffset =( Math.sin(time) / 6);
    ctx.translate(0, waveOffset);
    
  } else {
    if(oned==1){
      ctx.restore()
      oned=0
    }
  }
}
updateWaveEffect()

    return { treesBelowPlayer, treesAbovePlayer };

            
}
var oned=0
let targetX = offsetX; // Docelowa pozycja X
let targetY = offsetY; // Docelowa pozycja Y
let smoothingFactor = 0.40; // Współczynnik gładkości (jak szybko gracz się przesuwa)

let targetFPS = 14; 
let frameDuration = 1000 / targetFPS; // Duration of each frame in milliseconds



















const enemyTextures = {};

// Definicje tekstur w formie obiektów zawierających klucze i ścieżki
const textureDefinitions = {
    'bat': './bat.png',
    'bat1': './bat1.png',
    'shark': './shark.png',
    'shark1': './shark1.png',
    'wasp': './wasp.png',
    'wasp1': './wasp1.png',
    
    'voidguardian1': './voidguardian1.png',
    'voidguardian2': './voidguardian2.png',


    'bunn-left': './bunn-left.png',
    'bunn-right': './bunn-right.png',
    'bunn-up': './bunn-up.png',
    'bunn-down': './bunn-down.png',

    'raven-down': './raven1down.png',
    'raven-down2': './raven2down.png',
    'raven-up': './raven1up.png',
    'raven-up2': './raven2up.png',
    'raven-left': './raven1left.png',
    'raven-left2': './raven2left.png',
    'raven-right': './raven1right.png',
    'raven-right2': './raven2right.png',

    'voltary': './voltary1.png',
    'voltary2': './voltary2.png',
    'voltary3': './voltary3.png',
    'firefly1': './firefly1.png',
    'firefly2': './firefly2.png',
    'aquagod1': './aquagod1.png',
    'aquagod2': './aquagod2.png',
    'aquagod3': './aquagod3.png',

    'insaneuniversegod1': './insaneuniversegod1.png',
    'insaneuniversegod2': './insaneuniversegod2.png',

    'deepgodhead': './deepgod.png',
    'deepgodtorso': './deepgodtorso.png',


    '2medusa1': './2medusa1.png',
    '2medusa2': './2medusa2.png',
    '2medusa3': './2medusa3.png',

    'skull': './skull1.png',
    'skull1': './skull2.png',

    'spikegod': './spikegod1.png',
    'spikegod1': './spikegod2.png',

    'giantbat': './gigabat1.png',
    'giantbat1': './gigabat2.png',

    '1medusa1': './1medusa1.png',
    '1medusa2': './1medusa2.png',

    'spary': './spary.png',
    'spary2': './spary2.png',

    'darkeye': './darkeye.png',

    'flesh1': './flesh1.png',
    'flesh2': './flesh2.png',
    'flesh3': './flesh3.png',

    'floatingeye1': './floatingeye1.png',
    'floatingeye2': './floatingeye2.png',
    
    'pinkslime1': './pink1.png',
    'pinkslime2': './pink2.png',
    'pinkslime3': './pink3.png',

    'greenslime1': './green1.png',
    'greenslime2': './green2.png',
    'greenslime3': './green3.png',

    'blueslime1': './blue1.png',
    'blueslime2': './blue2.png',
    'blueslime3': './blue3.png',
    
    'skellybonesright1': './skellybonesright1.png',
    'skellybonesright2': './skellybonesright2.png',
    'skellybonesleft1': './skellybonesleft1.png',
    'skellybonesleft2': './skellybonesleft2.png',
    'skellybonesup1': './skellybonesup1.png',
    'skellybonesup2': './skellybonesup2.png',
    'skellybonesdown1': './skellybonesdown1.png',
    'skellybonesdown2': './skellybonesdown2.png',

    'abyssdevourerbody': './abyssdevourertorso.png',
    'abyssdevourerhead': './abyssdevourer.png',
    
    'hellskull1': './hellskull1.png',
    'hellskull2': './hellskull2.png',

    'soulcat1': './soulcat1.png',
    'soulcat2': './soulcat2.png',
    'frozenghost1': './frozenghost1.png',
    'frozenghost2': './frozenghost2.png',
    'desertscourgebody': './desertscourgebody.png',
    'desertscourgehead': './desertscourgehead.png',
   'desertelemental1': './sandelemental1.png',
    'desertelemental2': './sandelemental2.png',
   'flesher1': './flesher1.png',
    'flesher2': './flesher2.png',
       'hellscourgebody': './hellscourgebody.png',
   'hellscourgehead': './hellscourgehead.png',
    'trueuniversehead': './trueuniverse.png', //not last boss worm :)) 
    'trueuniversebody': './trueuniversetorso.png',
    "universeblast":"./universeblast.png",
    "aquablast":"./aquablast.png",
    'ghost': './ghost.png',
    'ghost1': './ghost1.png',
    "crimsonprojectile":"./crimsonprojectile.png",
    "magic":"./magic.png",
    "magicsharp":"./magicsharp.png",
    "hyperblast":"./hyperblast.png",
    "greenmagic1": "./greenmagic.png",
    "greenmagic2": "./grennmagic1.png",

    "duckright1": "./duckright1.png",
    "duckright2": "./duckright2.png",
    "duckleft1": "./duckleft1.png",
    "duckleft2": "./duckleft2.png",
    "duckup1": "./duckup1.png",
    "duckup2": "./duckup2.png",
    "duckdown1": "./duckdown1.png",
    "duckdown2": "./duckdown2.png",
    
 
"godmagic": "./godmagic.png",
"arrow": "./arrow.png",
"powerfullarrow": "./powerfullarrow.png",
"goodarrow": "./goodarrow.png",
// boomerang 
"boomerang":"./boomerang.png",
"good_boomerang":"./good_boomerang.png",
"titanium_boomerang":"./titanium_boomerang.png",
"hell_boomerang":"./hell_boomerang.png",
"draco_boomerang":"./draco_boomerang.png",

    "butterflyyellow1": "./butterflyyellow1.png",
    "butterflyyellow2": "./butterflyyellow2.png",
    
    "butterflyred1": "./butterflyred1.png",
    "butterflyred2": "./butterflyred2.png",
    
    "butterflyblue1": "./butterflyblue1.png",
    "butterflyblue2": "./butterflyblue2.png",
    "universebulb": "./universebulb.png",
    "trueprojectile": "./trueprojectile.png",
};

for (const [key, path] of Object.entries(textureDefinitions)) {
    enemyTextures[key] = new Image();
    enemyTextures[key].src = path;
}
let RENDEREDENEMIES2 = [];
let renderedEnemies = []; // Lista przechowująca aktualnie renderowanych przeciwników
const enemies = {
 "arrow": { hp: Infinity, atk: 0 },
 "powerfullarrow": { hp: Infinity, atk: 0 },
 "goodarrow": { hp: Infinity, atk: 0 },
  "godmagic": { hp: Infinity, atk: 0 },
  "magic": { hp: Infinity, atk: 0 },
  "universeblast": { hp: Infinity, atk: 0 },
  "aquablast": { hp: Infinity, atk: 0 },
  "greenmagic": { hp: Infinity, atk: 0 },
  "butterflyred": { hp: 1, atk: 0 },
  "butterflyyellow": { hp: 1, atk: 0 },
"butterflyblue": { hp: 1, atk: 0 },
"firefly": { hp: 1, atk: 0 },
  "magicsharp": { hp: Infinity, atk: 0 },
  "hyperblast": { hp: Infinity, atk: 0 },
  "boomerang": { hp: Infinity, atk: 0 },
  "titanium_boomerang": { hp: Infinity, atk: 0 },
  "good_boomerang": { hp: Infinity, atk: 0 },
  "draco_boomerang": { hp: Infinity, atk: 0 },
  "hell_boomerang": { hp: Infinity, atk: 0 },
  "bat": { hp: 5, atk: -1 },
  "giantbat": { hp: 20, atk: -1 },
  "shark": { hp: 10, atk: -2 },
  "duck": { hp: 7, atk: -2 },
  "ghost": { hp: 2000, atk: -2 },
  "hellskull": { hp: 300, atk: -2 },
  "hellscourgehead": { hp: 1000, atk: -2 },
  "hellscourgebody": { hp: Infinity, atk: -2 },
  "bunny": { hp: 5, atk: 0 },
  "greenslime": { hp: 20, atk: -0.5 },
  "blueslime": { hp: 25, atk: -0.5 },
  "pinkslime": { hp: 40, atk: -0.5 },
  "skellybones": { hp: 40, atk: -0.5 },
  "wasp": { hp: 4, atk: -1 },
  "raven": { hp: 15, atk: -1 },
  "voltary": { hp: 1000, atk: -2 },
  "desertscourgehead": { hp: 500, atk: -2 },
  "desertscourgebody": { hp: Infinity, atk: -2 },
  "desertelemental": { hp: 300, atk: -2 },
"skull": { hp: 50, atk: -0.5 },
"spary": { hp: 200, atk: -0.5 },
"spikegod": { hp: 2000, atk: -1 },
"darkeye": { hp: 4000, atk: -1.5 },
"1medusa": { hp: 400, atk: -1.5 },
"2medusa": { hp: 5000, atk: -1.0 },
"floatingeye": { hp: 400, atk: -1.0 },
"flesh": { hp: 6000, atk: -1.0 },
"insaneuniversegod": { hp: 10000, atk: -2.0 },
"trueuniversehead": { hp: 25000, atk: -2.0 },
"trueuniversebody": { hp: Infinity, atk: -0.2 },
"aquagod": { hp: 3000, atk: -1.0 },
"voidguardian": { hp: 400, atk: -0.2 },
"soulcat": { hp: 200, atk: -0.2 },
"frozenghost": { hp: 200, atk: -0.2 },
"abyssdevourerhead": { hp: 700, atk: -2 },
"abyssdevourerbody": { hp: Infinity, atk: -2 },
"flesher": { hp: 2000, atk: -2 },
"deepgodtorso": { hp: Infinity, atk: -2 },
"deepgodhead": { hp: 17000, atk: -2 },
"crimsonprojectile": { hp: Infinity, atk: -2 },
"universebulb": { hp: 1000, atk: -1.0 },
"trueprojectile": { hp: Infinity, atk: -2 },
};

function Enemy(x, y, type) {
  this.x = x;
  this.y = y;
  this.type = type;
  this.width = 32;
  this.height = 32;
  this.speed = 3;
  this.id ;
  this.animationFrame = 0;
  this.tickCount = 0;
  this.angle=0;
  this.following=null;
  this.angleTickCounter=0;
  this.direction = Math.floor(Math.random() * 4);
  this.hp = enemies[type].hp; // Ustawienie życia w zależności od typu przeciwnika
}

const collisionRadius = 32; // Promień kolizji (w pikselach)

const enemyDespawnDistance = 200; // Odległość w pikselach, po której nietoperz przestaje podążać
const enemyDamageDistance = 1; // Odległość, w której nietoperz zadaje obrażenia graczowi
const despawnTicks = 100; // Liczba ticków po której nietoperz się despawnuje, jeśli za daleko
// Funkcja do sprawdzania kolizji z innymi przeciwnikami

function isCollidingWithEnemies(enemy) {
    return renderedEnemies.some(otherEnemy => {
        if (otherEnemy !== enemy) {
            const dx = (enemy.x + enemy.width / 2) - (otherEnemy.x + otherEnemy.width / 2);
            const dy = (enemy.y + enemy.height / 2) - (otherEnemy.y + otherEnemy.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < collisionRadius; // Zwraca true, jeśli są w kolizji
        }
        return false; // Ignoruje porównania z samym sobą
    });
}
let ddg=0
let darkeyes=0
let medusa2z=0
let fleshz=0
let universegodz=0


var VISIBLEIDS = [];
var AVAILABLE_IDS = []; // Tablica dostępnych ID

function getNextAvailableID() {
    if (AVAILABLE_IDS.length > 0) {
        return AVAILABLE_IDS.shift(); 
    } else {
        return VISIBLEIDS.length + 1; 
    }
}

function releaseID(id) {
    if (!AVAILABLE_IDS.includes(id)) {
        AVAILABLE_IDS.push(id);
        AVAILABLE_IDS.sort((a, b) => a - b); // Sortowanie w kolejności rosnącej
    }
}

// Tworzenie nowego `trueuniverse`
function createTrueUniverse() {
    var id = getNextAvailableID();
    VISIBLEIDS.push(id);
    var head = new Enemy(offsetX - 64, offsetY - 80, 'trueuniversehead');
    head.id = id;
    
    head.angle = 0;
    const wormLength = 30;
    let previousSegment = head;
    try {
        for (let i = 0; i < wormLength; i++) {
            const segment = new Enemy(previousSegment.x, previousSegment.y, 'trueuniversebody');
            segment.id = id; 
            segment.following = previousSegment;
            segment.angle = 0;
            previousSegment = segment;
            renderedEnemies.push(segment);
        }
        renderedEnemies.push(head);
    } catch (e) {
        console.log(e);
    }
}
function createDeepgod() {
  var id = getNextAvailableID();
  VISIBLEIDS.push(id);
  var head = new Enemy(offsetX - 64, offsetY - 80, 'deepgodhead');
  head.id = id;
  head.angle = 0;
  const wormLength = 40;
  let previousSegment = head;
  try {
    for (let i = 0; i < wormLength; i++) {
      const segment = new Enemy(previousSegment.x, previousSegment.y, 'deepgodtorso');
      segment.id = id;
      segment.following = previousSegment;
      segment.angle = 0;
      previousSegment = segment;
      renderedEnemies.push(segment);
    }
    renderedEnemies.push(head);
  } catch (e) {
    console.log(e);
  }
}
function createDesertScourge() {
  var id = getNextAvailableID();
  VISIBLEIDS.push(id);
  var head = new Enemy(offsetX - 64, offsetY - 80, 'desertscourgehead');
  head.id = id;

  head.angle = 0;
  const wormLength = 15;
  let previousSegment = head;
  try {
    for (let i = 0; i < wormLength; i++) {
      const segment = new Enemy(previousSegment.x, previousSegment.y, 'desertscourgebody');
      segment.id = id;
      segment.following = previousSegment;
      segment.angle = 0;
      previousSegment = segment;
      renderedEnemies.push(segment);
    }
    renderedEnemies.push(head);
  } catch (e) {
    console.log(e);
  }
}
function createHellScourge() {
  var id = getNextAvailableID();
  VISIBLEIDS.push(id);
  var head = new Enemy(offsetX - 64, offsetY - 80, 'hellscourgehead');
  head.id = id;
  head.angle = 0;
  const wormLength = 13;
  let previousSegment = head;
  try {
    for (let i = 0; i < wormLength; i++) {
      const segment = new Enemy(previousSegment.x, previousSegment.y, 'hellscourgebody');
      segment.id = id;
      segment.following = previousSegment;
      segment.angle = 0;
      previousSegment = segment;
      renderedEnemies.push(segment);
    }
    renderedEnemies.push(head);
  } catch (e) {
    console.log(e);
  }
}
function removeEntityById(entityId) {
    const toRemove = renderedEnemies.filter(enemy => enemy.id === entityId);
    renderedEnemies = renderedEnemies.filter(enemy => enemy.id !== entityId);
    releaseID(entityId);
}

let delaytt=0

function createAbyssdevourer() {
  setTimeout(function (){
    if(delaytt==0){
      delaytt==1
  function spawnBatNearPlayer() {
    let spawnDistanceh=290
  let batX, batY;
  if (Math.random() >= 0.45) {
    batX = offsetX + spawnDistanceh;
  } else {
    batX = offsetX;
  }
  if (Math.random() >= 0.45) {
    batY = offsetY + spawnDistanceh;  
  } else {
    batY = offsetY; 
  }
let id = getNextAvailableID();
VISIBLEIDS.push(id);
let head = new Enemy(batX , batY, 'abyssdevourerhead');
head.id = id;
head.angle = 0;
const wormLength = 10;
let previousSegment = head;
try {
  for (let i = 0; i < wormLength; i++) {
    const segment = new Enemy(previousSegment.x, previousSegment.y, 'abyssdevourerbody');
    segment.id = id;
    segment.following = previousSegment;
    segment.angle = 0;
    previousSegment = segment;
    renderedEnemies.push(segment);
  }
  renderedEnemies.push(head);
} catch (e) {
  console.log(e);
}
}
spawnBatNearPlayer()
}else{
  setTimeout(function (){delaytt=0; createAbyssdevourer },1000)
}
},1000)
}

var yyte=null
function gfggf(data){
  yyte=data
}
let updfixbug=0
var arrows = {
    "arrow": { dmg: -4.0, speed: 17 },
    "goodarrow": { dmg: -5.0, speed: 17 },
    "powerfullarrow": { dmg: -7.5, speed: 16 },
}
var magicspellsfromentities = {

  "greenmagic": { dmg: -8.0, speed: 5 },
  "boomerang": { dmg: -1.5, speed: 12 },
  "good_boomerang": { dmg: -50, speed: 18 },
  "hell_boomerang": { dmg: -100, speed: 20 },
  "draco_boomerang": { dmg: -200, speed: 18 },
  "titanium_boomerang": { dmg: -16, speed: 15 },
  "magic": { dmg: -15.2, speed: 9 },
  "magicsharp": { dmg: -15.2, speed: 10 },
  "hyperblast": { dmg: -25.0, speed: 13 },
  "godmagic": { dmg: -150.2, speed: 10 },
};
var boomerangs = {

    "boomerang": {  speed: 0.8},
 "good_boomerang":{speed:1},
 "titanium_boomerang":{speed:1.3},
 "draco_boomerang":{speed:1.4},
 "hell_boomerang":{speed:1.4},
};
var butterflyentities = {
  "butterflyred": {   },
  "butterflyyellow": {   },
  "butterflyblue": {   },
  "firefly":{},
 
};
var speedmultiply=1.45
function updateEnemies() {
  var removebymagic=0;
  if(updfixbug==0){
  darkeyes=0
  medusa2z=0
  
  fleshz=0
  universegodz=0
  let removedd = 0
  
  let newEnemies = [];
    renderedEnemies = renderedEnemies.filter(enemy => {
      const prevX = enemy.x;
const prevY = enemy.y;
const playerCenterX = offsetX + player.x + player.width / 2;
const playerCenterY = offsetY + player.y + player.height / 2;
let fixedspeed = 1.0
const diffX = playerCenterX - 15 - enemy.x - enemy.width / 2;
const diffY = playerCenterY - 15 - enemy.y - enemy.height / 2;
const distanceToPlayer = Math.sqrt(diffX * diffX + diffY * diffY);

      
var fds22 = 25
if (enemy.hp > 10000) {
  fds22 = 24
} if (enemy.hp < 10000) {
  fds22 = 22
}


if (enemy.type in magicspellsfromentities) {
  const spell = magicspellsfromentities[enemy.type];
  enemy.height = 32 - 8;
  enemy.width = 32 - 8;

  // Ruch czaru
  enemy.x += Math.cos(enemy.angle) * spell.speed*speedmultiply;
  enemy.y += Math.sin(enemy.angle) * spell.speed*speedmultiply;
  renderedEnemies.forEach(otherEnemy => {
    if (otherEnemy !== enemy) {
      const distanceFromSpell = Math.sqrt(
        ((otherEnemy.x + otherEnemy.width / 2) - (enemy.x + enemy.width / 2)) ** 2 +
        ((otherEnemy.y + otherEnemy.height / 2) - (enemy.y + enemy.height / 2)) ** 2
      );

      if (distanceFromSpell <= 32) {
        otherEnemy.hp += spell.dmg; 
        removebymagic=1
        return false;
      }
    }
  });
}
if (enemy.type in boomerangs) {
    const spell = boomerangs[enemy.type];
    enemy.height = 32+2;
    enemy.width = 32+2 ;
if(!enemy.angle2){enemy.angle2 = 0;}
 enemy.angle2 += spell.speed
}
if (enemy.type in arrows) {
    const spell = arrows[enemy.type];
    enemy.height = 32 + 2;
    enemy.width = 32 + 2;
      // Ruch czaru
  enemy.x += Math.cos(enemy.angle) * spell.speed * speedmultiply;
  enemy.y += Math.sin(enemy.angle) * spell.speed * speedmultiply;
  renderedEnemies.forEach(otherEnemy => {
      if (otherEnemy !== enemy) {
          const distanceFromSpell = Math.sqrt(
              ((otherEnemy.x + otherEnemy.width / 2) - (enemy.x + enemy.width / 2)) ** 2 +
              ((otherEnemy.y + otherEnemy.height / 2) - (enemy.y + enemy.height / 2)) ** 2
          );

          if (distanceFromSpell <= 32) {
              if(enemy.atkplus){
              otherEnemy.hp += spell.dmg-enemy.atkplus;
              }else{
                  otherEnemy.hp += spell.dmg
              }
              removebymagic = 1
              return false;
          }
      }
  });
}
        // Obsługa segmentów robaka
        

        if (enemy.type === "trueuniversebody" && enemy.following) {

            const prevSegment = enemy.following;
            enemy.height = 64
enemy.width = 64
            const distance = Math.sqrt((prevSegment.x - enemy.x) ** 2 + (prevSegment.y - enemy.y) ** 2);
            const angleToFollow = Math.atan2(prevSegment.y - enemy.y, prevSegment.x - enemy.x);
            enemy.angle = angleToFollow;
            let  followDistance = 40; // Odstęp między segmentami
            if(fds22>25){
              followDistance=3
              
            }
            
            if (distance > followDistance) {
                enemy.x += Math.cos(angleToFollow) * fds22*speedmultiply;
                enemy.y += Math.sin(angleToFollow) * fds22*speedmultiply
            }
            if (!checkIfHasEnemy("trueuniversehead", 1)) {
  return false;
}
        }

        if (enemy.type === "trueuniversehead") {
    enemy.height = 64;
    enemy.width = 64;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;  
    }
    
    
let entityname2 = "trueprojectile"
if (Math.random() <= 0.095) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, entityname2);
  const spawnDistance = 9 * blockSize;

  function spawnBatNearPlayer() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;
      batY += Math.random() * 200 - 100;
    } else {
      batX = offsetX;
      batY += Math.random() * 200 - 100;
    }
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance;
      batX += Math.random() * 200 - 100;
    } else {
      batY = offsetY;
      batX += Math.random() * 200 - 100;
    }
    
    let bat = new Enemy(batX, batY, entityname2);

    newEnemies.push(bat);
  }

  spawnBatNearPlayer();
}


    let fds=Math.random()<0.010
    if(enemy.hp>15000){
    fds=Math.random()<0.010
    }else{
    fds=Math.random()<0.08
    }
    let gdf=35
    let fds2=10
    if(enemy.hp>10000){
    fds2=24
    gdf=35
    }else{
    fds2=27
    gdf=25
    }
    if (Math.random() <= 0.0025) {
  const typesof = ["universeblast"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer(x,y) {
    let bat = new Enemy(x, y, randomSpell); bat.width=32;bat.height=32; ; renderedEnemies.push(bat);  bat.speed=25
  } for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    spawnEnemyNearPlayer(enemy.x,enemy.y);
  }, i * 200);
}}
    if (enemy.angleTickCounter % gdf === 0 || fds) {
        const angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
    const amplitude = 15;
const frequency = 0.3;
const perpendicularAngle = enemy.angle + Math.PI / 2;
const sinusoidalOffsetX = Math.cos(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
const sinusoidalOffsetY = Math.sin(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
enemy.x += enemy.directionX * fds2 + sinusoidalOffsetX*speedmultiply;
enemy.y += enemy.directionY * fds2 + sinusoidalOffsetY*speedmultiply;

enemy.angleTickCounter++;
    enemy.angleTickCounter++;
    if (enemy.hp <= 0) {
  gfggf(enemy.id)
  return false; // Usuwa `trueuniversehead`, gdy hp <= 0
}
}

if (enemy.type === "abyssdevourerhead") {
    enemy.height = 64;
    enemy.width = 64;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let fds = Math.random() < 0.055; let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 35 === 0 || fds) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
    const amplitude = 5; 
    const frequency = 0.8; 
    const perpendicularAngle = enemy.angle + Math.PI / 2; 
    const sinusoidalOffsetX = Math.cos(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    const sinusoidalOffsetY = Math.sin(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    enemy.x += enemy.directionX * 8 + sinusoidalOffsetX*speedmultiply;
    enemy.y += enemy.directionY * 8 + sinusoidalOffsetY*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    if (distanceToPlayer > 250) {
        enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
        if (enemy.despawnTickCount > 1000) {
            gfggf(enemy.id)
            return false; 
        }
    }
    if (enemy.hp <= 1 || inabyss==0) {
        gfggf(enemy.id)
        return false; 
    }
}
if (enemy.type === "abyssdevourerbody" && enemy.following) {
          const prevSegment = enemy.following;
          enemy.height = 64; enemy.width = 64
          const distance = Math.sqrt((prevSegment.x - enemy.x) ** 2 + (prevSegment.y - enemy.y) ** 2);
          const angleToFollow = Math.atan2(prevSegment.y - enemy.y, prevSegment.x - enemy.x);
          enemy.angle = angleToFollow;
          let followDistance = 50; 
          if (distance > followDistance) {
            enemy.x += Math.cos(angleToFollow) * 12*speedmultiply;
            enemy.y += Math.sin(angleToFollow) * 12*speedmultiply
          }
          if(!checkIfHasEnemy("abyssdevourerhead",1)){
            return false;
          }
        }

if (enemy.type === "deepgodhead") {
    enemy.height = 64;
    enemy.width = 64;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let fds = Math.random() < 0.055; let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 35 === 0 || fds) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
    const amplitude = 9; 
    const frequency = 0.5; 
    const perpendicularAngle = enemy.angle + Math.PI / 2; 
    const sinusoidalOffsetX = Math.cos(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    const sinusoidalOffsetY = Math.sin(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    enemy.x += enemy.directionX * 8 + sinusoidalOffsetX*speedmultiply;
    enemy.y += enemy.directionY * 8 + sinusoidalOffsetY*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    
    if (enemy.hp <= 1 ) {
        gfggf(enemy.id)
        return false; 
    }
    if (Math.random() <= 0.018) {
  const typesof = ["aquablast"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer(x,y) {
    let bat = new Enemy(x, y, randomSpell); bat.width=32;bat.height=32; ; renderedEnemies.push(bat);  bat.speed=20
  } for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    spawnEnemyNearPlayer(enemy.x,enemy.y);
  }, i * 250);
}}
}
if (enemy.type === "deepgodtorso" && enemy.following) {
          const prevSegment = enemy.following;
          enemy.height = 64; enemy.width = 64
          const distance = Math.sqrt((prevSegment.x - enemy.x) ** 2 + (prevSegment.y - enemy.y) ** 2);
          const angleToFollow = Math.atan2(prevSegment.y - enemy.y, prevSegment.x - enemy.x);
          enemy.angle = angleToFollow;
          let followDistance = 50; 
          if (distance > followDistance) {
            enemy.x += Math.cos(angleToFollow) * 12*speedmultiply;
            enemy.y += Math.sin(angleToFollow) * 12*speedmultiply
          }
          
          if(!checkIfHasEnemy("deepgodhead",1)){
            return false;
          }
        }
if (enemy.type === "aquablast"||enemy.type === "universeblast") {
    enemy.height = 32;
    enemy.width = 32;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 1000 === 0 ) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
     
    enemy.x += enemy.directionX * enemy.speed*speedmultiply;
    enemy.y += enemy.directionY * enemy.speed*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    if (distanceToPlayer > 150) {
        enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
        if (enemy.despawnTickCount > 100) {
            return false; 
        }
    }
    if (enemy.type in arrows) {}else if (enemy.type in magicspellsfromentities) {}else{
      
 if (distanceToPlayer <= 32 && enemy.type == "universeblast") { updateHealth(-1.2); }else if (distanceToPlayer <= 32) { updateHealth(-0.8); }
}}
if (enemy.type === "crimsonprojectile") {
    enemy.height = 32-8;
    enemy.width = 32-8;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 1000 === 0 ) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
     
    enemy.x += enemy.directionX * 9*speedmultiply;
    enemy.y += enemy.directionY * 9*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    if (distanceToPlayer > 150) {
        enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
        if (enemy.despawnTickCount > 100) {
            return false; 
        }
    }
    if (enemy.type in arrows) {}else if (enemy.type in magicspellsfromentities) {}else{
if (distanceToPlayer <= 32) { updateHealth(-1.5); }
}}
if (enemy.type === "trueprojectile") {
    enemy.height = 32-8;
    enemy.width = 32-8;
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 1000 === 0 ) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
     
    enemy.x += enemy.directionX * 10*speedmultiply;
    enemy.y += enemy.directionY * 10*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    if (distanceToPlayer > 150) {
        enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
        if (enemy.despawnTickCount > 100) {
            return false; 
        }
    }
   if (enemy.type in arrows) {}else if (enemy.type in magicspellsfromentities) {}else{
if (distanceToPlayer <= 32) { updateHealth(-1.5); }
}}
if (enemy.type === "hellscourgehead") {
    enemy.height =32+16
    enemy.width = 32+16
    const playerCenterX = offsetX + player.x + player.width / 2;
    const playerCenterY = offsetY + player.y + player.height / 2;
    if (!enemy.angleTickCounter) {
        enemy.angleTickCounter = 0;
        enemy.previousAngle = enemy.angle || 0;
    }
    const distanceToPlayer = Math.sqrt(
        (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
    ); let fds = Math.random() < 0.055; let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
    if (enemy.angleTickCounter % 35 === 0 || fds) {
        enemy.previousAngle = angleToPlayer;
        enemy.angle = angleToPlayer;
        enemy.directionX = Math.cos(angleToPlayer);
        enemy.directionY = Math.sin(angleToPlayer);
    }
    const amplitude = 5; 
    const frequency = 0.5; 
    const perpendicularAngle = enemy.angle + Math.PI / 2; 
    const sinusoidalOffsetX = Math.cos(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    const sinusoidalOffsetY = Math.sin(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
    enemy.x += enemy.directionX * 5 + sinusoidalOffsetX*speedmultiply;
    enemy.y += enemy.directionY * 5 + sinusoidalOffsetY*speedmultiply;
enemy.angle = angleToPlayer;
    enemy.angleTickCounter++;
    if (distanceToPlayer > 250) {
        enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
        if (enemy.despawnTickCount > 1000) {
            gfggf(enemy.id)
            return false; 
        }
    }
    if (enemy.hp <= 1 || inhell==0) {
        gfggf(enemy.id)
        return false; 
    }
}
if (enemy.type === "hellscourgebody" && enemy.following) {
          const prevSegment = enemy.following;
          enemy.height = 32+16; enemy.width = 32+16;
          const distance = Math.sqrt((prevSegment.x - enemy.x) ** 2 + (prevSegment.y - enemy.y) ** 2);
          const angleToFollow = Math.atan2(prevSegment.y - enemy.y, prevSegment.x - enemy.x);
          enemy.angle = angleToFollow;
          let followDistance = 30; 
          if (distance > followDistance) {
            enemy.x += Math.cos(angleToFollow) * 10*speedmultiply;
            enemy.y += Math.sin(angleToFollow) * 10*speedmultiply
          }
          if(!checkIfHasEnemy("hellscourgehead",1)){
            return false;
          }
        }
        
        
        
if (enemy.type === "desertscourgehead") {
  enemy.height = 32+16
  enemy.width = 32+16
  const playerCenterX = offsetX + player.x + player.width / 2;
  const playerCenterY = offsetY + player.y + player.height / 2;
  if (!enemy.angleTickCounter) {
    enemy.angleTickCounter = 0;
    enemy.previousAngle = enemy.angle || 0;
  }
  const distanceToPlayer = Math.sqrt(
    (playerCenterX - enemy.x) ** 2 + (playerCenterY - enemy.y) ** 2
  );
  let fds = Math.random() < 0.055;
  let angleToPlayer = Math.atan2(playerCenterY - enemy.y, playerCenterX - enemy.x);
  if (enemy.angleTickCounter % 35 === 0 || fds) {
    enemy.previousAngle = angleToPlayer;
    enemy.angle = angleToPlayer;
    enemy.directionX = Math.cos(angleToPlayer);
    enemy.directionY = Math.sin(angleToPlayer);
  }
  const amplitude = 6; // Amplituda sinusoidy
  const frequency = 0.5; // Częstotliwość
  const perpendicularAngle = enemy.angle + Math.PI / 2; // Prostopadły do kierunku ruchu

  const sinusoidalOffsetX = Math.cos(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);
  const sinusoidalOffsetY = Math.sin(perpendicularAngle) * amplitude * Math.sin(enemy.angleTickCounter * frequency);

  enemy.x += enemy.directionX * 6 + sinusoidalOffsetX*speedmultiply;
  enemy.y += enemy.directionY * 6 + sinusoidalOffsetY*speedmultiply;
  enemy.angle = angleToPlayer;
  enemy.angleTickCounter++;
  if (distanceToPlayer > 200) {
    enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
    if (enemy.despawnTickCount > 100) {
      gfggf(enemy.id)
      return false; 
    }
  }
  if (enemy.hp <= 1 ) {
    gfggf(enemy.id)
    return false; 
  }
}

if (enemy.type === "desertscourgebody" && enemy.following) {
  const prevSegment = enemy.following;
  enemy.height = 32+16
  enemy.width = 32+16
  const distance = Math.sqrt((prevSegment.x - enemy.x) ** 2 + (prevSegment.y - enemy.y) ** 2);
  const angleToFollow = Math.atan2(prevSegment.y - enemy.y, prevSegment.x - enemy.x);
  enemy.angle = angleToFollow;
  let followDistance = 32;
  if (distance > followDistance) {
    enemy.x += Math.cos(angleToFollow) * 8*speedmultiply
    enemy.y += Math.sin(angleToFollow) * 8*speedmultiply
  }
  if (!checkIfHasEnemy("desertscourgehead", 1)) {
    return false;
  }
}

if (enemy.type == "2medusa" ) {
  if (medusa2z < 1) {
    nightpower=0;
    isRaining=false
    medusa2z += 1
    ctx.fillStyle = `rgba(0, 125, 255, 0.45)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  if (distanceToPlayer > 250) {
  enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
  if (enemy.despawnTickCount > 1000) {
    gfggf(enemy.id)

    return false; // Usuwa `trueuniversehead`, gdy hp <= 0
  }
}
}
if (enemy.type == "aquagod") {
  if (medusa2z < 1) {
    nightpower = 0;
    isRaining = false
    medusa2z += 1
    ctx.fillStyle = `rgba(0, ${Math.random()*255}, ${Math.random()*255}, 0.10)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}
if (enemy.type == "insaneuniversegod") {
  if (universegodz < 1) {
    nightpower = 0;
    isRaining = false
    universegodz += 1
    ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.20)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}


        if (enemy.type == "flesh") {
          enemy.speed=5;
          if (fleshz < 1) {
            if(Math.random()<0.6){
            nightpower = 2.5;
            }else{
              nightpower = 3
            }
            isRaining = false;
            fleshz += 1
            ctx.fillStyle = `rgba(255, 50, 50, ${Math.random()/3.5})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        
if(enemy.type=="darkeye"){
          if(darkeyes<1){
            darkeyes+=1
 ctx.fillStyle = `rgba(255, 0, 0, 0.3)`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
        }
        


        if(enemy.type=="voltary"||enemy.type=="spikegod"){
          enemy.height=80
          enemy.width=80
          if (Math.random() <= 0.015) {
            showTextInCanvas("skull summoned")
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'skull');
  const spawnDistance = 9 * blockSize;
  function spawnBatNearPlayer() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;  
    } else {
      batX = offsetX;  
    }
if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance;  
    } else {
      batY = offsetY;  
    }
    let bat = new Enemy(batX, batY, 'skull'); newEnemies.push(bat);  }spawnBatNearPlayer();
}}
if(enemy.type=="flesher"){
if (Math.random() <= 0.04) {
  function spawnBatNearPlayer() {
    let batX, batY;
    batX=enemy.x
    batY=enemy.y
    let bat = new Enemy(batX, batY, 'crimsonprojectile');
    bat.speed=9 
    newEnemies.push(bat);  
  }spawnBatNearPlayer();
}}
        if(enemy.type=="darkeye"){
          enemy.height=80
          enemy.width=80
          if (Math.random() <= 0.013) {
          //  showTextInCanvas("spary summoned")
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'spary');
  const spawnDistance = 9 * blockSize;
  function spawnBatNearPlayer() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;  
    } else {
      batX = offsetX;  
    }
if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance;  
    } else {
      batY = offsetY;  
    }
    let bat = new Enemy(batX, batY, 'spary');
    newEnemies.push(bat);  
  }
  spawnBatNearPlayer();
}
        }
if (enemy.type == "flesh"||enemy.type=="insaneuniversegod"||enemy.type=="aquagod") {
  enemy.height = 80 + 32;
  enemy.width = 80 + 32;
let ggdf = 0;

// Funkcja aktualizacji kąta gracza
function updatePlayerAngle() {
    switch (lastDirection) {
        case 'right':
            ggdf = 0;
            break;
        case 'down':
            ggdf = 90;
            break;
        case 'left':
            ggdf = 180;
            break;
        case 'up':
            ggdf = 270;
            break;
    }
}
updatePlayerAngle();

// Szansa na teleportację flesh
if (Math.random() < 0.013) {
    // Przelicz ggdf na radiany
    const angleInRadians = ggdf * (Math.PI / 180);

    // Obliczenie wektora kierunku patrzenia gracza, przemieszczamy się o 32 * 5 jednostek w kierunku patrzenia
    const playerDirectionX = Math.cos(angleInRadians) * 32 * 5;
    const playerDirectionY = Math.sin(angleInRadians) * 32 *5;

    // Aktualizacja pozycji przeciwnika typu 'flesh' w kierunku patrzenia gracza
    enemy.x = offsetX+player.x/1.5 + playerDirectionX;
    enemy.y =offsetY-32+ player.y + playerDirectionY;
}
let entityname="floatingeye"
if(enemy.type=="insaneuniversegod"){
  entityname="universebulb"
}
    // Przelicz ggdf na radiany
    const angleInRadians = ggdf * (Math.PI / 180);
    const playerDirectionX = Math.cos(angleInRadians) * 32 * 5;
    const playerDirectionY = Math.sin(angleInRadians) * 32 * 5;
  // Losowe przywoływanie floatingeye
  let rand=Math.random() <= 0.035
  if (enemy.type == "insaneuniversegod") {
  rand = Math.random() <= 0.025
}
  if (rand) {
    if(!checkIfHasEnemy(entityname,9)){
    let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, entityname);
    const spawnDistance = 9 * blockSize;

    function spawnBatNearPlayer() {
      let batX, batY;
      if (Math.random() >= 0.3) {
        batX = offsetX + spawnDistance;
      } else {
        batX = offsetX;
      }
      if (Math.random() >= 0.3) {
        batY = offsetY + spawnDistance;
      } else {
        batY = offsetY;
      }
      batX = offsetX+32 + player.x / 1.5 + playerDirectionX;
     batY = offsetY-32+ player.y + playerDirectionY;
      let bat = new Enemy(batX, batY, entityname);
       
      newEnemies.push(bat);
    }
    spawnBatNearPlayer();
  }}
  let entityname2 = "crimsonprojectile"
if (enemy.type == "insaneuniversegod") {
  entityname2 = "trueprojectile"
}
  if (Math.random() <= 0.085) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, entityname2);
  const spawnDistance = 9 * blockSize;

  function spawnBatNearPlayer() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;
      batY += Math.random()*200-100;
    } else {
      batX = offsetX;
      batY += Math.random()*200-100;
    }
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance ;
      batX += Math.random()*200-100;
    } else {
      batY = offsetY;
      batX += Math.random()*200-100;
    }
    batX = offsetX + 32 + player.x / 1.5 + playerDirectionX ;
    batY = offsetY - 32 + player.y + playerDirectionY;
    let bat = new Enemy(batX, batY, entityname2);

    newEnemies.push(bat);
  }

  spawnBatNearPlayer();
}
}
if(enemy.type=="2medusa"){
          enemy.height=80+16
          enemy.width=80+16
          if (Math.random() <= 0.018) {
          //  showTextInCanvas("medusa summoned")
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, '1medusa');
  const spawnDistance = 9 * blockSize;
  function spawnBatNearPlayerd() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;  
    } else {
      batX = offsetX;  
    }
if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance;  
    } else {
      batY = offsetY;  
    }
    let bat = new Enemy(batX, batY, '1medusa');
    newEnemies.push(bat);  
  } spawnBatNearPlayerd(); }}
if (enemy.type == "skull") {
  enemy.speed = 5
}if (enemy.type == "giantbat") {
  enemy.speed = 5
}
if (enemy.type == "voidguardian") {
  enemy.speed = 3
  enemy.width=64;
  enemy.height=64;
}
if (enemy.type == "floatingeye") {
  enemy.speed = 3
  if (Math.random() <= 0.045) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'crimsonprojectile');
  const spawnDistance = 9 * blockSize;

  function spawnBatNearPlayer() {
    batX = enemy.x
    batY = enemy.y
    let bat = new Enemy(batX, batY, 'crimsonprojectile');
    newEnemies.push(bat);
  }

  spawnBatNearPlayer();
}
}
if (enemy.type == "universebulb") {
  enemy.speed = 3
  if (Math.random() <= 0.025) {
    let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'trueprojectile');
    const spawnDistance = 9 * blockSize;

    function spawnBatNearPlayer() {
      batX = enemy.x
      batY = enemy.y
      let bat = new Enemy(batX, batY, 'trueprojectile');
      newEnemies.push(bat);
    }

    spawnBatNearPlayer();
  }
}
if (enemy.type == "soulcat") {
  enemy.speed = 2
}

if (enemy.type === "raven") {
  if (distanceToPlayer < enemyDespawnDistance) {
    enemy.despawnTickCount = 0;
enemy.speed=1.5
    const moveX = (diffX / distanceToPlayer) * enemy.speed;
const moveY = (diffY / distanceToPlayer) * enemy.speed;
enemy.x += moveX *(enemy.speed*fixedspeed)*speedmultiply;
enemy.y += moveY *(enemy.speed*fixedspeed)*speedmultiply;
if (Math.abs(moveX) > Math.abs(moveY)) {
  enemy.direction = moveX > 0 ? 3 : 2; // left or right
} else {
  enemy.direction = moveY > 0 ? 1 : 0; // up or down
}
  } else {
    enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
    if (enemy.despawnTickCount > despawnTicks) {
      return false; // Usuwamy kruka
    }
  }}
  
 if (enemy.type in butterflyentities) {

enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > 300) {
return false; // Usuwamy nietoperza z tablicy
}

if (Math.random() < 0.10) { 
enemy.direction = Math.floor(Math.random() * 4);
}
switch (enemy.direction) {
case 1: // up
enemy.y += (enemy.speed*fixedspeed);
break;
case 0: // down
enemy.y -= (enemy.speed*fixedspeed);
break;
case 3: // left
enemy.x += (enemy.speed*fixedspeed)
break;
case 2: // right
enemy.x -= (enemy.speed*fixedspeed)
break;
}}

if (enemy.type == "bunny"||enemy.type == "soulcat"||enemy.type == "duck") {
    if(enemy.type !== "duck"){
if(distanceToPlayer> 5* blockSize ){
enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > despawnTicks) {
return false; // Usuwamy nietoperza z tablicy
}}
}else{
    if(distanceToPlayer> 8* blockSize ){
enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > despawnTicks) {
return false; // Usuwamy nietoperza z tablicy
}}
}
if (distanceToPlayer < 2 * blockSize) {
const moveX = (-diffX / distanceToPlayer) * enemy.speed;
const moveY = (-diffY / distanceToPlayer) * enemy.speed;
enemy.x += moveX*5*speedmultiply;
enemy.y += moveY*5*speedmultiply;
if (Math.abs(moveX) > Math.abs(moveY)) {
enemy.direction = moveX > 0 ? 3 : 2; // left or right
} else {
enemy.direction = moveY > 0 ? 1 : 0; // up or down
}} else {
if (Math.random() < 0.10) { 
enemy.direction = Math.floor(Math.random() * 4);
}
switch (enemy.direction) {
case 1: // up
enemy.y += (enemy.speed*fixedspeed)*speedmultiply;
break;
case 0: // down
enemy.y -= (enemy.speed*fixedspeed)*speedmultiply;
break;
case 3: // left
enemy.x += (enemy.speed*fixedspeed)*speedmultiply
break;
case 2: // right
enemy.x -= (enemy.speed*fixedspeed)*speedmultiply
break;
}}}else if(enemy.type=="skellybones"||enemy.type=="voidguardian"){

  
  if(distanceToPlayer> 5* blockSize ){
enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > despawnTicks) {
return false; 
}}
if (distanceToPlayer < 5 * blockSize) {
const moveX = (-diffX / distanceToPlayer) * enemy.speed;
const moveY = (-diffY / distanceToPlayer) * enemy.speed;
enemy.x -= moveX*0.6*speedmultiply;
enemy.y -= moveY*0.6*speedmultiply;
if (Math.abs(moveX) > Math.abs(moveY)) {
enemy.direction = moveX > 0 ? 2 : 3; // left or right
} else {
enemy.direction = moveY > 0 ? 0 : 1; // up or down
}}
switch (enemy.direction) {
case 1: // up
enemy.y += (enemy.speed*fixedspeed)*speedmultiply;
break;
case 0: // down
enemy.y -= (enemy.speed*fixedspeed)*speedmultiply;
break;
case 3: // left
enemy.x += (enemy.speed*fixedspeed)*speedmultiply
break;
case 2: // right
enemy.x -= (enemy.speed*fixedspeed)*speedmultiply
break;
}}else if(enemy.type=="pinkslime"||enemy.type=="blueslime"||enemy.type=="greenslime"){
  if(distanceToPlayer> 6* blockSize ){
    enemy.speed=1.5
enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > despawnTicks) {
return false; 
}}
if (distanceToPlayer < 2 * blockSize) {
const moveX = (-diffX / distanceToPlayer) * enemy.speed;
const moveY = (-diffY / distanceToPlayer) * enemy.speed;
enemy.x -= moveX*0.6*speedmultiply;
enemy.y -= moveY*0.6*speedmultiply;
if (Math.abs(moveX) > Math.abs(moveY)) {
enemy.direction = moveX > 0 ? 2: 3; // left or right
} else {
enemy.direction = moveY > 0 ? 0 :1; // up or down
}}else {
  if (Math.random() < 0.10) {
    enemy.direction = Math.floor(Math.random() * 4);
  }
}
switch (enemy.direction) {
case 1: // up
enemy.y += (enemy.speed*fixedspeed)*speedmultiply;
break;
case 0: // down
enemy.y -= (enemy.speed*fixedspeed)*speedmultiply;
break;
case 3: // left
enemy.x += (enemy.speed*fixedspeed)*speedmultiply
break;
case 2: // right
enemy.x -= (enemy.speed*fixedspeed)*speedmultiply
break;
}}
if (enemy.type in arrows) {} else if (enemy.type in magicspellsfromentities) {}else{
if (distanceToPlayer < enemyDespawnDistance&& enemy.type!=="bunny"&& enemy.type!=="duck"&& enemy.type!=="soulcat"&& enemy.type!=="pinkslime"&& enemy.type!=="blueslime"&& enemy.type!=="greenslime"&& enemy.type!=="skellybones"&&enemy.type!=="voidguardian"&& enemy.type!=="voltary" && enemy.type!=="spikegod"&&enemy.type!=="darkeye"&&enemy.type!=="flesh"&&enemy.type!=="2medusa"&&enemy.type!=="insaneuniversegod"&&enemy.type!=="aquagod"&&enemy.type!=="trueuniversebody"&&enemy.type!=="trueuniversehead"&&enemy.type!=="abyssdevourerbody"&&enemy.type!=="abyssdevourerhead" &&enemy.type !== "desertscourgehead"&&enemy.type !== "desertscourgebody"&&enemy.type !== "hellscourgebody"&&enemy.type !== "hellscourgehead"&& enemy.type !== "crimsonprojectile"&&enemy.type !== "deepgodhead"&&enemy.type !== "deepgodtorso"&& enemy.type !== "aquablast"&&enemy.type !== "trueprojectile"&&enemy.type !== "universeblast" && !(enemy.type in butterflyentities)) {
enemy.despawnTickCount = 0;
const moveX = (diffX / distanceToPlayer) * (enemy.speed*fixedspeed)
const moveY = (diffY / distanceToPlayer) * (enemy.speed*fixedspeed);
enemy.x += moveX*speedmultiply;
enemy.y += moveY*speedmultiply;
} } if (distanceToPlayer < 99999999999*2 && (enemy.type == "voltary"|| enemy.type == "skull"|| enemy.type == "spary"|| enemy.type =="spikegod"||enemy.type=="darkeye" || enemy.type=="1medusa"|| enemy.type=="2medusa" || enemy.type =="floatingeye"||enemy.type =="universebulb"||enemy.type =="flesh" ||enemy.type=="insaneuniversegod"|| enemy.type=="aquagod")) {
enemy.speed=3+Math.floor(Math.random()*4)
if (enemy.type == "spary") { enemy.speed = 2; }
if (enemy.type == "insaneuniversegod") { enemy.speed = 7;}
if (enemy.type == "1medusa") { enemy.speed = 2.5;}
if (enemy.type == "floatingeye") { enemy.speed = 2;}
if (enemy.type == "flesh") {
  enemy.speed = 6; if(enemy.hp<5000){ enemy.speed = 7; enemy.hp+=1.5; }}
  
const moveX = (diffX / distanceToPlayer) * (enemy.speed * fixedspeed)
const moveY = (diffY / distanceToPlayer) * (enemy.speed * fixedspeed);
enemy.x += moveX*speedmultiply;
enemy.y += moveY*speedmultiply;
} else if(enemy.type!=="bunny"&& enemy.type!=="duck"&& enemy.type!=="pinkslime"&& enemy.type!=="soulcat"&& enemy.type!=="blueslime"&& enemy.type!=="greenslime"&& enemy.type!=="skellybones"&&enemy.type!=="voidguardian"&&enemy.type!=="voltary"&& enemy.type!=="spikegod"&& enemy.type!=="2medusa" && enemy.type!=="darkeye" &&enemy.type!=="flesh" &&enemy.type!=="insaneuniversegod"&&enemy.type!=="aquagod"&&enemy.type!=="trueuniversebody"&&enemy.type!=="trueuniversehead"&&enemy.type!=="abyssdevourerbody"&&enemy.type!=="abyssdevourerhead"&&enemy.type !== "desertscourgehead"&&enemy.type !== "desertscourgebody"&&enemy.type !== "hellscourgebody"&&enemy.type !== "hellscourgehead"&& enemy.type !== "crimsonprojectile"&&enemy.type !== "trueprojectile"&&enemy.type !== "deepgodhead"&&enemy.type !== "deepgodtorso"&& enemy.type !== "aquablast"&&enemy.type !== "universeblast" && !(enemy.type in butterflyentities)){
enemy.despawnTickCount = (enemy.despawnTickCount || 0) + 1;
if (enemy.despawnTickCount > despawnTicks) {
return false; 
}}
let collisionDetected = false;
const distanceFromPlayer = Math.sqrt(
          ((enemy.x+enemy.width/2) - playerCenterX) ** 2 + ((enemy.y+enemy.height/2) - playerCenterY) ** 2);
let collisionDetected2 = false;
if (enemy.type in arrows) {}else  if (enemy.type in magicspellsfromentities || enemy.type in butterflyentities) {} else if (enemy.type!=="aquablast" && enemy.type!=="universeblast"){
if (distanceFromPlayer <= 32) {  updateHealth(-1);
if(enemy.type=="trueuniversehead"){
  updateHealth(-5);
}
if (enemy.type == "trueuniversebody") {
  updateHealth(-2);
}
if(enemy.type=="flesh"|| enemy.type=="insaneuniversegod"|| enemy.type=="aquagod"){
  let ggdf = 0;
updateHealth(-10);
// Funkcja aktualizacji kąta gracza
function updatePlayerAngle() {
    switch (lastDirection) {
        case 'right':
            ggdf = 0;
            break;
        case 'down':
            ggdf = 90;
            break;
        case 'left':
            ggdf = 180;
            break;
        case 'up':
            ggdf = 270;
            break;
    }
}
updatePlayerAngle();



    // Przelicz ggdf na radiany
    const angleInRadians = ggdf * (Math.PI / 180);

    // Obliczenie wektora kierunku patrzenia gracza, przemieszczamy się o 32 * 5 jednostek w kierunku patrzenia
    const playerDirectionX = Math.cos(angleInRadians) * 32 * 5;
    const playerDirectionY = Math.sin(angleInRadians) * 32 *5;

    // Aktualizacja pozycji przeciwnika typu 'flesh' w kierunku patrzenia gracza
    enemy.x = offsetX+player.x/1.5 + playerDirectionX;
    enemy.y =offsetY-32+ player.y + playerDirectionY;


}}}

 



        if(enemy.type=='duck'){
        for (let block of renderedBlocks) {
          if ( block.type !== 'water') {
let dx = (enemy.x + enemy.width / 2) - offsetX - (block.x + blockSize / 2);
let dy = (enemy.y + enemy.height / 2) - offsetY - (block.y + blockSize / 2);
let distanceToBlock = Math.sqrt(dx * dx + dy * dy);

if (distanceToBlock < collisionRadius) {
collisionDetected = true;} if (distanceToBlock < collisionRadius-5) {
return false; break;}
              
          }}
}else {}
 
 

 
        if(enemy.type=='bat'||enemy.type=='bat1'||enemy.type=='greenslime'||enemy.type=='blueslime'||enemy.type=='pinkslime'||enemy.type=='wasp'||enemy.type=='wasp1'||enemy.type=='bunny'|| enemy.type=="skellybones"  ){
        for (let block of renderedBlocks) {
          if (block.type === 'rock' || block.type === 'tree0' || block.type === 'birch0' || block.type === 'yew0' || block.type === 'pine0' || block.type === 'stone_wall' || block.type === 'log_wall'|| block.type === 'log' || block.type === 'brickwall'|| block.type === 'gypsumblock'|| block.type === 'planks'|| block.type === 'cave_wall' ||block.type === 'rubyblock'||block.type === 'sapphireblock'||block.type === 'emeraldblock'||block.type === 'voidblock'||block.type === 'housegrass'||block.type === 'abyssblock' ||block.type === 'fence' || block.type === 'hellwall' ||block.type === 'hellwall2'|| block.type === 'basalt' ||block.type === 'granite' || block.type === 'basalt' ) {
let dx = (enemy.x + enemy.width / 2) - offsetX - (block.x + blockSize / 2);
let dy = (enemy.y + enemy.height / 2) - offsetY - (block.y + blockSize / 2);
let distanceToBlock = Math.sqrt(dx * dx + dy * dy);
if (distanceToBlock < collisionRadius) {
collisionDetected = true;break;}else if(distanceToBlock<collisionRadius-3){
    return false;
}
              
          }
            
        }
}else {
for (let block of renderedBlocks) {
  if (block.type !== 'water' ) {
    let dx = (enemy.x + enemy.width / 2) - offsetX - (block.x + blockSize / 2);
    let dy = (enemy.y + enemy.height / 2) - offsetY - (block.y + blockSize / 2);
    let distanceToBlock = Math.sqrt(dx * dx + dy * dy);
if (distanceToBlock < collisionRadius) {collisionDetected2 = true; break;}}}}
var collisionwithwater1 = false;

if (enemy.type == "bunny"|| enemy.type == "pinkslime" ||enemy.type == "greenslime" ||enemy.type == "blueslime"||enemy.type == "skellybones") {
for (let block of renderedBlocks) {
if (block.type == 'water' || block.type == 'water1') {
let dx = (enemy.x + enemy.width / 2) - offsetX - (block.x + blockSize / 2);
let dy = (enemy.y + enemy.height / 2) - offsetY - (block.y + blockSize / 2);
let distanceToBlock = Math.sqrt(dx * dx + dy * dy);
if (distanceToBlock < collisionRadius) {
let isCovered = renderedBlocks.some(otherBlock => 
otherBlock.x === block.x && otherBlock.y === block.y && otherBlock !== block  );
if (!isCovered) {
collisionwithwater1 = true; break;
}}}}}
if (collisionDetected && enemy.type !== 'shark' ) {
enemy.x = prevX;enemy.y = prevY;
} if (collisionDetected2 &&(enemy.type === 'shark') ) { return false;  } else if (collisionwithwater1 &&( enemy.type === 'bunny'||enemy.type === 'skellybones' ||enemy.type === 'pinkslime'||enemy.type === 'greenslime'|| enemy.type === 'blueslime')) { return false; }
/* Animacje !  LOL 😆 */
if(enemy.type=="voltary" ){
enemy.tickCount++;
if (enemy.tickCount >= 5) { 
enemy.animationFrame = (enemy.animationFrame + 1) ;
if(enemy.animationFrame>5){
enemy.animationFrame=0; }
enemy.tickCount = 0; }
isRaining=true; }  
if (enemy.type == "pinkslime"||enemy.type == "greenslime"||enemy.type == "blueslime") {
  enemy.tickCount++;
  if (enemy.tickCount >= 2) { 
    enemy.animationFrame = (enemy.animationFrame + 1); 
    if (enemy.animationFrame > 5) {
      enemy.animationFrame = 0
    }enemy.tickCount = 0;
} 
} else  if (enemy.type == "aquagod") {
  enemy.tickCount++;
  if (enemy.tickCount >= 5) { 
    enemy.animationFrame = (enemy.animationFrame + 1); 
    if (enemy.animationFrame > 5) {
      enemy.animationFrame = 0
    }enemy.tickCount = 0;
} isRaining = true
}else if (enemy.type == "flesh") { enemy.tickCount++;
if (enemy.tickCount >= 3) {
enemy.animationFrame = (enemy.animationFrame + 1);
if (enemy.animationFrame > 3) {enemy.animationFrame = 0; }enemy.tickCount = 0; 
}
}else if (enemy.type == "spikegod") {enemy.tickCount++;if (enemy.tickCount >= 5) {enemy.animationFrame = (enemy.animationFrame + 1) % 2; enemy.tickCount = 0; } isRaining = false
updateDayNightCycle();updateDayNightCycle();updateDayNightCycle();setTimeout(updateDayNightCycle,500);setTimeout(updateDayNightCycle,600);setTimeout(updateDayNightCycle,800);setTimeout(updateDayNightCycle,1000);setTimeout(updateDayNightCycle,1500); 
}else if (enemy.type == "2medusa") {
  enemy.tickCount++;
if (enemy.tickCount >= 5) { 
  enemy.animationFrame = (enemy.animationFrame + 1); //  
if (enemy.animationFrame > 5) {
enemy.animationFrame = 0
} enemy.tickCount = 0; }}else if(enemy.type=="ghost"){   enemy.tickCount++;
if (enemy.tickCount >= 20) { 
  enemy.animationFrame = (enemy.animationFrame + 1) % 2; // 
  enemy.tickCount = 0; 
}} else{  enemy.tickCount++;
if (enemy.tickCount >= 5) { 
  enemy.animationFrame = (enemy.animationFrame + 1) % 2; // 
  enemy.tickCount = 0; 
}}
return true; 
});
/*if(removedd==1){
  renderedEnemies = renderedEnemies.filter(e => e.type !== "trueuniversebody");
}*/

if(newEnemies.length>0){
renderedEnemies.push(...newEnemies);
}
if(yyte!==null){
  
  removeEntityById(yyte);
 yyte=null
}

}
  
  
  
   
    if( removebymagic==1){
      attackEnemyAtPosition(0,0)
    }




}


function checkIfHasEnemy(enemyType, minCount) {
    let count = renderedEnemies.filter(enemy => enemy.type === enemyType).length;
    return count >= minCount;
}

function drawEnemyHealthBar(enemy) {
  const healthBarWidth = 30; // Szerokość paska zdrowia
  const healthBarHeight = 4.5; // Wysokość paska zdrowia
  const healthRatio = enemy.hp / enemies[enemy.type].hp; // 
  const healthBarX = enemy.x - offsetX + (enemy.width / 2) - (healthBarWidth / 2);
  const healthBarY = enemy.y - offsetY - 10; 
//  ctx.globalAlpha = ;
  ctx.fillStyle = "#CC5500";
  ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
  ctx.fillStyle = "green";
  ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthRatio, healthBarHeight);
  ctx.globalAlpha =1;
}

 
function drawEnemies() {
    renderedEnemies.forEach(enemy => {
      
if(enemy.type=='bat' || enemy.type=='bat1' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['bat'] : enemyTextures['bat1']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if( enemy.type=='greenmagic' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['greenmagic1'] : enemyTextures['greenmagic2']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if( enemy.type=='butterflyred' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['butterflyred1'] : enemyTextures['butterflyred2']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if( enemy.type=='butterflyblue' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['butterflyblue1'] : enemyTextures['butterflyblue2']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if( enemy.type=='firefly' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['firefly1'] : enemyTextures['firefly2']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if( enemy.type=='butterflyyellow' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['butterflyyellow1'] : enemyTextures['butterflyyellow2']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}else if (enemy.type == 'magic') {const enemyTexture = enemyTextures['magic']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'godmagic') {const enemyTexture = enemyTextures['godmagic']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'aquablast') {const enemyTexture = enemyTextures['aquablast']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'universeblast') {const enemyTexture = enemyTextures['universeblast']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'universebulb') {const enemyTexture = enemyTextures['universebulb']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'trueprojectile') {const enemyTexture = enemyTextures['trueprojectile']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'ghost') {const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['ghost1'] : enemyTextures['ghost'];; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'hyperblast') {const enemyTexture = enemyTextures['hyperblast']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
}else if (enemy.type == 'boomerang') {const enemyTexture = enemyTextures['boomerang'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle2-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'arrow') {const enemyTexture = enemyTextures['arrow'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93.45);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'goodarrow') {const enemyTexture = enemyTextures['goodarrow'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93.45);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'powerfullarrow') {const enemyTexture = enemyTextures['powerfullarrow'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93.45);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'good_boomerang') {const enemyTexture = enemyTextures['good_boomerang'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle2-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'draco_boomerang') {const enemyTexture = enemyTextures['draco_boomerang'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle2-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'hell_boomerang') {const enemyTexture = enemyTextures['hell_boomerang'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle2-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'titanium_boomerang') {const enemyTexture = enemyTextures['titanium_boomerang'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle2-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }  
}else if (enemy.type == 'magicsharp') {const enemyTexture = enemyTextures['magicsharp']; if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);
    }
} if(enemy.type=='hellskull' || enemy.type=='hellskull1' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['hellskull1'] : enemyTextures['hellskull2']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if(enemy.type=='flesher1' || enemy.type=='flesher' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['flesher1'] : enemyTextures['flesher2']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if(enemy.type=='desertelemental' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['desertelemental2'] : enemyTextures['desertelemental1']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if(enemy.type=='soulcat' || enemy.type=='soulcat1' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['soulcat1'] : enemyTextures['soulcat2']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if(enemy.type=='frozenghost' || enemy.type=='frozenghost1' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['frozenghost2'] : enemyTextures['frozenghost1']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}if(enemy.type=='voidguardian' || enemy.type=='voidguardian1' ){ const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['voidguardian1'] : enemyTextures['voidguardian2']; drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.drawImage( enemyTexture, enemy.x - offsetX,  enemy.y - offsetY, enemy.width, enemy.height);}
}else if (enemy.type == 'trueuniversehead') {const enemyTexture = enemyTextures['trueuniversehead'];
    drawEnemyHealthBar(enemy);if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {ctx.save()
        ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
        ctx.rotate(enemy.angle - 89.8);
        ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore()
    }
} else if (enemy.type == 'trueuniversebody') {
    const enemyTexture = enemyTextures['trueuniversebody'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }
}else if (enemy.type == 'deepgodhead') {
    const enemyTexture = enemyTextures['deepgodhead'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); } drawEnemyHealthBar(enemy);
}else if (enemy.type == 'deepgodtorso') {
    const enemyTexture = enemyTextures['deepgodtorso'];
    if (enemyTexture.complete && enemyTexture.naturalWidth > 0) { ctx.save(); ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2); ctx.rotate(enemy.angle-93);ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
        ctx.restore(); }
}else if (enemy.type == 'abyssdevourerbody') {
  const enemyTexture = enemyTextures['abyssdevourerbody'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
}else if (enemy.type == 'abyssdevourerhead') {
  const enemyTexture = enemyTextures['abyssdevourerhead'];

  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
  drawEnemyHealthBar(enemy);
}else if (enemy.type == 'desertscourgehead') {
  const enemyTexture = enemyTextures['desertscourgehead'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
  drawEnemyHealthBar(enemy);
}else if (enemy.type == 'desertscourgebody') {
  const enemyTexture = enemyTextures['desertscourgebody'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
}else if (enemy.type == 'hellscourgebody') {
  const enemyTexture = enemyTextures['hellscourgebody'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }

}else if (enemy.type == 'crimsonprojectile') {
  const enemyTexture = enemyTextures['crimsonprojectile'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
}else if (enemy.type == 'hellscourgehead') {
  const enemyTexture = enemyTextures['hellscourgehead'];
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.save()
    ctx.translate(enemy.x - offsetX + enemy.width / 2, enemy.y - offsetY + enemy.height / 2);
    ctx.rotate(enemy.angle - 93);
    ctx.drawImage(enemyTexture, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
    ctx.restore()
  }
  drawEnemyHealthBar(enemy);
}
else if(enemy.type=='pinkslime'){ var enemyTexture=null; if(enemy.animationFrame==1){ enemyTexture=enemyTextures['pinkslime1']; }else if(enemy.animationFrame==0){ enemyTexture=enemyTextures['pinkslime2']; }else if (enemy.animationFrame == 3) { enemyTexture = enemyTextures['pinkslime3']; }else{ enemyTexture = enemyTextures['pinkslime3']; }
drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
ctx.drawImage(enemyTexture, enemy.x - offsetX, enemy.y - offsetY, enemy.width, enemy.height);}
}else if(enemy.type=='blueslime'){ var enemyTexture=null; if(enemy.animationFrame==1){ enemyTexture=enemyTextures['blueslime1']; }else if(enemy.animationFrame==0){ enemyTexture=enemyTextures['blueslime2']; }else if (enemy.animationFrame == 3) { enemyTexture = enemyTextures['blueslime3']; }else{ enemyTexture = enemyTextures['blueslime3']; }
drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
ctx.drawImage(enemyTexture, enemy.x - offsetX, enemy.y - offsetY, enemy.width, enemy.height);}
} else if(enemy.type=='greenslime'){ var enemyTexture=null; if(enemy.animationFrame==1){ enemyTexture=enemyTextures['greenslime1']; }else if(enemy.animationFrame==0){ enemyTexture=enemyTextures['greenslime2']; }else if (enemy.animationFrame == 3) { enemyTexture = enemyTextures['greenslime3']; }else{ enemyTexture = enemyTextures['greenslime3']; }
drawEnemyHealthBar(enemy); if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
ctx.drawImage(enemyTexture, enemy.x - offsetX, enemy.y - offsetY, enemy.width, enemy.height);}
} else if(enemy.type=='wasp'||enemy.type=='wasp1'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['wasp'] : enemyTextures['wasp1'];
        drawEnemyHealthBar(enemy);
         
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='skull'||enemy.type=='skull1'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['skull'] : enemyTextures['skull1'];
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='floatingeye'||enemy.type=='floatingeye1'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['floatingeye1'] : enemyTextures['floatingeye2'];
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='spary'||enemy.type=='spary2'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['spary'] : enemyTextures['spary2'];
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='darkeye'||enemy.type=='darkeye'){
        const enemyTexture =   enemyTextures['darkeye'] ;
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='spikegod'||enemy.type=='spikegod1'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['spikegod'] : enemyTextures['spikegod1'];
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='giantbat'){
        const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['giantbat'] : enemyTextures['giantbat1'];
        drawEnemyHealthBar(enemy);
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='voltary'||enemy.type=='voltary2'){
          var enemyTexture=null
          if(enemy.animationFrame==1){
            enemyTexture=enemyTextures['voltary']
          }else if(enemy.animationFrame==0){
            enemyTexture=enemyTextures['voltary2']
          }else if (enemy.animationFrame == 3) {
  enemyTexture = enemyTextures['voltary3']
}else{
  enemyTexture = enemyTextures['voltary3']
}
      //  = enemy.animationFrame === 0 ? enemyTextures['voltary'] : enemyTextures['voltary2'];
        drawEnemyHealthBar(enemy);
      //  showTextInCanvas(enemy.animationFrame)
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='aquagod'||enemy.type=='aquagod2'){
          var enemyTexture=null
          if(enemy.animationFrame==1){
            enemyTexture=enemyTextures['aquagod1']
          }else if(enemy.animationFrame==0){
            enemyTexture=enemyTextures['aquagod2']
          }else if (enemy.animationFrame == 3) {
  enemyTexture = enemyTextures['aquagod3']
}else{
  enemyTexture = enemyTextures['aquagod3']
}
      //  = enemy.animationFrame === 0 ? enemyTextures['voltary'] : enemyTextures['voltary2'];
        drawEnemyHealthBar(enemy);
      //  showTextInCanvas(enemy.animationFrame)
        if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
            // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
            ctx.drawImage(
                enemyTexture, 
                enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
                enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
                enemy.width, 
                enemy.height
            );
        }}else if(enemy.type=='insaneuniversegod'||enemy.type=='insaneuniversegod1'){
var enemyTexture=null
if(enemy.animationFrame==1){
enemyTexture=enemyTextures['insaneuniversegod1']
}else if(enemy.animationFrame==0){
enemyTexture=enemyTextures['insaneuniversegod2']
}else if (enemy.animationFrame == 3) {
enemyTexture = enemyTextures['insaneuniversegod1']
}else{
enemyTexture = enemyTextures['insaneuniversegod2']
}
// = enemy.animationFrame === 0 ? enemyTextures['voltary'] : enemyTextures['voltary2'];
drawEnemyHealthBar(enemy);
// showTextInCanvas(enemy.animationFrame)
if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
// Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
ctx.drawImage(
enemyTexture,
enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
enemy.width,
enemy.height
);
}}else if(enemy.type=='flesh'||enemy.type=='flesh1'){
var enemyTexture=null
if(enemy.animationFrame==1){
enemyTexture=enemyTextures['flesh1']
}else if(enemy.animationFrame==0){
enemyTexture=enemyTextures['flesh2']
}else if (enemy.animationFrame == 3) {
enemyTexture = enemyTextures['flesh3']
}else{
enemyTexture = enemyTextures['flesh3']
}
// = enemy.animationFrame === 0 ? enemyTextures['voltary'] : enemyTextures['voltary2'];
drawEnemyHealthBar(enemy);
// showTextInCanvas(enemy.animationFrame)
if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
// Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
ctx.drawImage(
enemyTexture,
enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
enemy.width,
enemy.height
);
}}else if(enemy.type=='2medusa'){
var enemyTexture=null
if(enemy.animationFrame==1){
enemyTexture=enemyTextures['2medusa1']
}else if(enemy.animationFrame==0){
enemyTexture=enemyTextures['2medusa2']
}else if (enemy.animationFrame == 3) {
enemyTexture = enemyTextures['2medusa3']
}else{
enemyTexture = enemyTextures['2medusa1']
}
// = enemy.animationFrame === 0 ? enemyTextures['voltary'] : enemyTextures['voltary2'];
drawEnemyHealthBar(enemy);
// showTextInCanvas(enemy.animationFrame)
if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
// Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
ctx.drawImage(
enemyTexture,
enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
enemy.width,
enemy.height
);
}}else if (enemy.type == "shark") {
  const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['shark'] : enemyTextures['shark1'];
  drawEnemyHealthBar(enemy);
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
    ctx.drawImage(
      enemyTexture,
      enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
      enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
      enemy.width,
      enemy.height
    );
  }
}else if (enemy.type == "1medusa") {
  const enemyTexture = enemy.animationFrame === 0 ? enemyTextures['1medusa1'] : enemyTextures['1medusa2'];
  drawEnemyHealthBar(enemy);
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    // Rysujemy przeciwnika w odniesieniu do offsetX i offsetY (przewijanie świata)
    ctx.drawImage(
      enemyTexture,
      enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
      enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
      enemy.width,
      enemy.height
    );
  }
}  else if (enemy.type == "raven") {
  let enemyTexture;drawEnemyHealthBar(enemy); if (enemy.direction == 0) { enemyTexture = enemy.animationFrame === 0 ? enemyTextures['raven-up'] : enemyTextures['raven-up2'];} if (enemy.direction == 1) {  enemyTexture = enemy.animationFrame === 0 ? enemyTextures['raven-down'] : enemyTextures['raven-down2'];}
  if (enemy.direction == 2) {  enemyTexture = enemy.animationFrame === 0 ? enemyTextures['raven-left'] : enemyTextures['raven-left2'];  }if (enemy.direction == 3) { enemyTexture = enemy.animationFrame === 0 ? enemyTextures['raven-right'] : enemyTextures['raven-right2'];  }  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.drawImage(
      enemyTexture,
      enemy.x - offsetX,
      enemy.y - offsetY,
      enemy.width,
      enemy.height
    );
  }
}else if (enemy.type == "duck") {
  let enemyTexture;  if (enemy.direction == 0) { enemyTexture = enemy.animationFrame === 0 ? enemyTextures['duckup1'] : enemyTextures["duckup2"];} if (enemy.direction == 1) {  enemyTexture = enemy.animationFrame === 0 ? enemyTextures['duckdown1'] : enemyTextures['duckdown2'];}
  if (enemy.direction == 2) {  enemyTexture = enemy.animationFrame === 0 ? enemyTextures['duckleft1'] : enemyTextures['duckleft2'];  }if (enemy.direction == 3) { enemyTexture = enemy.animationFrame === 0 ? enemyTextures['duckright1'] : enemyTextures['duckright2'];  }  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.drawImage(
      enemyTexture,
      enemy.x - offsetX,
      enemy.y - offsetY,
      enemy.width,
      enemy.height
    );
  }
}
else if (enemy.type == "skellybones") {
  let enemyTexture;
  drawEnemyHealthBar(enemy);
  if (enemy.direction == 0) {
    enemyTexture = enemy.animationFrame === 0 ? enemyTextures['skellybonesup1'] : enemyTextures['skellybonesup2'];}
  if (enemy.direction == 1) {
    enemyTexture = enemy.animationFrame === 0 ? enemyTextures['skellybonesdown1'] : enemyTextures['skellybonesdown2'];}
  if (enemy.direction == 2) {
    enemyTexture = enemy.animationFrame === 0 ? enemyTextures['skellybonesleft1'] : enemyTextures['skellybonesleft2'];}
  if (enemy.direction == 3) {
    enemyTexture = enemy.animationFrame === 0 ? enemyTextures['skellybonesright1'] : enemyTextures['skellybonesright2'];}
  if (enemyTexture.complete && enemyTexture.naturalWidth > 0) {
    ctx.drawImage(
      enemyTexture,
      enemy.x - offsetX,
      enemy.y - offsetY,
      enemy.width,
      enemy.height
    );
  }
}else if(enemy.type=="bunny"){
  drawEnemyHealthBar(enemy);
        switch (enemy.direction) {
            case 0: // up
                enemyTexture = enemyTextures['bunn-up'];
                break;
            case 1: // down
                enemyTexture = enemyTextures['bunn-down'];
                break;
            case 2: // left
                enemyTexture = enemyTextures['bunn-left'];
                break;
            case 3: // right
                enemyTexture = enemyTextures['bunn-right'];
                break;
        }
          ctx.drawImage(
  enemyTexture,
  enemy.x - offsetX, // Przesunięcie pozycji X o offsetX
  enemy.y - offsetY, // Przesunięcie pozycji Y o offsetY
  enemy.width,
  enemy.height
);
        }

        
        
        
    });
    RENDEREDENEMIES2 = renderedEnemies
}


function growTreeInVisibleChunks() {
    const radius = 95;
    const minX = Math.floor((offsetX ) / blockSize)-5;
    const maxX = Math.floor((offsetX ) / blockSize)+radius;
    const minY = Math.floor((offsetY ) / blockSize)-5;
    const maxY = Math.floor((offsetY ) / blockSize)+radius;

    // Iterujemy przez chunki w zasięgu widoczności
    for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
            const chunkKey = `${x},${y}`;
            const chunkBlocks = chunks[chunkKey];

            // Sprawdzamy, czy chunk istnieje
            if (!chunkBlocks) continue;

            // Sprawdzamy każdy blok w chunku
            chunkBlocks.forEach((block) => {
          
 if (Math.random() < 0.095 && Math.random() < 0.075) {
        if (block.type === 'lit_furnace') {
          // Obliczamy globalne współrzędne bloku
          const globalX = block.x + 3 + (parseInt(chunkKey.split(',')[0]) * blockSize);
          const globalY = block.y + 3 + (parseInt(chunkKey.split(',')[1]) * blockSize);

          // Usuwamy sadzonkę
          removeBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'lit_furnace');
          buildBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'furnace'); 
          
        }}else if (Math.random() < 0.095 && Math.random() < 0.075) {
        if (block.type === 'lit_kiln') {
          // Obliczamy globalne współrzędne bloku
          const globalX = block.x + 3 + (parseInt(chunkKey.split(',')[0]) * blockSize);
          const globalY = block.y + 3 + (parseInt(chunkKey.split(',')[1]) * blockSize);

          // Usuwamy sadzonkę
          removeBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'lit_kiln');
          buildBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'kiln'); 
          
        }}else if (Math.random() < 0.075 && Math.random() < 0.075) {
        if (block.type === 'campfire') {
          // Obliczamy globalne współrzędne bloku
          const globalX = block.x + 3 + (parseInt(chunkKey.split(',')[0]) * blockSize);
          const globalY = block.y + 3 + (parseInt(chunkKey.split(',')[1]) * blockSize);

          // Usuwamy sadzonkę
          removeBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'campfire');
          buildBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'extinguished_campfire'); 
          
        }}else if (Math.random() < 0.075 && Math.random() < 0.075) {
        if (block.type === 'wildcarrot') {
          // Obliczamy globalne współrzędne bloku
          const globalX = block.x + 3 + (parseInt(chunkKey.split(',')[0]) * blockSize);
          const globalY = block.y + 3 + (parseInt(chunkKey.split(',')[1]) * blockSize);

          // Usuwamy sadzonkę
          removeBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'wildcarrot');
          buildBlockAtPosition(Math.floor(((globalX - offsetX) / 32) * 32), Math.floor(((globalY - offsetY) / 32) * 32), 'carrot2'); 
          
        }}
       if(Math.random()<0.05&&Math.random()<0.09){
            if (block.type === 'hellsapling') {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'hellsapling');
                let treeStructure = [
                    { x: 0, y: 0, type: "helltree0" },    
                    { x: 0, y: -32, type: "helltree1" },
                    { x: 0, y: -64, type: "helltree2" }, 
                ];
                if (!chunks[chunkKey]) {
                    chunks[chunkKey] = [];
                }
                treeStructure.forEach((treeBlock) => {
                    chunks[chunkKey].push({
                        x: block.x + treeBlock.x,  
                        y: block.y + treeBlock.y,  
                        type: treeBlock.type       
                    });
                });
            }}
if(Math.random()<0.05&&Math.random()<0.05){
            if (block.type === 'abysssapling') {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'abysssapling');
                let treeStructure = [
                    { x: 0, y: 0, type: "abysstree0" },    
                    { x: 0, y: -32, type: "abysstree1" },
                    { x: 0, y: -64, type: "abysstree2" }, 
                ];
                if (!chunks[chunkKey]) {
                    chunks[chunkKey] = [];
                }
                treeStructure.forEach((treeBlock) => {
                    chunks[chunkKey].push({
                        x: block.x + treeBlock.x,  
                        y: block.y + treeBlock.y,  
                        type: treeBlock.type       
                    });
                });
            }}
            if(Math.random()<0.05&&Math.random()<0.09){
            if (block.type === 'palmsapling') {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'palmsapling');
                let treeStructure = [
                    { x: 0, y: 0, type: "palm1" },    
                    { x: 0, y: -32, type: "palm3" },
                    { x: 0, y: -64, type: "palm2" }, 
                ];
                if (!chunks[chunkKey]) {
                    chunks[chunkKey] = [];
                }
                treeStructure.forEach((treeBlock) => {
                    chunks[chunkKey].push({
                        x: block.x + treeBlock.x,  
                        y: block.y + treeBlock.y,  
                        type: treeBlock.type       
                    });
                });
            }}
 
          if(Math.random()<0.05&&Math.random()<0.09){
            if (block.type === 'sapling') {
                // Obliczamy globalne współrzędne bloku
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);

                // Usuwamy sadzonkę
                removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'sapling');
                
                // Struktura drzewa, wszystkie bloki będą w jednym chunku
                let treeStructure = [
                    { x: 0, y: 0, type: "pine0" },   // Pień drzewa
                    { x: 0, y: -32, type: "pine1" },  // Drugi blok pnia
                    { x: 0, y: -64, type: "pine2" },  // Trzeci blok (liście/czubek)
                    { x: 0, y: -96, type: "pine2" },  // Czwarty blok (liście/czubek)
                ];
if(checkBlockAtPosition(globalX-offsetX,globalY -offsetY,"snowgrass")||checkBlockAtPosition(globalX-offsetX ,globalY -offsetY,"snowgrass2")){
   treeStructure = [
    { x: 0, y: 0, type: "snowpine1" }, // Pień drzewa
    { x: 0, y: -32, type: "snowpine2" }, // Drugi blok pnia
    { x: 0, y: -64, type: "snowpine3" }, // Trzeci blok (liście/czubek)
    { x: 0, y: -96, type: "snowpine3" }, // Czwarty blok (liście/czubek)
];
}else{
                if (Math.random() < 0.43) {
                  treeStructure = [
                    { x: 0, y: 0, type: "tree0" }, // Pień drzewa
                    { x: 0, y: -32, type: "tree1" }, // Drugi blok pnia
                    { x: 0, y: -64, type: "tree2" },
                ];
                }        else if (Math.random() < 0.3) {
                  treeStructure = [
                    { x: 0, y: 0, type: "birch0" }, // Pień drzewa
                    { x: 0, y: -32, type: "birch1" }, // Drugi blok pnia
                    { x: 0, y: -64, type: "birch2" },
                ];
                }else{}
}
                // Sprawdzamy, czy chunk istnieje, jeśli nie - tworzymy
                if (!chunks[chunkKey]) {
                    chunks[chunkKey] = [];
                }

                // Dodajemy całą strukturę drzewa jako jeden wpis do chunku
                treeStructure.forEach((treeBlock) => {
                    chunks[chunkKey].push({
                        x: block.x + treeBlock.x, // lokalna pozycja w chunku
                        y: block.y + treeBlock.y, // lokalna pozycja w chunku
                        type: treeBlock.type      // typ bloku drzewa
                    });
                });

            //    console.log(`Sadzonka urosła w drzewo typu 'pine' na pozycji (${globalX}, ${globalY}) w chunku ${chunkKey}`);
            }}else if(block.type === 'hook'){
            
const hasTallgrass = chunkBlocks.some(b => b.type === 'water'||b.type === 'water1');
//showTextInCanvas(hasTallgrass)
if (hasTallgrass) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                if (Math.random()<0.5&&Math.random()<0.05) {
                  showTextInCanvas(" something appeared " )
removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'hook');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'catchhook');


                }
            }else{
              showTextInCanvas("trying to catch fish on grass doesn't work ")
            }
              
            }else if(block.type === 'catchhook'){
            if (Math.random()<0.5&&Math.random()<0.5&&Math.random()<0.08) {
const hasTallgrass = chunkBlocks.some(b => b.type === 'water'||b.type === 'water1');

if (hasTallgrass) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'catchhook');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'hook');
               showTextInCanvas(" ohh no fish run away!")
            }}}else if(block.type === 'empty_black_elderberry'){
            if (Math.random()<0.2&&Math.random()<0.10) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition(globalX - offsetX, globalY - offsetY, 'empty_black_elderberry');
removeBlockAtPosition(globalX - offsetX, globalY -32 - offsetY, 'empty_black_elderberry2');
removeBlockAtPosition(globalX - offsetX, globalY -32 - offsetY, 'empty_black_elderberry');
removeBlockAtPosition(globalX - offsetX, globalY-32 - offsetY, 'empty_black_elderberry');
 
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'black_elderberry');

//buildBlockAtPosition(globalX - offsetX,( globalY - offsetY)-32 ,'black_elderberry2');


chunks[chunkKey2].push({ 
            x: 0, 
            y: -32, 
            type: "black_elderberry2" 
        });
        
               
            }}}else if(block.type === 'palm1'){
if (Math.random()<0.05&&Math.random()<0.05) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
             let   x =globalX - offsetX
             let   y =globalY - offsetY
deleteFromChunk(x, y, ["palm1", "palm2","palm3"]);
deleteFromChunk(x, y, ["palm12", "coconutpalm", "palm32"]);
removeBlockAtPosition(x, y , "palm1");
removeBlockAtPosition(x, y , "palm12");
removeBlockAtPosition(x, y - (32), "palm3");
removeBlockAtPosition(x, y - (32 * 2), "palm2");
removeBlockAtPosition(x, y - (32), "palm32");
removeBlockAtPosition(x, y - (32 * 2), "coconutpalm");

                let treeStructure = [
                    { x: 0, y: 0, type: "palm12" },
                    { x: 0, y: -32, type: "palm32" },
                    { x: 0, y: -64, type: "coconutpalm" },
                ];
                if (!chunks[chunkKey]) {
                    chunks[chunkKey] = [];
                }
                treeStructure.forEach((treeBlock) => {
                    chunks[chunkKey].push({
                        x: block.x + treeBlock.x,
                        y: block.y + treeBlock.y,
                        type: treeBlock.type
                    });
                });


               
            }}}else if(block.type === 'mycelium'){
              //if (Math.random()<0.04&&Math.random()<0.05) {
            if (Math.random()<0.04&&Math.random()<0.05) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'mycelium');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'kite1');
            }}}else if(block.type === 'emptyblackberry'){
            if (Math.random()<0.05&&Math.random()<0.05) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'emptyblackberry');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'blackberry');
            }}}else if(block.type === 'cactusempty'){
            if (Math.random()<0.05&&Math.random()<0.04) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'cactusempty');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'cactus');
            }}}else if(block.type === 'briarempty'){
            if (Math.random()<0.05&&Math.random()<0.04) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'briarempty');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'briar');
            }}}else if(block.type === 'thistleseeds'){
            if (Math.random()<0.03&&Math.random()<0.05) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'thistleseeds');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'thistle1');
            }}}else if(block.type === 'dandelion'){
            if (Math.random()<0.02&&Math.random()<0.03) {
 const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'dandelion');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'dandelion2');
              
            }}else if(block.type === 'dandelionseeds'){
            if (Math.random()<0.02&&Math.random()<0.05) {

              const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
              const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
              var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
              removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'dandelionseeds');
              buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'dandelion2');
              
            }}else if(block.type === 'rye_seeds'){
            if (Math.random()<0.03&&Math.random()<0.05) {
if (true) {
                const globalX = block.x + (parseInt(chunkKey.split(',')[0]) * blockSize);
                const globalY = block.y + (parseInt(chunkKey.split(',')[1]) * blockSize);
                var chunkKey2 = `${Math.floor((globalX+3)/32)},${Math.floor((globalY+3)/32)}`;
removeBlockAtPosition2(globalX - offsetX, globalY - offsetY, 'rye_seeds');
buildBlockAtPosition(globalX - offsetX, globalY - offsetY, 'rye1');
            }}}
        });
        }
    }
}


var by5=0

function isStayOn(type) {
    const collisionRadius = 32; // Promień kolizji w pikselach

    // Oblicz środek gracza
    const playerCenterX = player.x + player.width / 2;
    const playerCenterY = player.y + player.height; // Zakładamy, że stoi na dolnej krawędzi

    // Znajdź blok w promieniu kolizji pod graczem
    const blockBelow = renderedBlocks.find(block => {
        const blockCenterX = block.x + blockSize / 2;
        const blockCenterY = block.y + blockSize / 2;

        // Oblicz odległość między środkiem gracza a środkiem bloku
        const distance = Math.sqrt(
            (playerCenterX - blockCenterX) ** 2 + (playerCenterY - blockCenterY) ** 2
        );

        // Sprawdź, czy odległość jest mniejsza niż promień i typ bloku pasuje
        return distance <= collisionRadius && block.type === type;
    });

    // Zwróć true, jeśli blok został znaleziony, w przeciwnym razie false
    return blockBelow;
}
function isStayOn2(type) {
    const collisionRadius = 32+ player.width /1.2; // Promień kolizji w pikselach

    // Oblicz środek gracza
    const playerCenterX = player.x + player.width / 2;
    const playerCenterY = player.y + player.height; // Zakładamy, że stoi na dolnej krawędzi

    // Znajdź blok w promieniu kolizji pod graczem
    const blockBelow = renderedBlocks.find(block => {
        const blockCenterX = block.x + blockSize / 2;
        const blockCenterY = block.y + blockSize / 2;

        // Oblicz odległość między środkiem gracza a środkiem bloku
        const distance = Math.sqrt(
            (playerCenterX - blockCenterX) ** 2 + (playerCenterY - blockCenterY) ** 2
        );

        // Sprawdź, czy odległość jest mniejsza niż promień i typ bloku pasuje
        return distance <= collisionRadius && block.type === type;
    });

    // Zwróć true, jeśli blok został znaleziony, w przeciwnym razie false
    return blockBelow;
}


// Parametry deszczu
let isRaining = false;
let rainTextureIndex = 0;
const rainTextures = [
    "./rain1.png", "./rain2.png", "./rain3.png", "./rain4.png"
];
const snowtextures = [
    "./snow1.png", "./snow2.png", "./snow3.png", "./snow4.png","./snow5.png","./snow6.png","./snow7.png"
];
const sandstormtextures = [
    "./sandstorm1.png", "./sandstorm2.png", "./sandstorm3.png"
];
const leavestextures = [
    "./leaves1.png", "./leaves2.png", "./leaves3.png","./leaves4.png", "./leaves5.png"
];
const hellparticles = [
    "./ashes1.png", "./ashes2.png", "./ashes3.png","./ashes4.png", "./ashes5.png", "./ashes6.png","./ashes7.png", "./ashes8.png"
];
const rainTextureChangeInterval = 2; // co ile klatek zmienia się tekstura deszczu

// Wczytaj tekstury deszczu
const loadedRainTextures = rainTextures.map(src => {
    const img = new Image();
    img.src = src;
    return img;
});
const loadedleavestextures = leavestextures.map(src => {
  const img = new Image();
  img.src = src;
  return img;
});
const loadedsnowTextures = snowtextures.map(src => {
  const img = new Image();
  img.src = src;
  return img;
});
const loadedsandstormTxt = sandstormtextures.map(src => {
  const img = new Image();
  img.src = src;
  return img;
});
const loadedashesTxt = hellparticles.map(src => {
  const img = new Image();
  img.src = src;
  return img;
});
// Funkcja rysowania deszczu na blokach
let leafChangeCounter = 0; // licznik ticków do zmiany liści
const changeInterval = 3000; // liczba ticków przed zmianą liści
// 1. Generacja szumów
let anableleaves=1
function drawRainEffectOnBlocks() {
  if(Math.random()<0.0015 && anableleaves==1){
    anableleaves=0
  }else if(anableleaves==0 && Math.random()<0.003){
    anableleaves=1
  }
  if(anableleaves==1&& Math.random()<0.015){
    playwindsound()
  }
  if (generateCave !== 1 && isinhouse !== 1 && inhell !== 1 && (isStayOn("grass") || isStayOn("grasslayer")|| isStayOn("forestgrass")) && options.fancygraphic === 1 && anableleaves==1 && !isRaining) {
    ctx.globalAlpha = 0.2;

    // Zwiększ licznik ticków
  if (by5 % rainTextureChangeInterval === 0) {
    rainTextureIndex = (rainTextureIndex + 1) % loadedleavestextures.length;
  }
  if (rainTextureIndex >= loadedleavestextures.length) {
    rainTextureIndex = 0;
  }
  const currentRainTexture = loadedleavestextures[rainTextureIndex]
  let scale = 1.0
    const rainTextureSize = blockSize*scale; 
    const scaled = 1.6; // Dostosowane na podstawie logiki

    chunkPositions.forEach(chunk => {
      const adjustedX = Math.round(chunk.x) * scaled;
      const adjustedY = Math.round(chunk.y) * scaled;

      for (let x = adjustedX; x < adjustedX + chunk.width * scaled; x += rainTextureSize) {
        for (let y = adjustedY; y < adjustedY + chunk.height * scaled; y += rainTextureSize) {
          if(Math.random()<0.7){
            ctx.drawImage(currentRainTexture, x*scaled, y*scaled, rainTextureSize, rainTextureSize);
          }
        }
      }
    });

    ctx.globalAlpha = 1.0;
  }
else  if (generateCave !== 1 && isinhouse !== 1 && inhell !== 1 && (isStayOn("snowgrass") ||isStayOn("snowgrass2") )) {
  ctx.globalAlpha = 0.6;
  if (by5 % rainTextureChangeInterval === 0) {
    rainTextureIndex = (rainTextureIndex + 1) % loadedsnowTextures.length;
  }
  if (rainTextureIndex >= loadedsnowTextures.length) {
    rainTextureIndex = 0;
  }
  const currentRainTexture = loadedsnowTextures[rainTextureIndex];
  let scaled = 1.2
  let scale = 1.2
  const rainTextureSize = blockSize * scale;
  const rainSize = blockSize * scaled;
  chunkPositions.forEach(chunk => {
    const adjustedX = Math.round(chunk.x) * scaled;
    const adjustedY = Math.round(chunk.y) * scaled;
    for (let x = adjustedX; x < adjustedX + chunk.width * scaled; x += rainSize) {
      for (let y = adjustedY; y < adjustedY + chunk.height * scaled; y += rainSize) {
        ctx.drawImage(currentRainTexture, x, y, rainTextureSize, rainTextureSize);
      }
    }
  });
  ctx.globalAlpha = 1.0;
}else if (generateCave !== 1 && isinhouse !== 1 && inhell == 1 ) {
  ctx.globalAlpha = 0.6;
  if (by5 % rainTextureChangeInterval === 0) {
    rainTextureIndex = (rainTextureIndex + 1) % loadedashesTxt.length;
  }
  if (rainTextureIndex >= loadedashesTxt.length) {
    rainTextureIndex = 0;
  }
  const currentRainTexture = loadedashesTxt[rainTextureIndex];
  let scaled = 1
  let scale = 1
  const rainTextureSize = blockSize * scale;
  const rainSize = blockSize * scaled;
  chunkPositions.forEach(chunk => {
    const adjustedX = Math.round(chunk.x) * scaled;
    const adjustedY = Math.round(chunk.y) * scaled;
    for (let x = adjustedX; x < adjustedX + chunk.width * scaled; x += rainSize) {
      for (let y = adjustedY; y < adjustedY + chunk.height * scaled; y += rainSize) {
        ctx.drawImage(currentRainTexture, x, y, rainTextureSize, rainTextureSize);
      }
    }
  });
  ctx.globalAlpha = 1.0;
}else if (generateCave !== 1 && inhell!==1&& isinhouse !== 1 && isStayOn("desertsand")) {
  ctx.globalAlpha = 0.8;
  if (by5 % (rainTextureChangeInterval+2) === 0) {
    rainTextureIndex = (rainTextureIndex + 1) % loadedsandstormTxt.length;
  }
if (rainTextureIndex >= loadedsandstormTxt.length) {
    rainTextureIndex = 0;
}

  const currentRainTexture = loadedsandstormTxt[rainTextureIndex];
  let scaled = 1.2
  let scale = 1.2
  const rainTextureSize = blockSize * scale;
  const rainSize = blockSize * scaled;
  chunkPositions.forEach(chunk => {
    const adjustedX = Math.round(chunk.x) * scaled;
    const adjustedY = Math.round(chunk.y) * scaled;
    for (let x = adjustedX; x < adjustedX + chunk.width * scaled; x += rainSize) {
      for (let y = adjustedY; y < adjustedY + chunk.height * scaled; y += rainSize) {
        ctx.drawImage(currentRainTexture, x, y, rainTextureSize, rainTextureSize);
      }
    }
  });
  ctx.globalAlpha = 1.0;
} else if (isRaining && generateCave!==1&& inhell!==1&& isinhouse!==1 ) {
      
      playRain()
        // Ustawienie przezroczystości deszczu
        ctx.globalAlpha = 0.4; // 0.5 oznacza 50% przezroczystości, można dostosować

        // Zwiększ indeks tekstury co kilka klatek, by animacja była płynna
        if (by5 % rainTextureChangeInterval === 0) {
            rainTextureIndex = (rainTextureIndex + 1) % loadedRainTextures.length;
        }
if (rainTextureIndex >= loadedRainTextures.length) {
    rainTextureIndex = 0;
}

        // Pobierz aktualną teksturę deszczu
        const currentRainTexture = loadedRainTextures[rainTextureIndex];

        // Ustal rozmiar tekstury deszczu, aby odpowiadał 2.5 bloku
        let scaled=1.6
        let scale=1.3
        const rainTextureSize = blockSize * scale;
const rainSize = blockSize * scaled;
        // Rysowanie deszczu co 2.5 bloku
        chunkPositions.forEach(chunk => {
            const adjustedX = Math.round(chunk.x)*scaled;
            const adjustedY = Math.round(chunk.y)*scaled;

            // Oblicz współrzędne siatki co 2.5 bloku
            for (let x = adjustedX; x < adjustedX + chunk.width*scaled; x += rainSize) {
                for (let y = adjustedY; y < adjustedY + chunk.height*scaled; y += rainSize) {
                    // Rysowanie tekstury deszczu na siatce
                    ctx.drawImage(currentRainTexture, x, y, rainTextureSize, rainTextureSize);
                }
            }
        });

        // Przywrócenie przezroczystości do pełnej, aby inne elementy nie były przezroczyste
        ctx.globalAlpha = 1.0;
    }else{
      
stopRain()
    }
}

// Parametry błyskawic
let lightningActive = false;
let lightningDuration = 100; // czas trwania błyskawicy w milisekundach
let lightningCooldown = 5000; // czas między błyskawicami w milisekundach
let lastLightningTime = 0; // czas ostatniej błyskawicy
let lightningOpacity = 0; // przezroczystość błyskawicy
let lightningFadeDuration = 100; // czas fade in/out w milisekundach
let lightningState = 'fadeOut'; // aktualny stan błyskawicy ('fadeIn' lub 'fadeOut')
let lightningState2 = 'fadeOut';
let lightningActive2 = false;
let lightningDuration2 = 3000;
let lightningCooldown2 = 5000;
let lightningOpacity2 = 0;
let lightningFadeDuration2 = 2200;
let lightningTimer2 = 0;

function drawLightning2() {
  if (lightningActive2) {
    ctx.fillStyle = `rgba(255, 255, 255, ${lightningOpacity2})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function startLightning2() {
  lightningActive2 = true;
  lightningState2 = 'fadeIn';
  lightningOpacity2 = 0;
  lightningTimer2 = Date.now(); // Zapisz czas rozpoczęcia błyskawicy
}

function updateLightning2() {
  if (lightningActive2) {
    if (lightningState2 === 'fadeIn') {
      lightningOpacity2 += (0.9/ (lightningFadeDuration2 / frameDuration));
      if (lightningOpacity2 >= 1) {
        lightningOpacity2 = 0.7;
        lightningState2 = 'fadeOut';
      }
    } else if (lightningState2 === 'fadeOut') {
      lightningOpacity2 -= (1.5 / (lightningFadeDuration2 / frameDuration));
      if (lightningOpacity2 <= 0) {
        lightningOpacity2 = 0;
        lightningActive2 = false;
        lightningState2 = 'fadeIn';
      }
    }
  } else {
    if (Date.now() - lightningTimer2 >= lightningCooldown2) {
      
    }
  }
}


        let hurtEffectActive = false;
        let hurtEffectOpacity = 0;
        const hurtEffectDuration = 1000; // Czas trwania efektu (ms)
        const fadeInDuration = 500; // Czas fade-in (ms)
        const fadeOutDuration = 500; // Czas fade-out (ms)
        let hurtEffectStartTime=0;
        const hurtEffectImage = new Image();
        hurtEffectImage.src = './hurteffect.png';

        function startHurtEffect() {
            hurtEffectActive = true;
            hurtEffectOpacity = 0;
            requestAnimationFrame(updateHurtEffect);
        }

        function updateHurtEffect() {
            if (hurtEffectActive) {
                const currentTime = Date.now();

                // Fade-in
                if (hurtEffectOpacity < 0.7) {
                    hurtEffectOpacity += (1.0 / (fadeInDuration / 16)); // 16 ms to przybliżony czas klatki
                } else if (hurtEffectOpacity >= 0.7 && currentTime - hurtEffectStartTime < hurtEffectDuration) {
                    // Czekaj na pełne wyświetlenie
                } else {
                    // Fade-out
                    if (hurtEffectOpacity > 0) {
                        hurtEffectOpacity -= (1.0 / (fadeOutDuration / 16));
                    } else {
                        hurtEffectActive = false; // Zakończ efekt
                    }
                }

                // Rysuj efekt
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Czyść ekran
                ctx.globalAlpha = hurtEffectOpacity; // Ustaw przezroczystość
                ctx.drawImage(hurtEffectImage, 0, 0, canvas.width, canvas.height); // Rysuj obrazek na cały ekran
                ctx.globalAlpha = 1; // Przywróć przezroczystość

                requestAnimationFrame(updateHurtEffect);
            }
        }





function drawLightning() {
    if (lightningActive && isRaining&& generateCave!==1&& isinhouse!==1) {
        // Rysowanie błyskawicy z animacją przezroczystości
        ctx.fillStyle = `rgba(255, 255, 255, ${lightningOpacity})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height); // rysuj prostokąt na całym ekranie
    }
}

function updateLightning() {
    if (isRaining && lightningActive && generateCave!==1&& isinhouse!==1) {
        // Zmiana stanu animacji
        if (lightningState === 'fadeIn') {
            lightningOpacity += (0.4 / (lightningFadeDuration / frameDuration));
            if (lightningOpacity >= 0.6) {
                lightningOpacity = 0.2; // ogranicz do 1
                lightningState = 'fadeOut'; // Przejdź do fade out
            }
        } else if (lightningState === 'fadeOut') {
            lightningOpacity -= (0.05 / (lightningFadeDuration / frameDuration));
            if (lightningOpacity <= 0) {
                lightningOpacity = 0; // ogranicz do 0
                lightningActive = false; // Wyłącz efekt błyskawicy
                lightningState = 'fadeIn'; // Przywróć stan do fadeIn na następny raz
            }
        }
    } else {
        // Sprawdź, czy błyskawica może być aktywowana
        const currentTime = Date.now();
        if (currentTime - lastLightningTime >= lightningCooldown) {
            if (Math.random() < 0.005) {
                lightningActive = true;
                lightningOpacity = 0; // Resetuj przezroczystość na 0
                if(isRaining && generateCave!==1&& isinhouse!==1){
                playthundersound()
                }
                lastLightningTime = currentTime;
                lightningState = 'fadeIn'; // Ustaw stan na fadeIn
            }
        }
    }
}
var toggleNightVison=false
function synchronizeVisibleChunks() {
  if (Array.isArray(housechunks)) {
  housechunks = {}; // zmienna staje się pustym obiektem
}
  if(overworldChunks){
  if(renderedBlocks!==null&& renderedBlocks){
    renderedBlocks.forEach(block => {
        const x = block.x;
        const y = block.y;

        // Synchronizacja drzwi (door)
        
        // Synchronizacja ściany domu (house_wall)
        if (checkBlockAtOverWorldPosition(x, y, "house_wall")||checkBlockAtOverWorldPosition(x, y, "houseroof")||checkBlockAtOverWorldPosition(x, y, "ryeroof")||checkBlockAtOverWorldPosition(x, y, "brickhouse")||checkBlockAtOverWorldPosition(x, y, "gypsumroof")||checkBlockAtOverWorldPosition(x, y, "gypsumhouse")) {
          if(checkBlockAtPosition(x,y,"voidblock")){
            removeBlockAtPosition2(x, y, "voidblock");
            buildBlockAtPositionBefore2(x, y, "housegrass");
          }
        } else {
   
            if (!checkBlockAtPosition(x, y, "voidblock")) {
                buildBlockAtPositionBefore2(x, y, "voidblock");
                removeBlockAtPosition2(x, y, "housegrass");
            }
            
        }
        
        if (checkBlockAtOverWorldPosition(x, y, "door")||checkBlockAtOverWorldPosition(x, y, "gypsumdoor")) {
            // Jeśli w `chunks` nie ma "door", dodaj go
            
               
                
if (checkBlockAtPosition(x, y, "voidblock")) {
  removeBlockAtPosition2(x, y, "voidblock");
  buildBlockAtPositionBefore2(x, y, "housegrass");
}
  removeBlockAtPosition2(x, y, "door2");
   


  buildBlockAtPosition(x, y, "door2");
  if (checkBlockAtPosition(x, y, "door2")) {
    if(!checkBlockAtPosition(x, y, "housegrass")){
  removeBlockAtPosition2(x, y, "voidblock");
  buildBlockAtPositionBefore2(x, y, "housegrass");
}}

            
        } else {
 
            if (checkBlockAtPosition(x, y, "door2")) {
if (checkBlockAtPosition(x, y, "voidblock")) {
  removeBlockAtPosition2(x, y, "voidblock");
  buildBlockAtPositionBefore2(x, y, "housegrass");
}
                removeBlockAtPosition2(x, y, "door2");
                removeBlockAtPosition2(x, y, "door2")
            }
        }
 
    });
}}}


function getVisibleChunks() {
    const visibleChunks = [];
    const chunkSize = blockSize * 1; // Zakładam, że jeden chunk ma 16x16 bloków

    const startX = Math.floor((offsetX - canvas.width / 2) / chunkSize);
    const endX = Math.floor((offsetX + canvas.width / 2) / chunkSize);
    const startY = Math.floor((offsetY - canvas.height / 2) / chunkSize);
    const endY = Math.floor((offsetY + canvas.height / 2) / chunkSize);

    for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
            visibleChunks.push(`${x},${y}`);
        }
    }
    return visibleChunks;
}

function checkBlockAtOverWorldPosition(x, y, type) {
  // Oblicz pozycje globalne z przesunięciem
  const globalX = x + offsetX;
  const globalY = y + offsetY;
   
  
  const snappedGlobalX = Math.floor(globalX / blockSize) * blockSize;
  const snappedGlobalY = Math.floor(globalY / blockSize) * blockSize;

  // Iterowanie przez chunki, ale tylko te, które są w pobliżu kliknięcia
  const chunkX = Math.floor(snappedGlobalX / blockSize);
  const chunkY = Math.floor(snappedGlobalY / blockSize);

  const neighboringChunks = [
        `${chunkX},${chunkY}`, // dokładnie ten chunk

    ];

  // Sprawdzamy tylko sąsiednie chunki
  
  for (let chunkKey of neighboringChunks) {
    let chunkBlocks = overworldChunks[chunkKey];
    if (!chunkBlocks) continue; // pomiń chunk, jeśli nie istnieje

    // Iterujemy przez wszystkie bloki w danym chunku
    for (let i = 0; i < chunkBlocks.length; i++) {
      let block = chunkBlocks[i];

      // Sprawdzamy najpierw, czy typ pasuje, aby ograniczyć liczbę operacji
      if (block.type !== type) continue;

      let blockGlobalX = block.x + chunkX * blockSize;
      let blockGlobalY = block.y + chunkY * blockSize;

      // Jeśli pasuje współrzędna, zwracamy true
      if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
        return true;
      }
    }
  }
  return false; // Nie znaleziono bloku o zadanym typie
}

const itemsAndDamage = {
  "pointed_stick": { dmg: 1, kill: ["voltary", "giantbat", "bunny","duck"], duration: 80, cooldown: 80, range: 75},
  "bone_sword": { dmg: 1, kill: ["voltary", "giantbat", "bunny"], duration: 50, cooldown: 30, range: 75 },
  "long_spear": { dmg: 3, kill: ["shark"], duration: 85, cooldown: 120, range: 90 },
"magicwand": { dmg: 20, kill: [], duration: 40, cooldown: 50, range: 73 },
"godwand": { dmg: 20, kill: [], duration: 150, cooldown: 600, range: 63 },
"greenwand": { dmg: 10, kill: [], duration: 40, cooldown: 50, range: 73 },
"magicwandofsharp": { dmg: 20, kill: [], duration: 40, cooldown: 50, range: 73 },
"hyperblastwand": { dmg: 20, kill: [], duration: 40, cooldown: 50, range: 73 },
// boomerang 
"boomerang": { dmg: 0.0, kill: [], duration: 0, cooldown: 0, range: 0},
"titanium_boomerang": { dmg: 0.0, kill: [], duration: 0, cooldown: 0, range: 0},
"good_boomerang": { dmg: 0.0, kill: [], duration: 0, cooldown: 0, range: 0},
"hell_boomerang": { dmg: 0.0, kill: [], duration: 0, cooldown: 0, range: 0},
"draco_boomerang": { dmg: 0.0, kill: [], duration: 0, cooldown: 0, range: 0},
  "copper_spear": { dmg: 5, kill: [], duration: 50, cooldown: 50, range: 80 },
  "iron_spear": { dmg: 10, kill: [], duration: 100, cooldown: 50, range: 85 },
  "iron_sword": { dmg: 18, kill: [], duration: 50, cooldown: 70, range: 90 },
  "bow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 80 },
  "hellbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "quantumbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "rainbowbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "moltenbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "nightbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "darkbow": { dmg: 2, kill: [], duration: 50, cooldown: 70, range: 83 },
  "iron_mace": { dmg: 25, kill: [], duration: 400, cooldown: 120, range: 65 },
  "titaniumsword": { dmg: 40, kill: [], duration: 40, cooldown: 50, range: 90 },
  "thundersword": { dmg: 85, kill: [], duration: 60, cooldown: 50, range: 95 },
  "nightsword": { dmg: 80, kill: [], duration: 60, cooldown: 50, range: 90 },
  "aquaspear": { dmg: 100, kill: [], duration: 50, cooldown: 70, range: 100 },
  "sharpmace": { dmg: 120, kill: [], duration: 50, cooldown: 100, range: 70 },
    "sharpsaw": { dmg: 120, kill: [], duration: 60, cooldown: 50, range: 90 },
    "hellsword": { dmg: 160, kill: [], duration: 60, cooldown: 50, range: 90 },
  "goodsword": { dmg: 200, kill: [], duration: 50, cooldown: 50, range: 95 },
  "fleshsaber": { dmg: 350, kill: [], duration: 20, cooldown: 100, range: 100 },
  "moltensword": { dmg: 360, kill: [], duration: 60, cooldown: 100, range: 100 },
  "goodmace": { dmg: 250, kill: [], duration: 100, cooldown: 200, range: 85 },
  
  "titaniummace": { dmg: 60, kill: [], duration: 50, cooldown: 150, range: 65 },
  "universesword": { dmg: 500, kill: [], duration: 20, cooldown: 100, range: 100 },
  "trueuniversesword": { dmg: 999, kill: [], duration: 80, cooldown: 100, range: 100 },
  "rainbow": { dmg: 420, kill: [], duration: 20, cooldown: 100, range: 100 },
  
"truegodsword": { dmg: 3785320, kill: [], duration: 80, cooldown: 10, range: 100 },

"magiclanter": { dmg: 10, kill: [], duration: 20, cooldown: 100, range: 90 },
};

var weaponSpearAnimation=["long_spear","iron_spear","copper_spear","aquaspear","magiclanter","pointed_stick","magicwand",'greenwand',"hyperblastwand",'magicwandofsharp',"godwand","bow","hellbow","nightbow","darkbow","quantumbow","rainbowbow","moltenbow"]
// Przechowywanie stanu broni
let activeWeapon = null;
let weaponCooldown = false;
let rotationAngle = 0;
var cooldownatk=false;
function startWeaponRotation(weapon) {
  if (weaponCooldown) return; // Jeśli trwa cooldown, nie można aktywować broni

  activeWeapon = weapon;
  weaponCooldown = true; // Aktywujemy cooldown
  rotationAngle = 0; // Resetujemy kąt obrotu

  // Ustawiamy timer na czas trwania broni
  setTimeout(() => {
    activeWeapon = null; // Wyłączamy broń po zakończeniu duration
    setTimeout(() => weaponCooldown = false, itemsAndDamage[weapon].cooldown); // Włączamy cooldown
  }, itemsAndDamage[weapon].duration);
}

  
function drawWeapon(ctx) {
  if (!activeWeapon) return; // Nie rysujemy, jeśli nie ma aktywnej broni
  
  const weaponData = itemsAndDamage[activeWeapon];
  const range = weaponData.range-40; // Pobranie zasięgu broni

  const playerCenterX = player.x + player.width * 2;
  const playerCenterY = player.y + player.height * 2;
  const canvasCenterX = playerCenterX - 32 - 15;
  const canvasCenterY = playerCenterY - 32 - 15;

  const weaponTexture = new Image();
  weaponTexture.src = textureSources[activeWeapon];

  ctx.save();
  ctx.translate(canvasCenterX, canvasCenterY);
  ctx.rotate(rotationAngle);

  // Zamiast stałej wielkości 32, użyjemy `range` do określenia rozmiaru broni
  ctx.drawImage(weaponTexture, 0, -range, range, range); // Używamy `range` jako wielkości broni

  ctx.restore();

  const duration = weaponData.duration;
  if (!weaponSpearAnimation.includes(activeWeapon)) {
    rotationAngle += (2 * Math.PI) / (duration / 16.67);
  }
}

function handleWeaponUse(weapon, x, y) {
  if (weapon && cooldownatk == false) {
    cooldownatk = true;
    activeWeapon = weapon;
currentweapon=weapon
able1=0; able2=0; i1pp=0; i2pp=0;
    // Oblicz kąt rotacji na podstawie pozycji gracza i pozycji kliknięcia
    const playerCenterX = player.x + player.width * 2;
const playerCenterY = player.y + player.height * 2;
const canvasCenterX = playerCenterX - 32 ;
const canvasCenterY = playerCenterY - 32 ;
    // Oblicz różnice w pozycjach
    const deltaX = x - canvasCenterX;
    const deltaY = y - canvasCenterY;

    // Oblicz kąt rotacji w radianach
    rotationAngle = Math.atan2(deltaY, deltaX)+(90/2);

    setTimeout(function () {
      cooldownatk = false;
    }, itemsAndDamage[activeWeapon].cooldown * 5);
    setTimeout(function() {
  activeWeapon = null
}, itemsAndDamage[activeWeapon].duration * 5) ;
  }
}
let currentweapon=null
let i1pp=0
let i2pp=0
let able1=0
let able2=0
function weaponTimeout(){
 /* if(currentweapon!==null){
    
    if(able1==0){i1pp+=17;
    if(i1pp>=itemsAndDamage[currentweapon].cooldown * 5){
      cooldownatk = false;
      able1=1
    }}
    if(able2==0){i2pp+=17;
    if(i2pp>=itemsAndDamage[currentweapon].duration * 5){
      activeWeapon = null
      able2=1
      currentweapon=null
    }}
  }*/
}

 
 let maxOxygen = 1000;  // Maksymalny poziom tlenu
let oxygen = 1000;     // Aktualny poziom tlenu
function updateOxygen() {
    if (isunderwater === 1) {
        oxygen = Math.max(0, oxygen - 1.5);  // Odejmij 1 punkt tlenu co tick, ale nie pozwól, aby spadł poniżej 
        if(oxygen<1){
          oxygen=0
          updateHealth(-0.5)
        }
    } else {
        oxygen = Math.min(maxOxygen, oxygen + 5);  // Dodaj 2 punkty tlenu, jeśli gracz jest na powierzchni
        if(oxygen>maxOxygen){
          oxygen=maxOxygen+1
        }
    }
}
function drawOxygenBar(ctx) {
    if (isunderwater === 1) {
        const barWidth = canvas.width * 0.5;  // Szerokość paska jako 50% szerokości canvasa
        const barHeight = 10;  // Wysokość paska tlenu
        const barX = (canvas.width - barWidth) / 2;  // Pozycja paska na środku
        const barY = canvas.height -25 - barHeight - 10; // Pasek na dole canvasa

        // Obliczenie szerokości zielonego paska na podstawie poziomu tlenu
        const oxygenLevelWidth = (oxygen / maxOxygen) * barWidth;

        // Tło paska (ciemny kolor)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // Pasek tlenu (zielony, jeśli dużo tlenu; czerwony, gdy blisko wyczerpania)
        ctx.fillStyle = oxygen > 500 ? 'rgb(0,255,155)' : 'rgb(50,215,215)';
        ctx.fillRect(barX, barY, oxygenLevelWidth, barHeight);

        // Opcjonalnie dodaj obramowanie dla paska
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
}
var abletostart=0
var tickFix=0
var zoomedDELTA=0
    let isUpdating = 0;

 let weponDelay=0
let fskip=0
let onbigbed=0

function updatePlayerAnimation() {
  
    const inWater = isPlayerInWater(); // Sprawdzenie, czy gracz jest w wodzie
if(inWater ){
  if(checkIfItems("broom", 1) && isflying==1){
  }else{
  updateStamina(-0.2)
}}
    // Logika wyboru animacji
    if (inWater || (checkIfItems("broom", 1) && isflying == 1)) {
        if (moveRight) {player.currentAnimation = 'inwater_moveright';lastDirection="right"}
        else if (moveLeft){ player.currentAnimation = 'inwater_moveleft';lastDirection="left"}
        else if (moveUp) {player.currentAnimation = 'inwater_moveup';lastDirection="up"}
        else if (moveDown) {player.currentAnimation = 'inwater_movedown';lastDirection="down"}
        playerSpeed = waterspeed;
    } else {
        playerSpeed = norspeed;
        if (moveRight && moveUp) {player.currentAnimation = 'moveupright';lastDirection="up";}
        else if (moveLeft && moveUp) {player.currentAnimation = 'moveupleft';lastDirection="left";}
        else if (moveRight) {player.currentAnimation = 'moveright';lastDirection="right";}
        else if (moveLeft) {player.currentAnimation = 'moveleft';lastDirection="left";}
        else if (moveUp) {player.currentAnimation = 'moveup';lastDirection="up";}
        else if (moveDown){ player.currentAnimation = 'movedown';lastDirection="down";}
        else {
            if (player.currentAnimation.includes('move')) {
                if (player.currentAnimation === 'moveup'){ player.currentAnimation = 'stayup';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveupright'){ player.currentAnimation = 'stayupright';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveupleft'){ player.currentAnimation = 'stayupleft';
                lastDirection="up"
                }
                if (player.currentAnimation === 'moveleft'){ player.currentAnimation = 'stayleft';
                lastDirection="left"
                }
                if (player.currentAnimation === 'moveright'){ player.currentAnimation = 'stayright';
                lastDirection="right"
                }
                if (player.currentAnimation === 'movedown'){ player.currentAnimation = 'staydown';
                lastDirection="down"
                  
                }
            }
        }
    }

    if ((moveLeft || moveRight || moveUp || moveDown) && !inWater && !(checkIfItems("broom", 1) && isflying==1)) {
      
        playFootstepSound();
        stopswimsound()
    } else if((moveLeft || moveRight || moveUp || moveDown)&& !(checkIfItems("broom", 1) && isflying==1)) {
        stopFootstepSound();
        playswimsound()
    }else{
      stopswimsound()
      stopFootstepSound()
    }

    // Obsługa animacji klatek
    player.frameCounter++;
    if (player.frameCounter >= player.frameSpeed) {

        player.frameIndex = (player.frameIndex + 1) % player.textures[player.currentAnimation].length;
        player.frameCounter = 0;
    }

    // Ładowanie nowej tekstury gracza
    let newTexture 
            if (player.frameIndex +1 > player.textures[player.currentAnimation].length) {
            player.frameIndex -=1
        }
newTexture = player.textures[player.currentAnimation][player.frameIndex];
if (issmoking !== 0) {

    newTexture = armourstextures.smoking[player.currentAnimation][player.frameIndex];
    // alert("_")
}else if (checkIfItems("broom", 1) && isflying == 1) {
  newTexture = armourstextures.broom[player.currentAnimation][player.frameIndex];
  
}else if (checkIfItems("dracobuff", 1)) {
    newTexture = armourstextures.dracobuff[player.currentAnimation][player.frameIndex];

} else   if (checkIfItems("hellbuff", 1)) {
  newTexture=armourstextures.hellbuff[player.currentAnimation][player.frameIndex];
  
} else if( checkIfItems("titaniumbuff",1)){
      newTexture = armourstextures.titaniumbuff[player.currentAnimation][player.frameIndex];
      
}else{
    
}
  //  newTexture.onload = function() {
        player.texture = newTexture;
  //  };

     
    nocliping = 0
if (isflying == 1) {
  nocliping = 1
}
if (options.noclip == 1) {
  nocliping = 1
}
}

function update() {
    players[yourname].x=Math.floor(offsetX/32); players[yourname].y=Math.floor(offsetY/32);
    
    if(gametest==1){
        activatedCheats=1;
        options.creativemode=1;
        options.noclip=1;
    }
    let offsetboxGui="25px"

    fskip+=1;
    if(fskip>2){
        fskip=0
    }
    if(options.Fskipping==1){
          targetFPS = 10;
           speedmultiply=1.70
         frameDuration = 1000 / targetFPS;
    }else if (options.Fskipping !== 1) {
    targetFPS = 14;
    speedmultiply=1.60
    frameDuration = 1000 / targetFPS;
    }
    if(weponDelay>0){
        weponDelay-=1
    }
 if(by5>14){
         if (options.invertControls == 1) {
        document.getElementById("joystick").style.left = ""
        document.getElementById("joystick").style.right = offsetboxGui
        document.getElementById("Q1EQ").style.left = offsetboxGui
        document.getElementById("Q1EQ").style.right = ""

    } else {
        document.getElementById("joystick").style.left = offsetboxGui
        document.getElementById("joystick").style.right = ""
        document.getElementById("Q1EQ").style.left = ""
        document.getElementById("Q1EQ").style.right = offsetboxGui
    }
      if(options.zoomout==1){
       if(options.biggerzoomout==1){
        zoomedDELTA=53
       }else{
       zoomedDELTA=37
       }
  canvas.width=420+zoomedDELTA; canvas.height=350+zoomedDELTA;
  ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
player.x = canvas.width / 2 - 2 ;
player.y = canvas.height / 2 + 6.7 ;
 }else{
  canvas.width=420; canvas.height=350;
  ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
zoomedDELTA=0
    player.x = canvas.width / 2 -2+zoomedDELTA;
    player.y = canvas.height / 2 +6.7+zoomedDELTA;
    
 }}
 
  
  if (isUpdating>1) {
      isUpdating=0
  }else if(paused!==1){
      multiplayerLoop()
const startTime = performance.now();
 if(players[yourname]){
const playerCenterX = offsetX + canvas.width / 2 * 32 ;
const playerCenterY = offsetY + canvas.height / 2 * 32 ;
     players[yourname].x=playerCenterX
     players[yourname].y=playerCenterY
 }
 
 
    isUpdating += 1; // Ustaw flagę na true, aby oznaczyć, że funkcja jest w trakcie wykonywania
      
    weaponTimeout()
  if( currentTrack !== trueTrack && checkIfHasEnemy("trueuniversehead",1)){
    playTrueTrack()
  }
 // nightpower=2.8
 if(activatedCheats!==1){
   options.noclip=0
 }
 watertickcount += 1
if (watertickcount > 40) {
  watertickcount = 0
}
updateHurtEffect()
  if(abletostart==1){
if (checkIfItems("dracobuff", 1)) {
      updateHealth2(0.23)
  }else{
    if(checkIfItems("healthregenerator",1) && !checkIfItems("hellbuff",1)){
      updateHealth2(0.06);
    }
    if (checkIfItems("staminaregenerator", 1)) {
      updateStamina(0.08);
    }
    
  if (checkIfItems("hellbuff", 1)) {
  updateHealth2(0.2)
}}
if(checkIfItems("broom", 1) && isflying==1){
 updateStamina(-0.10)
playerSpeed = 6.5  // 6.5
}else if (isflying == 1) {
  isflying = 0
} else if( checkIfItems("speedmedalion",1) ){
    
    playerSpeed=6
    const inWater = isPlayerInWater();
if (inWater) {
  playerSpeed = waterspeed;
}
  }else{
    
    playerSpeed=5
    const inWater = isPlayerInWater();
    if(inWater){
    playerSpeed = waterspeed;
    }
  }
  
  
  
  if( checkIfItems('compass',1)){
    showTextInCanvas2("X:"+Math.floor(offsetX/32)+" Y:"+Math.floor(offsetY/32) )
  }
  if(checkIfItems("healmedalion",1)){
    updateHealth(0.01);
  }
  
  
    if (Array.isArray(housechunks)) {
  housechunks = {}; // zmienna staje się pustym obiektem
}
  canvas = document.getElementById('gameCanvas');
    
    updateDayNightCycle();
    by5++
    checkCaveEntranceOrExit(player.x, player.y);
    if(options.creativemode==1){
      currentHP=100
    }
if((isStayOn("grass")||isStayOn("forestgrass")||isStayOn("sand")||isStayOn("snowgrass")||isStayOn("snowgrass2"))&& nightpower<2.8){
if (Math.random() <= 0.021) {
if(!checkIfHasEnemy("butterflyyellow",3)&&!checkIfHasEnemy("butterflyred",3)&&!checkIfHasEnemy("butterflyblue",3)){
  const slimeTypes = [ "butterflyyellow","butterflyred","butterflyblue"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 8 * blockSize;
  function spawnEnemyNearPlayer() {
  if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance; } else { enemyX = offsetX; }
  if (Math.random() >= 0.3) { enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
  let bat = new Enemy(enemyX, enemyY, randomSlime);
  renderedEnemies.push(bat);
  bat.speed = 2.2
}
  spawnEnemyNearPlayer();
}}
}

    if(isStayOn("forestgrass")&& nightpower>=2.7){
      if (Math.random() <= 0.015) {
        if(!checkIfHasEnemy("ghost",2)){
  const slimeTypes = [ "ghost"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 8 * blockSize;

  function spawnEnemyNearPlayer() {
    const enemyX = Math.random() >= 0.3 ? offsetX + spawnDistance : offsetX - spawnDistance;
    const enemyY = Math.random() >= 0.3 ? offsetY + spawnDistance : offsetY - spawnDistance;
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed = 2.5
  }
  spawnEnemyNearPlayer();
}}
    }
    if(isStayOn("forestgrass")&& nightpower>=2.0){
      if (Math.random() <= 0.015) {
        if(!checkIfHasEnemy("firefly",3)){
  const slimeTypes = [ "firefly"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 8 * blockSize;

  function spawnEnemyNearPlayer() {
    const enemyX = Math.random() >= 0.3 ? offsetX + spawnDistance : offsetX - spawnDistance;
    const enemyY = Math.random() >= 0.3 ? offsetY + spawnDistance : offsetY - spawnDistance;
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed = 2
  }
  spawnEnemyNearPlayer();
}}
    }
    if(inabyss==1){
      
      if(Math.random()<0.002){
        if(checkIfHasEnemy("abyssdevourerhead",2)){
        }else{
        createAbyssdevourer()
      }}


if (Math.random() <= 0.015) {
  const slimeTypes = ['voidguardian',"soulcat","skellybones","voidguardian"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 8 * blockSize;
  function spawnEnemyNearPlayer() {
    const enemyX = Math.random() >= 0.3 ? offsetX + spawnDistance : offsetX - spawnDistance;
    const enemyY = Math.random() >= 0.3 ? offsetY + spawnDistance : offsetY - spawnDistance;
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=2
  }
  spawnEnemyNearPlayer();
}
    }
    if(inhell==1){
      if(isStayOn("fleshblock1")||isStayOn("fleshblock2")||isStayOn("fleshblock")){
if (Math.random() <= 0.015) {
  const slimeTypes = ['hellskull',"flesher","flesher"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  let spawnDistance = 9 * blockSize;
  if (randomSlime == "flesher") {
spawnDistance = 6* blockSize
}
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    if(randomSlime=="flesher"){
bat.speed=2.5
    }else{
    bat.speed=4.2
    }
  }spawnEnemyNearPlayer();}
      }else{
      if (Math.random() <= 0.008) {
  const slimeTypes = ['hellskull',"hellscourge",'hellskull','hellskull',"flesher"];
  let randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 9 * blockSize;
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=4.2
  }
  if(randomSlime!=="hellscourge" || checkIfHasEnemy("hellscourgehead",1)){randomSlime="hellskull"; spawnEnemyNearPlayer();}else{
    createHellScourge()
  }
        
      }
    }}
    if(isunderwater==0 && inhell==0){
      
      if (Math.random() <= 0.008) {
  const slimeTypes = ['greenslime', 'blueslime', 'pinkslime'];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 9 * blockSize;
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=2
  }
  spawnEnemyNearPlayer();
}
      
    if(generateCave==1){
      if (Math.random() <= 0.003) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'skellybones');
  const spawnDistance = 9 * blockSize;

  function spawnBatNearPlayer() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'skellybones');
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale  lub zdarzeniu)
  spawnBatNearPlayer();


}

            if (Math.random() <= 0.007) {
        let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'giantbat');
        const spawnDistance = 9 * blockSize;
        function spawnBatNearPlayer() {
          let batX, batY;
          if (Math.random() >= 0.3) {
            batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
          } else {
            batX = offsetX; // 10 bloków w lewo od gracza
          }

          // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
          if (Math.random() >= 0.3) {
            batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
          } else {
            batY = offsetY; // 10 bloków w górę od gracza
          }

          // Tworzenie nowego nietoperza w wylosowanej pozycji
          let bat = new Enemy(batX, batY, 'giantbat');
          renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
        }

        // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
        spawnBatNearPlayer();


      }
    }
    if(nightpower>=2){
                  if (Math.random() <= 0.007) {
        let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'skellybones');
        const spawnDistance = 9 * blockSize;
        function spawnBatNearPlayer() {
          let batX, batY;
          if (Math.random() >= 0.3) {
            batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
          } else {
            batX = offsetX; // 10 bloków w lewo od gracza
          }

          // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
          if (Math.random() >= 0.3) {
            batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
          } else {
            batY = offsetY; // 10 bloków w górę od gracza
          }

          // Tworzenie nowego nietoperza w wylosowanej pozycji
          let bat = new Enemy(batX, batY, 'skellybones');
          renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
        }

        // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
        spawnBatNearPlayer();


      }
      
      if (Math.random() <= 0.002 && curseofgos==1)  {
 // let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'spary');
  // Stała reprezentująca 10 bloków odległości
  const spawnDistance = 9 * blockSize;

  // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
  function spawnBatNearPlayer() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    if(Math.random()<0.8){
    let bat = new Enemy(batX, batY, 'spary');
    renderedEnemies.push(bat);
    }else{
      let bat = new Enemy(batX, batY, 'skull');
renderedEnemies.push(bat);
    }
     // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
  spawnBatNearPlayer();


}
      if(Math.random()<=0.007){
        let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'bat');
        // Stała reprezentująca 10 bloków odległości
const spawnDistance = 9* blockSize;

// Funkcja tworzenia nietoperza w losowej pozycji względem gracza
function spawnBatNearPlayer() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
        batX =  offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
        batX = offsetX ; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
        batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
        batY = offsetY ; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'bat');
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
}

// Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
spawnBatNearPlayer();


      }
    }
   let chance5=0
    if(nightpower>2){
      chance5=0.0005
    }else{
      chance5=0.00005
      
    }
    if(generateCave==1 ){
      chance5=0.0008
    }
    if ((Math.random() <= chance5 )) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'raven');
  // Stała reprezentująca 10 bloków odległości
  const spawnDistance = 8 * blockSize;

  // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
  function spawnBatNearPlayer() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'raven');
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
  spawnBatNearPlayer();


}
    if (Math.random() <= 0.003) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'wasp', 32, 32, 2);
  
  // Stała reprezentująca 10 bloków odległości
  const spawnDistance = 9 * blockSize;

  // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
  function spawnBatNearPlayer2() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'wasp');
    bat.speed = 1.5
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
  spawnBatNearPlayer2();


}else if (Math.random() <= 0.005) {
    let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'shark', 32, 32, 1);
    // Stała reprezentująca 10 bloków odległości
    const spawnDistance = 9 * blockSize;

    // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
    function spawnBatNearPlayer2() {
        let batX, batY;

        // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
        if (Math.random() >= 0.3) {
            batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
        } else {
            batX = offsetX; // 10 bloków w lewo od gracza
        }

        // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
        if (Math.random() >= 0.3) {
            batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
        } else {
            batY = offsetY; // 10 bloków w górę od gracza
        }

        // Tworzenie nowego nietoperza w wylosowanej pozycji
        let bat = new Enemy(batX, batY, 'shark');
        bat.speed = 1.5
        renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
    }

    // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
    spawnBatNearPlayer2();


}else if (Math.random() <= 0.005) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'duck', 32, 32, 1);
  // Stała reprezentująca 10 bloków odległości
  const spawnDistance = 9 * blockSize;

  // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
  function spawnBatNearPlayer2() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'duck');
    bat.speed = 1.5
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
  spawnBatNearPlayer2();


}else  if (Math.random() <= 0.002) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, 'bunny', 32, 32, 1);
  // Stała reprezentująca 10 bloków odległości
  const spawnDistance = 9 * blockSize;

  // Funkcja tworzenia nietoperza w losowej pozycji względem gracza
  function spawnBatNearPlayer2() {
    let batX, batY;

    // Losowanie pozycji X: 10 bloków w lewo (-) lub w prawo (+)
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance; // 10 bloków w prawo od gracza
    } else {
      batX = offsetX; // 10 bloków w lewo od gracza
    }

    // Losowanie pozycji Y: 10 bloków w górę (-) lub w dół (+)
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance; // 10 bloków w dół od gracza
    } else {
      batY = offsetY; // 10 bloków w górę od gracza
    }

    // Tworzenie nowego nietoperza w wylosowanej pozycji
    let bat = new Enemy(batX, batY, 'bunny');
    bat.speed = 1.5
    renderedEnemies.push(bat); // Dodanie nietoperza do listy renderowanych przeciwników
  }

  // Przykład wywołania funkcji (np. w regularnym interwale lub zdarzeniu)
  spawnBatNearPlayer2();


}}else if(inhell!==1){
  if (Math.random() <= 0.004) {
  let bat = new Enemy(8 * blockSize + offsetX, 8 * blockSize + offsetY, '1medusa', 32, 32, 1);
  const spawnDistance = 9 * blockSize;
  function spawnBatNearPlayer2() {
    let batX, batY;
    if (Math.random() >= 0.3) {
      batX = offsetX + spawnDistance;
    } else {
      batX = offsetX;
    }
    if (Math.random() >= 0.3) {
      batY = offsetY + spawnDistance;
    } else {
      batY = offsetY; 
    }
    let bat = new Enemy(batX, batY, '1medusa');
    bat.speed = 1.5
    renderedEnemies.push(bat); 
  }
  spawnBatNearPlayer2();
}
  
}
    playerX = offsetX; // Gracz jest zawsze na środku ekranu
    playerY = offsetY;
let addY=0
if(onbigbed==1){
    addY=-15
}
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let previousOffsetX = offsetX;
    let previousOffsetY = offsetY;

    // Ruch gracza
    if(cannotmove!==1){
    if (moveLeft) offsetX -= playerSpeed*speedmultiply;
    if (moveRight) offsetX += playerSpeed*speedmultiply;
    if (moveUp) offsetY -= playerSpeed*speedmultiply;
    if (moveDown) offsetY += playerSpeed*speedmultiply;
    }
if(moveDown || moveUp || moveLeft || moveRight){
  updateStamina(-0.05)
}else{
  updateStamina(0.17)
}
    // Ustawienie celu na zaokrągloną pozycję, gdy nie ma ruchu
    if (!moveDown && !moveUp && !moveRight && !moveLeft) {
        targetX = (Math.floor(offsetX / 32) * 32)+17 ; // Zaokrąglamy offsetX
        targetY = (Math.floor(offsetY / 32) * 32)+10 ; // Zaokrąglamy offsetY
    }

    // Gładkie przesuwanie do docelowej pozycji
    if (!moveDown && !moveUp && !moveRight && !moveLeft) {
        offsetX += (targetX - offsetX) * smoothingFactor;
        offsetY += (targetY - offsetY) * smoothingFactor;
        if (Math.abs(offsetX - targetX) < 0.1 && Math.abs(offsetY - targetY) < 0.1) {
            offsetX = targetX;
            offsetY = targetY;
        }
    }

    const { treesBelowPlayer, treesAbovePlayer } = drawChunks();

    const playerCenterX = player.x + offsetX + player.width * 2;
    const playerCenterY = player.y + offsetY + player.height * 2;

    let collision = checkCollisionWithRock(playerCenterX, playerCenterY);
    if (collision && warped!==1) {
        offsetX = previousOffsetX;
        offsetY = previousOffsetY;
        console.log('Kolizja z blokiem rock, cofanie ruchu.');
    }else if(! collision && warped==1){
        warped=0;
    }

    // Rysowanie chunków i drzew
   // drawTreesBelowPlayer(treesBelowPlayer);
    if(checkIfHasEnemy("trueuniversebody",1)){
ctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    drawEnemies()
  updateOthersAnimation()
  if(experimentalmultiplayer==1){
    for (const playerName in players) {
    const playerData = players[playerName];
    if (playerData.texture) {
        ctx.drawImage(playerData.texture, playerData.x - offsetX, playerData.y - offsetY, playerData.width, playerData.height);
        drawPlayerInfo(playerData,playerName); // Rysowanie nicku i HP
    }
}}

     if(player.texture){
         
    if(!(checkIfItems("broom", 1) && isflying==1)){
        
    ctx.drawImage(player.texture, player.x, player.y+addY, player.width, player.height);
    }
    drawTreesAbovePlayer(treesAbovePlayer);
}else{
  // console.log(player.frameIndex)
}
if(player.texture){
if ((checkIfItems("broom", 1) && isflying == 1)) {
    ctx.drawImage(player.texture, player.x, player.y + addY, player.width, player.height);
}
}else{
    console.log(player.frameIndex+" "+player.currentAnimation)
}
    // Dodanie efektu ciemności nad każdym chunk'iem, jeśli w pobliżu nie ma pochodni
    // Dodanie efektu ciemności nad każdym chunk'iem, jeśli w pobliżu nie ma pochodni
    if(by5>15){
     
       
 
growTreeInVisibleChunks()
if (isinhouse == 1) {
  synchronizeVisibleChunks()
}

by5=0
if(isStayOn("desertsand")){
  if (Math.random() <= 0.07) {
  const slimeTypes = ['desertelemental',"desertelemental","desert"];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 9 * blockSize;
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
    if(randomSlime=="desert"){
      if(checkIfHasEnemy("desertscourgehead",3)){
        
      }else{
      createDesertScourge()
    }}else{
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=4
  }}
  spawnEnemyNearPlayer();
}
}
if(isStayOn("snowgrass")||isStayOn("snowgrass2")){
  if (Math.random() <= 0.3) {
  const slimeTypes = ['frozenghost'];
  const randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 9 * blockSize;
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=2
  }
  spawnEnemyNearPlayer();
}
}
}

updateEnemies()
updatePlayerAnimation();

if (Math.random() < 0.04 && Math.random() < 0.006 && isRaining !== false) {
  isRaining = false
} 
if (Math.random() < 0.03 && Math.random() < 0.005 && isRaining !== true) {
  isRaining = true
}
drawWeapon(ctx)
updateLightning()
updateLightning2()

if(isunderwater==0&&inabyss==0){
drawRainEffectOnBlocks(); // Rysowanie efektu deszczu
drawLightning(); // Rysowanie efektu błyskawicy
}else if(isunderwater==1){
ctx.fillStyle = `rgba(0, 125, 255, 0.45)`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}

const maxLightRadius = 150; // Maksymalny zasięg światła
const lightDecay = 0.2; // Współczynnik zmniejszania się 
if (checkIfItems("hallucinate", 1)) {
    ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.20)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    updateHealth2(-0.07);
}else{
    
if(!toggleNightVison){
chunkPositions.forEach(chunk => {
 if(isNearTorch(renderedBlocks, chunk.x, chunk.y)==true){ if(!checkIfHasEnemy("flesh",1)){
 
      }}else if(isNearTorch(renderedBlocks, chunk.x, chunk.y)==0.5){ if(!checkIfHasEnemy("flesh",1) && inhell==0){
        
        if (isunderwater == 1) {
  darknessOpacity = (nightpower / maxNightpower) - 0.4
} else {
  darknessOpacity = nightpower / maxNightpower;
}
if (generateCave == 1 || isinhouse == 1) {
  darknessOpacity = 0.98;
}

        ctx.fillStyle = `rgba(0, 0, 0, ${darknessOpacity-0.3})`;
        const adjustedX = Math.round(chunk.x);
const adjustedY = Math.round(chunk.y);
const adjustedWidth = chunk.width + 0.1;
const adjustedHeight = chunk.height + 0.135;
ctx.fillRect(adjustedX, adjustedY, adjustedWidth, adjustedHeight);
      }} else if ((!checkIfHasEnemy("flesh",1))) {
  let darknessOpacity = 0.99;
if(generateCave!==1 && isinhouse!==1 ){
  if(isunderwater==1){
darknessOpacity = (nightpower / maxNightpower)-0.4
  }else{
darknessOpacity = nightpower / maxNightpower;
}
}else{
   darknessOpacity = 0.98;
}
if(inabyss){
  darknessOpacity = 0.55;
}
if (inhell==1) {
  darknessOpacity = 0.20;
}
if(darknessOpacity > 0.96){
  darknessOpacity = 0.97;
}
if (inabyss==1 && Math.random() < 0.03) {
  ctx.fillStyle = `rgba(${Math.random()*10}, ${Math.random()*10}, ${Math.random()*10}, ${darknessOpacity + ((Math.random()*2-1)/130)})`;
}else if(isRaining && Math.random()<0.025){
        ctx.fillStyle = `rgba(0, 0, 0, ${darknessOpacity + ((Math.random()*2-1)/40)})`;
}else{
  
  ctx.fillStyle = `rgba(0, 0, 0, ${darknessOpacity})`;
  if(Math.random()<0.008){
    ctx.fillStyle = `rgba(5, 5, 5, ${darknessOpacity+ ((Math.random()*2-1)/60)})`;
  }
}
        const adjustedX = Math.round(chunk.x);
        const adjustedY = Math.round(chunk.y);
        const adjustedWidth = chunk.width+0.1; 
        const adjustedHeight = chunk.height + 0.135; 
        ctx.fillRect(adjustedX, adjustedY, adjustedWidth, adjustedHeight);
    }else{
      
    }
    if(checkIfHasEnemy("flesh",1)){
              // Zaokrąglenie pozycji chunków, aby były całkowite
     ctx.fillStyle = `rgba(5, 5, 5, ${0.3+((Math.random()*2-1)/40)})`;
        const adjustedX = Math.round(chunk.x);
        const adjustedY = Math.round(chunk.y);

        // Dodanie dodatkowych pikseli do rozmiaru, aby uniknąć przerw
        const adjustedWidth = chunk.width + 0.1; // dodanie 1 piksela do szerokości
        const adjustedHeight = chunk.height + 0.1; // dodanie 1 piksela do wysokości

        ctx.fillRect(adjustedX, adjustedY, adjustedWidth, adjustedHeight);
    }
    

});
}}
    // Aktualizacja animacji i inne logiki gry
    drawText();
    drawText2();
updateOxygen();

drawOxygenBar(ctx);
//chunkPositions.forEach(chunk => {
     // if (isNearTorch2(renderedBlocks, chunk.x, chunk.y)) {
     if (options.fancygraphic !== 0) {
       
if (inhell == 1) {
  let torchX = canvas.width / 2
  let torchY = canvas.height / 2
  const gradient = ctx.createRadialGradient(torchX, torchY, 0, torchX, torchY, maxLightRadius);
  gradient.addColorStop(0, `rgba(50, 0, 0, 0.1)`);
  gradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.0)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(torchX + 32, torchY, maxLightRadius+300 + Math.random() * 150, 0, 2 * Math.PI);
  ctx.fill();
} else if (isunderwater==0) {
  
        let torchX = (canvas.width/2)+ 15
        let torchY = ( canvas.height/2)+ 15
        const gradient = ctx.createRadialGradient(torchX, torchY, 0, torchX, torchY, maxLightRadius);
        gradient.addColorStop(0, `rgba(205, 150, 100, 0.23)`);
        gradient.addColorStop(0.5, 'rgba(205, 140, 50, 0.1)');
        gradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.0)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(torchX+32, torchY, maxLightRadius + Math.random()*150, 0, 2 * Math.PI);
        ctx.fill();
}else{
  
  if( checkIfItems("hand_torch",1) || checkIfItems("magiclanter",1)){
    
let centerX = (canvas.width / 2) + 64+32+15;
let centerY = (canvas.height / 2) + 64+32+15;
const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.sqrt(centerX * centerX + centerY * centerY));
gradient.addColorStop(0, 'rgba(10, 10, 30, 0.04)');
gradient.addColorStop(0.7, 'rgba(10, 20, 80, 0.06)');
gradient.addColorStop(1, 'rgba(10, 50, 100, 0.05)');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}

}      }
if (options.fancygraphic !== 0) {
    // Ustawienie środka ekranu jako punkt początkowy dla gradientu
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;

    // Tworzenie gradientu radialnego
    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.sqrt(centerX * centerX + centerY * centerY));
    
    
    if (!isStayOn("desertsand")) {
    if(nightpower<2 && generateCave!==1){
    gradient.addColorStop(0, 'rgba(200, 200, 200, 0.05)');
gradient.addColorStop(0.6, 'rgba(20, 20, 0, 0.05)');
gradient.addColorStop(1, 'rgba(30, 30, 30, 0.3)');
}else {
  gradient.addColorStop(0, 'rgba(20, 20, 0, 0.1)');
gradient.addColorStop(0.3, 'rgba(20, 20, 0, 0.35)');
gradient.addColorStop(1, 'rgba(30, 20, 0, 0.7)');
}

}else{
  gradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
  gradient.addColorStop(0.4, 'rgba(55, 40, 0, 0.3)');
  gradient.addColorStop(1, 'rgba(10, 10, 0, 0.9)');
}
if(inhell==1){
  gradient.addColorStop(0, 'rgba(20, 20, 0, 0.1)');
gradient.addColorStop(0.7, 'rgba(20, 20, 0, 0.35)');
gradient.addColorStop(1, 'rgba(30, 20, 0, 0.8)');
}
    // Ustawienie stylu wypełnienia na gradient
    ctx.fillStyle = gradient;

    // Rysowanie gradientu na całym canvasie
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

drawLightning2();
   // }
//});
    // Obliczanie czasu wykonania i czekanie na kolejną klatkę
    const endTime = performance.now();
    const timeTaken = endTime - startTime;
    const timeToWait = Math.max(0, frameDuration - timeTaken);

    setTimeout(function(){isUpdating = 0;update();}, frameDuration); // Wywołanie update ponownie
  }
  
}}


let hitboxShowEnabled = 0;  // Zmienna kontrolująca widoczność hitboxów
let vartt=0
// Funkcja sprawdzająca kolizję z blokami "rock"
const CcBuilder = ["stone_floor", "fiber_floor","grasslayer","yellow","violet","thistle","clayblock","clayblock1","dandelion","toadstool","sandblock2","gypsumblock","glass","fern","planks_floor","log_floor","ashblock","ashfloor","brickfloor","dirt","daffodil","flax","myosotis","fiber_floor","bed1","magnetite","nettle","stone_floor","emeraldfloor","sapphirefloor","rubyfloor","opalblock","brickfloor","gypsum_dirt","violetfloor","brickfloor2"];
let notabletoreturn987444=0
function clearCaveWallsNearEntrance(entranceX, entranceY) {
    // Definiujemy promień w blokach do przeszukania w pobliżu wejścia
    const radius = 3 * blockSize;

    // Pobieramy wszystkie chunki wokół wejścia
    for (let x = entranceX - radius; x <= entranceX + radius; x += blockSize) {
        for (let y = entranceY - radius; y <= entranceY + radius; y += blockSize) {
            // Dla każdego bloku w tym obszarze sprawdzamy typ
            if (checkBlockAtPosition(x, y, "cavewall") ||
                checkBlockAtPosition(x, y, "cave_wall") ||
                checkBlockAtPosition(x, y, "broken_cavewall")) {
                
                // Usuwamy blok, jeśli jest jednym z określonych typów
                removeBlockAtPosition(x, y, "cavewall");
                removeBlockAtPosition(x, y, "cave_wall");
                removeBlockAtPosition(x, y, "broken_cavewall");
            }
        }
    }

    // Sprawdź, czy istnieje `cave_escape` na pozycji `entranceX`, `entranceY`, jeśli nie, dodaj go
  //  const hasEscape = allCaveEntrances.some(([x, y]) => x === entranceX/32 && y === entranceY/32 && checkBlockAtPosition(x, y, "cave_escape"));
     
      if(!checkBlockAtPosition(entranceX,entranceY,"cave_escape")){
        buildBlockAtPosition(entranceX, entranceY, "cave_floor");
        buildBlockAtPosition(entranceX, entranceY, "cave_escape");
        
    }
}
function clearHellCaveWallsNearEntrance(entranceX, entranceY) {
  // Definiujemy promień w blokach do przeszukania w pobliżu wejścia
  const radius = 4 * blockSize;

  // Pobieramy wszystkie chunki wokół wejścia
  for (let x = entranceX - radius; x <= entranceX + radius; x += blockSize) {
    for (let y = entranceY - radius; y <= entranceY + radius; y += blockSize) {
      // Dla każdego bloku w tym obszarze sprawdzamy typ
      if (checkBlockAtPosition(x, y, "hellwall") ||
        checkBlockAtPosition(x, y, "hellwall") ||
        checkBlockAtPosition(x, y, "basalt")) {

        // Usuwamy blok, jeśli jest jednym z określonych typów
        removeBlockAtPosition(x, y, "hellwall");
        removeBlockAtPosition(x, y, "lava");
        removeBlockAtPosition(x, y, "hellwall");
removeBlockAtPosition(x, y, "basalt");
        removeBlockAtPosition(x, y, "moltenstone");
        buildBlockAtPosition(x, y, "hellcavestone");
      }
    }
  }



  if (!checkBlockAtPosition(entranceX, entranceY, "hell_escape")) {
    buildBlockAtPosition(entranceX, entranceY, "hellcavestone");
    buildBlockAtPosition(entranceX, entranceY, "hell_escape");

  }
}
function UNBUGclearCave(entranceX, entranceY) {
    const radius = 3 * blockSize;
    for (let x = entranceX - radius; x <= entranceX + radius; x += blockSize) {
        for (let y = entranceY - radius; y <= entranceY + radius; y += blockSize) {
if (checkBlockAtPosition(x, y, "cave_wall") ||checkBlockAtPosition(x, y, "broken_cavewall") ) {removeBlockAtPosition(x, y, "broken_cavewall");removeBlockAtPosition(x, y, "cave_wall");}
}}}
function UNBUGclearunderwaterChunk(entranceX, entranceY) {
    // Definiujemy promień w blokach do przeszukania w pobliżu wejścia
    const radius = 3 * blockSize;

    // Pobieramy wszystkie chunki wokół wejścia
    for (let x = entranceX - radius; x <= entranceX + radius; x += blockSize) {
        for (let y = entranceY - radius; y <= entranceY + radius; y += blockSize) {
            // Dla każdego bloku w tym obszarze sprawdzamy typ
            if (checkBlockAtPosition(x, y, "underwatersandblock") ||
                checkBlockAtPosition(x, y, "aquawall") ||
                checkBlockAtPosition(x, y, "aquawall")) {
                  
                removeBlockAtPosition(x, y, "underwatersandblock");
                removeBlockAtPosition(x, y, "aquawall");
                removeBlockAtPosition(x, y, "aquawall");
            }
        }}
if (!checkBlockAtPosition(entranceX, entranceY, "underwatersand")) {
  buildBlockAtPositionBefore(entranceX, entranceY, "underwatersand");
}
      if(!checkBlockAtPosition(entranceX,entranceY,"underwaterescape")){
        
        buildBlockAtPosition(entranceX, entranceY, "underwaterescape");

    }
    
}
function UNBUGclearabysschunks(entranceX, entranceY) {
    // Definiujemy promień w blokach do przeszukania w pobliżu wejścia
    const radius = 3 * blockSize;

    // Pobieramy wszystkie chunki wokół wejścia
    for (let x = entranceX - radius; x <= entranceX + radius; x += blockSize) {
        for (let y = entranceY - radius; y <= entranceY + radius; y += blockSize) {
            // Dla każdego bloku w tym obszarze sprawdzamy typ
            if (checkBlockAtPosition(x, y, "abyssblock") ) {
                removeBlockAtPosition(x, y, "abyssblock");
                removeBlockAtPosition(x, y, "abyssblock");
                
            }
        }}
      if(!checkBlockAtPosition(entranceX,entranceY,"abyssescape")){
        buildBlockAtPosition(entranceX, entranceY, "abyssfloor");
        buildBlockAtPosition(entranceX, entranceY, "abyssescape");
        
    }
}
 
let houseBlockPositions = [];  // Tablica przechowująca pozycje bloków 'door' i 'housewall'

// Funkcja do zbierania pozycji 'door' i 'housewall'
function collectHouseBlockPositions() {
  alldoors=[]
  doorsisthere=[]
  for (let block of renderedBlocks) {
    if (block.type == "door") {
  alldoors.push({ x: block.x, y: block.y })
 doorsisthere.push({ x: block.x, y: block.y })
}
if (block.type == "house_wall") {
  alldoors.push({ x: block.x, y: block.y })
}
}
}

// Funkcja do usunięcia bloków 'voidblock' w housechunks
function clearVoidBlocksInHouse() {
  for (let pos of doorsisthere) {
  if (checkBlockAtPosition(Math.floor((pos.x - offsetX) / 32) * 32, Math.floor((pos.y - offsetY) / 32) * 32, "voidblock")) {

    removeBlockAtPosition2(pos.x - offsetX, pos.y - offsetY, "voidblock");
    buildBlockAtPosition(pos.x - offsetX, pos.y - offsetY, "housegrass");
    buildBlockAtPosition(pos.x - offsetX, pos.y - offsetY, "door");
  }
}
    for (let pos of alldoors) {
        if (checkBlockAtPosition( Math.floor((pos.x-offsetX)/32)*32, Math.floor((pos.y-offsetY)/32)*32, "voidblock")) {
          
            removeBlockAtPosition2(pos.x-offsetX, pos.y-offsetY, "voidblock");
        }
    }
    
}

 var isinhill=0
 let warped=0
 function warpDimension(){
 if(inhell==1){
hellchunks = chunks
inhell = 0;
chunks = overworldChunks;  
delayChangeDimension = 1
setTimeout(function() {
    delayChangeDimension = 0
}, 5000)
overworldChunks = null; 
warped=1
delayChangeDimension = 1;
}else if(inabyss==1){
abysschunks = chunks
warped=1
inabyss = 0;
chunks = overworldChunks;  
delayChangeDimension = 1
setTimeout(function() {
    delayChangeDimension = 0
}, 5000)
overworldChunks = null; 
delayChangeDimension = 1;
}else if (isunderwater == 1) {
    seachunks = chunks
    warped = 1
    isunderwater = 0;
    chunks = overworldChunks;
    delayChangeDimension = 1
    setTimeout(function() {
        delayChangeDimension = 0
    }, 5000)
    overworldChunks = null;
    delayChangeDimension = 1;
}


 }
function checkCollisionWithRock(playerX, playerY) {
    let mercuryhurt=0;
    const collisionRadius = 28; // Promień kolizji (32 / 2)
    let collisionDetected = false;
    onbigbed=0;
for (let block of renderedBlocks) {
 if (block.type === 'mercuryliquid') {
     
    let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
    let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (hitboxShowEnabled == 1) {
        ctx.fillStyle = 'red';
        ctx.fillRect(block.x, block.y, blockSize, blockSize);
    }
    if (distance < collisionRadius) {
        mercuryhurt=1
        achievementget("Owie it hurts ;( ",0)
    }
}
  
   if (block.type === 'geyser') {
  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
  let distance = Math.sqrt(dx * dx + dy * dy);
  if (hitboxShowEnabled == 1) {
    ctx.fillStyle = 'red';
    ctx.fillRect(block.x, block.y, blockSize, blockSize);
  }
  if (distance < collisionRadius*2) {
    oxygen = Math.min(maxOxygen, oxygen + 5);
    
  }
  
  
}
if (block.type === 'moltenstone') {
  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
  let distance = Math.sqrt(dx * dx + dy * dy);
  if (hitboxShowEnabled == 1) {
    ctx.fillStyle = 'red';
    ctx.fillRect(block.x, block.y, blockSize, blockSize);
  }
  if (distance < collisionRadius ) {
    updateHealth2(-0.2)

  }


}
if (nocliping == 1 && options.noclip!==1) {
  if (block.type == 'voidblock' || block.type == 'cave_wall' || block.type == 'cavewall' || block.type == 'broken_cavewall') {

    let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
    let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);


    let distance = Math.sqrt(dx * dx + dy * dy);
    if (hitboxShowEnabled == 1) {
      ctx.fillStyle = 'red';
      ctx.fillRect(block.x, block.y, blockSize, blockSize);
    }
    if (distance < collisionRadius - 2) {
      // Jeśli kolizja, zaznacz blok na czerwono

      collisionDetected = true; // Kolizja wykryta
    }
  }
}


if (nocliping == 0 && options.noclip == 0) {
 if (!isStayOn2("hill1")) {
 isinhill = 0
 }
 if (block.type == 'hill1' && !checkIfItems("hill_climber",1)) {

  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);


  let distance = Math.sqrt(dx * dx + dy * dy);
  if (hitboxShowEnabled == 1) {
   ctx.fillStyle = 'red';
   ctx.fillRect(block.x, block.y, blockSize, blockSize);
  }
  if (distance < collisionRadius - 5) {
   let PrimoriaFaces = getFenceConnection(block.x,block.y,5)
  if( (PrimoriaFaces=="full" || PrimoriaFaces=="Cdl" || PrimoriaFaces== "Cdr" || PrimoriaFaces=="Cur" || PrimoriaFaces=="Cul" || PrimoriaFaces=="Culdr" || PrimoriaFaces=="Curdl" )  ){
   
  }else if (isinhill==0){
  
   collisionDetected = true; // Kolizja wykryta
  }else if (isinhill==1){
   
  }
 }else{
  
 }}
}

if(  options.noclip!==1 ){
  if (block.type === 'cave_wall'||block.type === 'cavewall'||block.type === 'broken_cavewall' || block.type === 'broken_cavewall') {
                  if(delayChangeDimension!==1){

          let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
          let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);


          let distance = Math.sqrt(dx * dx + dy * dy);
          if (hitboxShowEnabled == 1) {
            ctx.fillStyle = 'red';
            ctx.fillRect(block.x, block.y, blockSize, blockSize);
          }
          if (distance < collisionRadius/2.5) {
            // Jeśli kolizja, zaznacz blok na czerwono
caveChunks = chunks
showTextInCanvas("this cave is broken")
generateCave = 0;
chunks = overworldChunks; // Przywróć chunk-i świata
delayChangeDimension = 1
setTimeout(function() {
  delayChangeDimension = 0
}, 5000)
overworldChunks = null; // Wyczyść zapis
            collisionDetected = true; // Kolizja wykryta
          delayChangeDimension = 1;
        }}}
}
    if (delayChangeDimension !== 1) {
        let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
        let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 20) { // Zakładając promień kolizji 10 dla uproszczenia
            if (block.type === 'cave_entrance'||block.type === 'customcaveentrance'&& generateCave === 0) {
                const blockAbove = renderedBlocks.find(b => 
                    b.x === block.x && b.y === block.y - blockSize
                );
              if (!blockAbove || !CcBuilder.includes(blockAbove.type) ) {
                  delayChangeDimension = 1;
                    generateCave = 1;
                    overworldChunks = { ...chunks }; 
                    UNBUGclearCave(block.x,block.y)
                    chunks = caveChunks; 
                    clearCaveWallsNearEntrance(block.x, block.y);
                    return;
               }

            } else if (block.type === 'cave_escape' && generateCave === 1) {
              UNBUGclearCave(block.x,block.y)
              delayChangeDimension = 1;
                caveChunks = chunks;
                generateCave = 0;
                chunks = overworldChunks; 
                delayChangeDimension = 1;
                overworldChunks = null; 
                
                return;
            } else if (block.type === 'hell_entrance' || block.type === 'hell_entrance' && inhell === 0) {
  const blockAbove = renderedBlocks.find(b =>
    b.x === block.x && b.y === block.y - blockSize
  );
  if (!blockAbove || !CcBuilder.includes(blockAbove.type)) {
    UNBUGclearCave(block.x,block.y)
     delayChangeDimension = 1;
    generateCave = 0;
    inhell=1;
    caveChunks = { ...chunks };
    chunks = hellchunks;
    clearHellCaveWallsNearEntrance(block.x, block.y);
    
  playMusic()

    setTimeout(function (){
     
hellchunks = chunks
generateCave = 1;
inhell = 0;
chunks = caveChunks;
 

setTimeout(function (){
 
generateCave = 0;
inhell = 1;
caveChunks = { ...chunks };
chunks = hellchunks;
delayChangeDimension = 1;
clearHellCaveWallsNearEntrance(block.x, block.y);
},200)
},200)


    return;
  }

} else if (block.type === 'hell_escape' && inhell === 1) {
  delayChangeDimension = 1;
  
  hellchunks= chunks
  generateCave = 1;
  inhell=0;
  chunks = caveChunks;
  delayChangeDimension = 1;
  playMusic()
  
setTimeout(function() {
  UNBUGclearCave(block.x,block.y)
}, 200);
  return;
}
        }
    }
if (delayChangeDimension !== 1) {
  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
  let distance = Math.sqrt(dx * dx + dy * dy);

  if (distance < 5) { 
    if (block.type === 'underwaterescape' || block.type === 'underwaterentrance' && generateCave !== 1 &&    isinhouse !== 1 && inabyss !== 1 ) {
  const blockAbove = renderedBlocks.find(b =>
    b.x === block.x && b.y === block.y - blockSize // 
  );
  if (!blockAbove || !CcBuilder.includes(blockAbove.type)) {
    delayChangeDimension = 1;
    if(isunderwater==0){
    isunderwater = 1;

    overworldChunks = { ...chunks };


    chunks = seachunks;
playMusic();
   UNBUGclearunderwaterChunk(block.x,block.y)
}else{
  isunderwater = 0;
seachunks = { ...chunks };
chunks = overworldChunks;
playMusic();
}
    return;
  }

}if (block.type === 'abyssescape' || block.type === 'abyssentrance' && isinhouse !== 1 ) {
  
  const blockAbove = renderedBlocks.find(b =>
    b.x === block.x && b.y === block.y - blockSize // 
  );
  if (!blockAbove || !CcBuilder.includes(blockAbove.type)) {
    
    if (inabyss == 0) {
      delayChangeDimension = 1;
generateCave=0
UNBUGclearCave(block.x,block.y)
      caveChunks = { ...chunks };


      chunks = abysschunks;

      UNBUGclearabysschunks(block.x, block.y)
      setTimeout(function (){
        UNBUGclearabysschunks(block.x, block.y)
        
      },200);
      delayChangeDimension = 1;
      inabyss = 1;
      playMusic();
    } else {
      inabyss = 0;
generateCave=1
UNBUGclearCave(block.x,block.y)
      abysschunks = { ...chunks };
      chunks = caveChunks;
delayChangeDimension = 1;
    }
    return;
  }

}else if (block.type === 'door'||block.type === 'gypsumdoor'||block.type === 'door2' && generateCave!==1 && isinhouse==0) {
  
      const blockAbove = renderedBlocks.find(b =>
        b.x === block.x && b.y === block.y - blockSize // 
      );
      if (!blockAbove || !CcBuilder.includes(blockAbove.type)) {
        delayChangeDimension = 1;
        isinhouse = 1;
        
        overworldChunks = { ...chunks }; 
         
        
        chunks = housechunks;  
synchronizeVisibleChunks()

        showTextInCanvas("goto")

        return;
      }

    } else if (block.type === 'door'||block.type === 'door2' && generateCave!==1 && isinhouse!==0 && inabyss!==1) {
      delayChangeDimension = 1;
      housechunks = chunks;
      isinhouse = 0;
       
      chunks = overworldChunks; // Przywróć chunk-i świata
      
      delayChangeDimension = 1;
   //   overworldChunks = null; // Wyczyść zapis
      showTextInCanvas("exit")
      return;
    }
  }
}
if(delayChangeDimension == 1){
vartt++
if(vartt>5000 ){
  vartt=0
  delayChangeDimension=0
  if (currentTrack == abyssumTrack) {
  playMusic()
}
}}

if (nocliping == 0) {
    if (block.type === 'rock' || block.type === 'log0' || block.type === 'tree0' || block.type === 'house_wall'|| block.type === 'gypsumhouse' || block.type === 'voidblock' || block.type === 'empty_black_elderberry' || block.type === 'black_elderberry' || block.type === 'birch0' || block.type === 'snowpine1' || block.type === 'yew0' || block.type === 'pine0' || block.type === 'stone_wall' || block.type === 'log_wall' || block.type === 'log' || block.type === 'sapling' || block.type === 'brickwall' || block.type === 'gypsumblock' || block.type === 'planks' || block.type === 'cave_wall' || block.type === 'broken_cavewall' || block.type === 'rubyblock' || block.type === 'sapphireblock' || block.type === 'emeraldblock' || block.type === 'brickhouse' || block.type === 'underwatersandblock' || block.type === 'abyssblock' || block.type === 'stonewithgypsum' || block.type === 'cavewallwithsalt' || block.type === 'fence' || block.type === 'table' || block.type === 'lamp' || block.type === 'hellwall' || block.type === 'hellwall2' || block.type === 'basalt' || block.type === 'granite'||block.type === 'statue1_1'||block.type === 'statue2_1'
    ||block.type === 'helllog'||block.type === 'abysslog'||block.type === 'helltree0' ||block.type === 'abysstree0'||block.type === 'hellsapling'||block.type === 'abysssapling'||block.type === 'palmlog'||block.type === 'palm1'||block.type === 'palmsapling'||block.type === 'palm12'||block.type === 'can'||block.type === 'cinnabargeode'||block.type === 'fountain'||block.type === 'cauldron') {
        
        // Obliczanie prostokątów kolizji
        let playerRect = {
            x: player.x,
            y: player.y,
            width: player.width-7,
            height: player.height-7
        };

        let blockRect = {
            x: block.x,
            y: block.y,
            width: blockSize-7,
            height: blockSize-7
        };

        // Sprawdzanie kolizji prostokątów
        let collides = !(playerRect.x > blockRect.x + blockRect.width ||
                         playerRect.x + playerRect.width < blockRect.x ||
                         playerRect.y > blockRect.y + blockRect.height ||
                         playerRect.y + playerRect.height < blockRect.y);

        if (hitboxShowEnabled == 1) {
            ctx.fillStyle = 'red';
            ctx.fillRect(block.x, block.y, blockSize, blockSize);
        }

        if (collides) {
            // Jeśli kolizja, zaznacz blok na czerwono
            collisionDetected = true; // Kolizja wykryta
        }
    }
}

                
        if (block.type === 'cactus'){
                      let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
            let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);


            let distance = Math.sqrt(dx * dx + dy * dy);
            if (hitboxShowEnabled == 1) {
              ctx.fillStyle = 'red';
              ctx.fillRect(block.x, block.y, blockSize, blockSize);
            }
            if (distance < collisionRadius) {
              // Jeśli kolizja, zaznacz blok na czerwono
achievementget("Owie it hurts ;( ",0)
              updateHealth(-1)

            }
          
        }
        if (block.type === 'bed1' || block.type === 'a1bed') {
  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);


  let distance = Math.sqrt(dx * dx + dy * dy);
  if (hitboxShowEnabled == 1) {
    ctx.fillStyle = 'red';
    ctx.fillRect(block.x, block.y, blockSize, blockSize);
  }
  if (distance < collisionRadius && (isunderwater==0 && inhell==0 && inabyss==0 )  ) {
    // Jeśli kolizja, zaznacz blok na czerwono
    const playerCenterX2 = offsetX //+ canvas.width / 2 ;
const playerCenterY2 = offsetY// + canvas.height / 2 ;
if(isinhouse==1){
player.savedinworld="house"
}else{
player.savedinworld=""
}
    if(! isPlayerInWater() ){
player.spawnX = playerCenterX2;
player.spawnY = playerCenterY2;
achievementget("Time to break time", 1)
 if(langPlactive==1){
showTextInCanvas("ustawiono punkt odradzania czas pędzi")
}else{
    showTextInCanvas("spawn point set time is faster now" )
} 

    updateStamina(0.1)
    currentHP = Math.max(0, Math.min(maxHP, currentHP + 0.03));

const healthBar = document.getElementById('healthBar');
const healthPercentage = (currentHP / maxHP) * 100;
healthBar.style.width = healthPercentage + '%';
    updateDayNightCycle()
    updateDayNightCycle()
    updateDayNightCycle()
updateDayNightCycle()
  }else{
       if (langPlactive == 1) {
     showTextInCanvas("łużko na wodzie i ty niby myslisz że to zadziała :3 ")
 } else {
     showTextInCanvas("bed on water ? Bro you are thinking this will work :3 ")
 }

  }}

}   
;
if (  block.type === 'a1bed') {
  let dx = (player.x + player.width / 2) - (block.x + blockSize / 2);
  let dy = (player.y + player.height / 2) - (block.y + blockSize / 2);
  let distance = Math.sqrt(dx * dx + dy * dy);
  if (hitboxShowEnabled == 1) {
    ctx.fillStyle = 'red';
    ctx.fillRect(block.x, block.y, blockSize, blockSize);
  }
  if (distance < 15  ) {
    // Jeśli kolizja, zaznacz blok na czerwono
    if(! isPlayerInWater() ){
 
onbigbed=1;
  }else{
 

  }}else{
      
  }

}
    }
if(mercuryhurt==1){
    updateHealth2(-0.25)
}
    return collisionDetected; // Zwracamy wynik kolizji
}


let currentText = "";  // Aktualny tekst do wyświetlenia
let textTimeout = 0;   // Czas, kiedy tekst ma zniknąć
let textX = 0;         // Pozycja X tekstu
let textY = 0;         // Pozycja Y tekstu

function showTextInCanvas(text) {
    // Ustawiamy tekst i pozycję
    currentText = text;
    textX = canvas.width / 2;
    textY = canvas.height -30;

    // Ustawiamy, aby tekst zniknął za 2 sekundy
    textTimeout = performance.now() + 4000;  // Teraz + 2 sekundy
}

// Funkcja do rysowania tekstu
function drawText() {
    if (currentText !== "" && performance.now() < textTimeout) {
        // Rysowanie tekstu na canvasie, jeśli jeszcze nie wygasł czas
        ctx.font = "10px Arial";
        ctx.fillStyle = "rgb(255,255,200)";
        ctx.textAlign = "center";
        ctx.fillText(currentText, textX, textY);
    }
}


let currentText2 = "";  // Aktualny tekst do wyświetlenia
let textTimeout2 = 0;   // Czas, kiedy tekst ma zniknąć
let textX2 = 0;         // Pozycja X tekstu
let textY2 = 0;         // Pozycja Y tekstu

function showTextInCanvas2(text) {
    // Ustawiamy tekst i pozycję
    currentText2 = text;
    textX2 = 40;
textY2 =canvas.height -50;

    // Ustawiamy, aby tekst zniknął za 2 sekundy
    textTimeout2 = performance.now() + 4000;  // Teraz + 2 sekundy
}

// Funkcja do rysowania tekstu
function drawText2() {
    if (currentText2 !== "" && performance.now() < textTimeout2) {
      
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        const textMetrics = ctx.measureText(currentText2);
        const textWidth = textMetrics.width;
        const textHeight = 10;
        ctx.fillStyle = "white";
        ctx.globalAlpha = 0.3;
        ctx.fillRect(textX2 - textWidth / 2 - 5, textY2 - textHeight, textWidth + 10, textHeight + 5);
        ctx.globalAlpha = 1
        ctx.fillStyle = "black";
        ctx.fillText(currentText2, textX2, textY2);
    }
}






// Start the update loop

// Zmienne do deltaTime
let lastTime = 0;

function mainLoop(timestamp) {
    const deltaTime = timestamp - lastTime; // Obliczamy deltaTime
    lastTime = timestamp; // Ustawiamy ostatni czas na obecny timestamp
    update(deltaTime); // Przekazujemy deltaTime do update
}


setTimeout(function() {
  requestAnimationFrame(mainLoop);
}, 13000);





function singDrop(item) {
    closeInventory()
    showTextInput("type something",
        async function(text) {
    let playerX = Math.floor((offsetX + player.x) / blockSize) * blockSize;
    let playerY = Math.floor((offsetY + player.y + 1) / blockSize) * blockSize;
    switch (lastDirection) {
        case 'up':
            playerY -= blockSize;
            break;
        case 'down':
            playerY += blockSize;
            break;
        case 'left':
            playerX -= blockSize;
            break;
        case 'right':
            playerX += blockSize;
            break;
        case 'right-up':
            playerX += blockSize;
            playerY -= blockSize;
            break;
        case 'left-up':
            playerX -= blockSize;
            playerY -= blockSize;
            break;
    }
    const newBlock = {
        x: playerX / blockSize, // Skala bloków
        y: playerY / blockSize,
        type: item
    };
    const chunkKey = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;

// Jeśli chunk nie istnieje, stwórz go
if (!chunks[chunkKey]) {
    chunks[chunkKey] = [];
}

// Dodanie bloku do chunka
chunks[chunkKey].push({ x: 0, y: 0, type: item , text:text});
 
});}
function dropItemAtPlayerPosition(item) {
    // Zaokrąglij pozycję gracza do siatki bloków 32x32
    playhitmp3()
    let playerX = Math.floor((offsetX + player.x) / blockSize) * blockSize;
    let playerY = Math.floor((offsetY + player.y+1) / blockSize) * blockSize;
 

if (item == "blackberry-fruit") {
  if (currentHP > 80) {

  } else {
    updateHealth(20)
    return;
  }
}
if (item == "sing") {
    singDrop(item);
    return;
}
if (item == "stonesing") {
    singDrop(item);
    return;
}
if (item == "textstone") {
    singDrop(item);
    return;
}
if (item == "energybowl") {
  if (currentStamina > 80) {

  } else {
    updateStamina(80)
    dropItemAtPlayerPosition("bowl")
    return;
  }
}
if (item == "candy") {
  if (currentStamina > 95) {

  } else {
    updateStamina(40)
    return;
  }
}

if(item=="bread"){
  if (currentHP > 80) {
   
} else {
  updateHealth(90)
  return;
}
}
if (item == "healthbowl") {
  if (currentHP > 99) {

  } else {
    updateHealth(100)
    dropItemAtPlayerPosition("bowl")
    return;
  }
}
if (item == "soup") {
    if(options.dropany==0){
    if (currentHP > 99) {

    } else {
        updateHealth(95)
        dropItemAtPlayerPosition("bowl")
        return;
    }}
}
if (item == "coconut") {
    if(options.dropany==0){
    if (currentHP > 95) {

    } else {
        updateHealth(7)
        
        return;
    }
}}
if (item == "carrot") {
    if(options.dropany==0){
    if (currentHP > 95) {

    } else {
        updateHealth(15)
        
        return;
    }
}}
if (item == "friedegg") {
    if (currentHP > 95) {

    } else {
        updateHealth(15)

        return;
    }
}
if (item == "cigarettes") {
    if(options.dropany==0){
    issmoking=1
    cannotmove=1
    console.log(issmoking)
updateHealth(-5)
setTimeout(function (){
issmoking = 0
cannotmove = 0
},6000)
         
}}
if (item == "honey_mushrooms") {
  if (currentHP > 90) {

  } else {
    updateHealth(10)
    return;
  }
}
if (item == "cooked_bunnmeat") {
  if (currentHP > 90) {

  } else {
    updateHealth(50)
    return;
  }
}if (item == "black_elderberries") {
  if (currentHP > 95) {

  } else {
    updateHealth(5)
    return;
  }
}
if (item == "warporb") {
    if(!delayChangeDimension){
  if(options.dropany==0&&(inhell==1||inabyss==1|| isunderwater==1)){ warpDimension(); 
         if (langPlactive == 1) {
           showTextInCanvas("zostałeś przetelportowany do normalnego\n świata");
       } else {
           showTextInCanvas("you are warped to overworld dimensions ");
       }
  
  return;
  }else{
    if (langPlactive == 1) {
             showTextInCanvas("błąd nie można zmienić świata ");
         } else {
             showTextInCanvas("err cannot change dimension ");
         }
      
      
       
  }
}}
if (item == "extrabag") {
  if(options.dropany==0){
  if (slots < 9) {
slots=9
return;
  } else {
 if (langPlactive == 1) {
    showTextInCanvas("już masz dodatkowe miejsce ekwipunku ")
} else {
    showTextInCanvas("you already have extra slot")
}

  }
}}
if (item == "larger_bag") {
  if(options.dropany==0){
  if (slots < 11) {
    slots = 11
    return;
  } else {
 if (langPlactive == 1) {
     showTextInCanvas("już masz dodatkowe miejsce ekwipunku ")
 } else {
     showTextInCanvas("you already have extra slot")
 }
  }
}}
if (item == "heavybag") {
  if(options.dropany==0){
  if (slots < 16) {
    slots = 16
 if (langPlactive == 1) {
     showTextInCanvas("to maksymalna ilość slotów ile można \n mieć :)")
 } else {
     showTextInCanvas("this is max slots you can have :)")
 }
    return;
  } else {
     if (langPlactive == 1) {
     showTextInCanvas("już masz maksymalny ekwipunek ")
 } else {
     showTextInCanvas("you already have max slot")
 }
  }
}}
if (item == "cooked_thistleroot") {
  if (currentHP > 60) {

  } else {
    updateHealth(40)
    return;
  }
}
if (item == "kite") {
  if (currentHP > 90) {

  } else {
    updateHealth(15)
    return;
  }
}
if (item == "briar-fruit") {
  if (currentHP > 80) {

  } else {
    updateHealth(10)
    return;
  }
}
if (item == "bowl_with_water") {
  if (currentHP > 90) {

  } else {
    updateHealth(30)
    dropItemAtPlayerPosition("bowl")
    return;
  }
}
if (item == "leafbowlwithcleanwater") {
  if (currentHP > 90) {
  } else {
    updateHealth(20)
    dropItemAtPlayerPosition("leafbowl")
    return;
  }
}
if (item == "cooked_salmon") {
  if (currentHP > 90) {

  } else {
    updateHealth(40)
    dropItemAtPlayerPosition("bone")
    return;
  }
}
if (item == "cooked_trout") {
  if (currentHP > 90) {

  } else {
    updateHealth(30)
    dropItemAtPlayerPosition("bone")
    return;
  }
}
 if (currentHP < 95 && item=="cactus_fruit") {
  updateHealth(20)

return;
} 
    // Zmiana pozycji na podstawie ostatniego kierunku
    switch (lastDirection) {
        case 'up':
            playerY -= blockSize;
            break;
        case 'down':
            playerY += blockSize;
            break;
        case 'left':
            playerX -= blockSize;
            break;
        case 'right':
            playerX += blockSize;
            break;
        case 'right-up':
            playerX += blockSize;
            playerY -= blockSize;
            break;
        case 'left-up':
            playerX -= blockSize;
            playerY -= blockSize;
            break;
    }

if (item == "bowl_with_seawater") {
  
    addItem("bowl",1)
    item="water1"
  
}
if (item == "leafbowlwithwater") {

  addItem("leafbowl", 1)
  item = "water1"

}
if (item == "fishing_rod") {
  if(options.dropany==0){
cannotmove=1
  item = "hook"

}}
if (item == "mercurybottle") {
  if(options.dropany==0){
  item = "mercuryliquid"
  addItem("bottle",1);
}}
if (item == "itemfence") {
  if (options.dropany == 0) {
  item = "fence"
}
}
if (item == "itemroad") {
  if (options.dropany == 0) {
    item = "road"
  }
}
    // Dodanie nowego bloku z zaokrąglonymi współrzędnymi
    const newBlock = {
        x: playerX / blockSize,  // Skala bloków
        y: playerY / blockSize,
        type: item
    };
if (item == "black_elderberry_tree") {
  const newBlock1 = {
  x: playerX / blockSize, // Skala bloków
  y: playerY / blockSize,
  type: item
};
const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
if (!chunks[chunkKey1]) {
  chunks[chunkKey1] = [];
}

// Dodanie bloku do chunka
chunks[chunkKey1].push({ x: 0, y: 0, type: "black_elderberry" });
chunks[chunkKey1].push({ x: 0, y: -32, type: "black_elderberry2" });
    return;
  
}
if (item == "statue1") {
 const newBlock1 = {
  x: playerX / blockSize, // Skala bloków
  y: playerY / blockSize,
  type: item
 };
 const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
 if (!chunks[chunkKey1]) {
  chunks[chunkKey1] = [];
 }

 // Dodanie bloku do chunka
 chunks[chunkKey1].push({ x: 0, y: 0, type: "statue1_1" });
 chunks[chunkKey1].push({ x: 0, y: -32, type: "statue1_2" });
 return;

}
if (item == "statue2") {
  const newBlock1 = {
    x: playerX / blockSize, // Skala bloków
    y: playerY / blockSize,
    type: item
  };
  const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
  if (!chunks[chunkKey1]) {
    chunks[chunkKey1] = [];
  }

  // Dodanie bloku do chunka
  chunks[chunkKey1].push({ x: 0, y: 0, type: "statue2_1" });
  chunks[chunkKey1].push({ x: 0, y: -32, type: "statue2_2" });
  return;

}
if (item == "algae_item") {
 const newBlock1 = {
  x: playerX / blockSize, // Skala bloków
  y: playerY / blockSize,
  type: item
 };
 const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
 if (!chunks[chunkKey1]) {
  chunks[chunkKey1] = [];
 }

 // Dodanie bloku do chunka
 chunks[chunkKey1].push({ x: 0, y: 0, type: "algae1" });
 chunks[chunkKey1].push({ x: 0, y: -32, type: "algae0" });
 chunks[chunkKey1].push({ x: 0, y: -64, type: "algae2" });
 return;

}
if (item == "lamptorch") {
  const newBlock1 = {
    x: playerX / blockSize, // Skala bloków
    y: playerY / blockSize,
    type: item
  };
  const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
  if (!chunks[chunkKey1]) {
    chunks[chunkKey1] = [];
  }

  // Dodanie bloku do chunka
  chunks[chunkKey1].push({ x: 0, y: 0, type: "lamp" });
  chunks[chunkKey1].push({ x: 0, y: -32, type: "lamp2" });
  return;

}
if (item == "bed") {
    const newBlock1 = {
        x: playerX / blockSize, // Skala bloków
        y: playerY / blockSize,
        type: item
    };
    const chunkKey1 = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;
    if (!chunks[chunkKey1]) {
        chunks[chunkKey1] = [];
    }
    chunks[chunkKey1].push({ x: 0, y: 0, type: "a1bed" });
    chunks[chunkKey1].push({ x: 0, y: -32, type: "a2bed" });
    return;

}
    // Klucz chunka na podstawie współrzędnych bloków
    const chunkKey = `${Math.floor(newBlock.x)},${Math.floor(newBlock.y)}`;

    // Jeśli chunk nie istnieje, stwórz go
    if (!chunks[chunkKey]) {
        chunks[chunkKey] = [];
    }

    // Dodanie bloku do chunka
    chunks[chunkKey].push({x:0,y:0,type:item});
if(paused==1){
  paused=0
  update()
    paused=1
 
}
    updateInventory()
    updateCrafting()
    
}
function buildBlockAtPositionPlus(x, y, blockTypeToAdd,x2,y2) {
    let maxblocktorm = 2;
const globalX = Math.floor((x + offsetX) / 32) * 32;
const globalY = Math.floor((x + offsetX) / 32) * 32;

const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
const snappedGlobalX = snapToBlockGrid(globalX);
const snappedGlobalY = snapToBlockGrid(globalY);

// Obliczamy chunk, do którego należy ten blok
const chunkX = Math.floor(snappedGlobalX / blockSize);
const chunkY = Math.floor(snappedGlobalY / blockSize);
const chunkKey = `${chunkX},${chunkY}`;

// Obliczamy odległość od gracza (offsetX, offsetY)
const distanceFromPlayer = Math.sqrt(
    (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
);

// Sprawdzamy, czy odległość jest mniejsza niż 10 bloków
/*  if (distanceFromPlayer > 10 * blockSize) {
        return; // Jeśli blok jest poza zasięgiem, przerywamy
    }
*/
// Sprawdzenie, czy chunk istnieje
const chunkBlocks = chunks[chunkKey];
if (!chunkBlocks) {
    // Jeśli chunk nie istnieje, stwórz go
    chunks[chunkKey] = [];
}

 
chunks[chunkKey].push({
    x: Math.floor(((snappedGlobalX - (chunkX * blockSize)) / 32) * 32)+x2,
    y: Math.floor(((snappedGlobalY - (chunkY * blockSize)) / 32) * 32)+y2,
    type: blockTypeToAdd
});
 alert( chunkKey )
    updateCrafting()
}
function buildBlockAtPosition(x, y, blockTypeToAdd) {
    let maxblocktorm = 2;
    const globalX = Math.floor((x + offsetX)/32)*32;
    const globalY = Math.floor((x + offsetX)/32)*32;

    const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
    const snappedGlobalX = snapToBlockGrid(globalX);
    const snappedGlobalY = snapToBlockGrid(globalY);

    // Obliczamy chunk, do którego należy ten blok
    const chunkX = Math.floor(snappedGlobalX / blockSize);
    const chunkY = Math.floor(snappedGlobalY / blockSize);
    const chunkKey = `${chunkX},${chunkY}`;

    // Obliczamy odległość od gracza (offsetX, offsetY)
    const distanceFromPlayer = Math.sqrt(
        (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
    );

    // Sprawdzamy, czy odległość jest mniejsza niż 10 bloków
  /*  if (distanceFromPlayer > 10 * blockSize) {
        return; // Jeśli blok jest poza zasięgiem, przerywamy
    }
*/
    // Sprawdzenie, czy chunk istnieje
    const chunkBlocks = chunks[chunkKey];
    if (!chunkBlocks) {
        // Jeśli chunk nie istnieje, stwórz go
        chunks[chunkKey] = [];
    }

    // Sprawdzamy, czy w danym miejscu już istnieje blok
    const blockExists = chunkBlocks.some(block => {
        const blockGlobalX = block.x + (chunkX * blockSize);
        const blockGlobalY = block.y + (chunkY * blockSize);

        // Jeżeli już istnieje blok dirt, przerwij dodawanie nowego dirta
        if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
            if (block.type === "dirt" && blockTypeToAdd === "dirt") {
                customAlert("Nie można dodać bloku 'dirt' - już istnieje na tej pozycji.");
                return true; // Blok istnieje, a typ to 'dirt'
            }
            return true; // Blok istnieje, ale nie jest to 'dirt'
        }
        return false;
    });

    // Dodajemy nowy blok, jeśli nie ma już bloku na tych współrzędnych

        chunks[chunkKey].push({ 
            x: Math.floor(((snappedGlobalX - (chunkX * blockSize))/32)*32), 
            y: Math.floor(((snappedGlobalY - (chunkY * blockSize))/32)*32), 
            type: blockTypeToAdd 
        });
        console.log(`Dodano blok :)  ${blockTypeToAdd} na (${snappedGlobalX}, ${snappedGlobalY})`);
    
    updateCrafting()
}

function buildBlockAtPositionBefore(x, y, blockTypeToAdd) {
    let maxblocktorm = 2;
    const globalX = x + offsetX;
    const globalY = y + offsetY;

    const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
    const snappedGlobalX = snapToBlockGrid(globalX);
    const snappedGlobalY = snapToBlockGrid(globalY);

    // Obliczamy chunk, do którego należy ten blok
    const chunkX = Math.floor(snappedGlobalX / blockSize);
    const chunkY = Math.floor(snappedGlobalY / blockSize);
    const chunkKey = `${chunkX},${chunkY}`;

    // Obliczamy odległość od gracza (offsetX, offsetY)
    const distanceFromPlayer = Math.sqrt(
        (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
    );



    // Sprawdzenie, czy chunk istnieje
    let chunkBlocks = chunks[chunkKey];
    if (!chunkBlocks) {
        // Jeśli chunk nie istnieje, stwórz go
        chunks[chunkKey] = [];
        chunkBlocks = chunks[chunkKey]; // aktualizujemy odnośnik do tablicy bloków w chunku
    }

    // Sprawdzamy, czy w danym miejscu już istnieje blok
    const blockExists = chunkBlocks.some(block => {
        const blockGlobalX = block.x + (chunkX * blockSize);
        const blockGlobalY = block.y + (chunkY * blockSize);

        // Jeżeli już istnieje blok dirt, przerwij dodawanie nowego dirta
        if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
            if (block.type === "dirt" && blockTypeToAdd === "dirt") {
               // customAlert("Nie można dodać bloku 'dirt' - już istnieje na tej pozycji.");
                return true; // Blok istnieje, a typ to 'dirt'
            }
            return true; // Blok istnieje, ale nie jest to 'dirt'
        }
        return false;
    });

    // Dodajemy nowy blok na początku tablicy, jeśli nie ma już bloku na tych współrzędnych
    if ( true) {
        chunks[chunkKey].unshift({ 
            x: snappedGlobalX - (chunkX * blockSize), 
            y: snappedGlobalY - (chunkY * blockSize), 
            type: blockTypeToAdd 
        });
        console.log(`Dodano blok :) ${blockTypeToAdd} na (${snappedGlobalX}, ${snappedGlobalY}) jako pierwszy na liście.`);
    }
    updateCrafting()
}

function buildBlockAtPositionBefore2(x, y, blockTypeToAdd) {
  let maxblocktorm = 2;
  const globalX = x + offsetX;
  const globalY = y + offsetY;

  const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
  const snappedGlobalX = snapToBlockGrid(globalX);
  const snappedGlobalY = snapToBlockGrid(globalY);

  // Obliczamy chunk, do którego należy ten blok
  const chunkX = Math.floor(snappedGlobalX / blockSize);
  const chunkY = Math.floor(snappedGlobalY / blockSize);
  const chunkKey = `${chunkX},${chunkY}`;



  // Sprawdzenie, czy chunk istnieje
  let chunkBlocks = chunks[chunkKey];
  if (!chunkBlocks) {
    // Jeśli chunk nie istnieje, stwórz go
    chunks[chunkKey] = [];
    chunkBlocks = chunks[chunkKey]; // aktualizujemy odnośnik do tablicy bloków w chunku
  }

  // Sprawdzamy, czy w danym miejscu już istnieje blok
  const blockExists = chunkBlocks.some(block => {
    const blockGlobalX = block.x + (chunkX * blockSize);
    const blockGlobalY = block.y + (chunkY * blockSize);

    // Jeżeli już istnieje blok dirt, przerwij dodawanie nowego dirta
    if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
      if (block.type === "dirt" && blockTypeToAdd === "dirt") {
        // customAlert("Nie można dodać bloku 'dirt' - już istnieje na tej pozycji.");
        return true; // Blok istnieje, a typ to 'dirt'
      }
      return true; // Blok istnieje, ale nie jest to 'dirt'
    }
    return false;
  });

  // Dodajemy nowy blok na początku tablicy, jeśli nie ma już bloku na tych współrzędnych
  if (true) {
    chunks[chunkKey].unshift({
      x: snappedGlobalX - (chunkX * blockSize),
      y: snappedGlobalY - (chunkY * blockSize),
      type: blockTypeToAdd
    });
    console.log(`Dodano blok :) ${blockTypeToAdd} na (${snappedGlobalX}, ${snappedGlobalY}) jako pierwszy na liście.`);
  }
}
function buildBlockAtPosition(x, y, blockTypeToAdd) {
  let maxblocktorm = 0;
  const globalX = x + offsetX;
  const globalY = y + offsetY;

  const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
  const snappedGlobalX = snapToBlockGrid(globalX);
  const snappedGlobalY = snapToBlockGrid(globalY);

  // Obliczamy chunk, do którego należy ten blok
  const chunkX = Math.floor(snappedGlobalX / blockSize);
  const chunkY = Math.floor(snappedGlobalY / blockSize);
  const chunkKey = `${chunkX},${chunkY}`;

  // Obliczamy odległość od gracza (offsetX, offsetY)
  const distanceFromPlayer = Math.sqrt(
    (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
  );

 
  // Sprawdzenie, czy chunk istnieje
  const chunkBlocks = chunks[chunkKey];
  if (!chunkBlocks) {
    // Jeśli chunk nie istnieje, stwórz go
    chunks[chunkKey] = [];
  }


  // Dodajemy nowy blok, jeśli nie ma już bloku na tych współrzędnych

  chunks[chunkKey].push({ x: snappedGlobalX - (chunkX * blockSize), y: snappedGlobalY - (chunkY * blockSize), type: blockTypeToAdd });
  console.log(`Dodano blok :)  ${blockTypeToAdd} na (${snappedGlobalX}, ${snappedGlobalY})`);

}
function removeBlockAtPosition2(x, y, blockTypeToRemove) {
  let maxblocktorm = 0
const globalX = x + offsetX;
const globalY = y + offsetY;

const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
const snappedGlobalX = snapToBlockGrid(globalX);
const snappedGlobalY = snapToBlockGrid(globalY);

// Obliczamy chunk, do którego należy ten blok
const chunkX = Math.floor(snappedGlobalX / blockSize);
const chunkY = Math.floor(snappedGlobalY / blockSize);
const chunkKey = `${chunkX},${chunkY}`;

// Obliczamy odległość od gracza (offsetX, offsetY)
const distanceFromPlayer = Math.sqrt(
  (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
);

 
// Sprawdzenie czy chunk istnieje
const chunkBlocks = chunks[chunkKey];
if (!chunkBlocks) return; // Jeśli chunk nie istnieje, przerywamy

// Szukamy konkretnego bloku w chunku
const blockToRemove = chunkBlocks.find(block => {
  const blockGlobalX = block.x + (chunkX * blockSize);
  const blockGlobalY = block.y + (chunkY * blockSize);

  return (
    blockGlobalX === snappedGlobalX &&
    blockGlobalY === snappedGlobalY &&
    block.type === blockTypeToRemove
  );
});

// Jeśli znaleziono blok, usuwamy go
if (blockToRemove) {
  const index = chunkBlocks.indexOf(blockToRemove);
  if (index > -1) {

    if (maxblocktorm < 1) {
      chunkBlocks.splice(index, 1);

    }
    maxblocktorm++
    console.log(`Usunięto blok: ${blockToRemove.type} na (${snappedGlobalX}, ${snappedGlobalY})`);
  }
}
}
function removeBlockAtPosition(x, y, blockTypeToRemove) {
  playcollectsound()
  let maxblocktorm=0
    const globalX = x + offsetX;
    const globalY = y + offsetY;

    const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
    const snappedGlobalX = snapToBlockGrid(globalX);
    const snappedGlobalY = snapToBlockGrid(globalY);

    // Obliczamy chunk, do którego należy ten blok
    const chunkX = Math.floor(snappedGlobalX / blockSize);
    const chunkY = Math.floor(snappedGlobalY / blockSize);
    const chunkKey = `${chunkX},${chunkY}`;

    // Obliczamy odległość od gracza (offsetX, offsetY)
    const distanceFromPlayer = Math.sqrt(
  (snappedGlobalX - offsetX) ** 2 + (snappedGlobalY - offsetY) ** 2
);

// Sprawdzamy, czy odległość jest mniejsza niż 10 bloków
 



    // Sprawdzenie czy chunk istnieje
    const chunkBlocks = chunks[chunkKey];
    if (!chunkBlocks) return;  // Jeśli chunk nie istnieje, przerywamy

    // Szukamy konkretnego bloku w chunku
    const blockToRemove = chunkBlocks.find(block => {
        const blockGlobalX = block.x + (chunkX * blockSize);
        const blockGlobalY = block.y + (chunkY * blockSize);

        return (
            blockGlobalX === snappedGlobalX &&
            blockGlobalY === snappedGlobalY &&
            block.type === blockTypeToRemove
        );
    });

    // Jeśli znaleziono blok, usuwamy go
    if (blockToRemove) {
        const index = chunkBlocks.indexOf(blockToRemove);
        if (index > -1) {
          
          if(maxblocktorm<1){
            chunkBlocks.splice(index, 1);
            
          }
          maxblocktorm++
            console.log(`Usunięto blok: ${blockToRemove.type} na (${snappedGlobalX}, ${snappedGlobalY})`);
        }
    }
}



function setblockatposition(x, y, blockTypeToSet) {
    const globalX = x + offsetX;
    const globalY = y + offsetY;

    const snapToBlockGrid = (value) => Math.floor(value / blockSize) * blockSize;
    const snappedGlobalX = snapToBlockGrid(globalX);
    const snappedGlobalY = snapToBlockGrid(globalY);

    // Obliczamy chunk, do którego należy ten blok
    const chunkX = Math.floor(snappedGlobalX / blockSize);
    const chunkY = Math.floor(snappedGlobalY / blockSize);
    const chunkKey = `${chunkX},${chunkY}`;

    // Sprawdzamy, czy chunk istnieje
    const chunkBlocks = chunks[chunkKey];
    if (!chunkBlocks) {
        console.log(`Chunk ${chunkKey} nie istnieje.`);
        return; // Jeśli chunk nie istnieje, przerywamy
    }

    // Usuwamy wszystkie bloki w chunku
    chunkBlocks.length = 0; // Usunięcie wszystkich bloków w chunku

    // Dodajemy nowy blok na pozycji (0, 0) w chunku
    chunkBlocks.push({ x: 0, y: 0, type: blockTypeToSet });
    console.log(`Dodano blok: ${blockTypeToSet} na (${chunkX}, ${chunkY})`);
}

function removeTree(x, y) {
    // Usunięcie tree0
    setblockatposition(x, y, "grass");
    // Usunięcie tree1 (blok nad tree0)
   
}

function igniteFiberAround(x, y, radius = 64) {
    // Przeglądamy otaczające bloki w promieniu radius
    for (let dx = -radius; dx <= radius; dx += blockSize) {
        for (let dy = -radius; dy <= radius; dy += blockSize) {
            const newX = x + dx;
            const newY = y + dy;
            
            // Sprawdź, czy blok w tej pozycji to "fiber"
            if (checkBlockAtPosition(newX, newY, "fiber")) {
                // Usuń blok "fiber"
                removeBlockAtPosition(newX, newY, "fiber");
                
                // Zamień na "ignited_fiber"
                buildBlockAtPosition(newX, newY, "ignited_fiber");
                return;
            }else{
  if (langPlactive == 1) {
         showTextInCanvas("nie ma tu żadnego włókna obok pługu ogniowego")
     } else {
         showTextInCanvas("there is no placed fiber around this friction kit")
     }
              
            }
        }
    }
}
 
var curseofgos=0
function removeBatAtPosition(x, y) {
  const weapon = checkIfPlayerHasAnyWeapon(); // tutaj możesz sprawdzić, jaką broń ma gracz
  let playerCenterX = player.x + offsetX + player.width * 2;
let playerCenterY = player.y + offsetY + player.height * 2;
playerCenterX -= 32 + 32;
playerCenterY -= 32 + 33;

  
  if (!weapon) return; 
  const range = itemsAndDamage[weapon].range; 
 renderedEnemies.forEach(enemy => {
      const dx = x - (enemy.x + enemy.width) + offsetX;
      const dy = y - (enemy.y + enemy.height) + offsetY;
      const distanceClick = Math.sqrt(dx * dx + dy * dy);
      const distanceFromPlayer = Math.sqrt(
        (enemy.x - playerCenterX) ** 2 + (enemy.y - playerCenterY) ** 2
      );
      if (distanceClick <= range && distanceFromPlayer <= range && enemy.hp<(9999*99)) {
let slashsound6 = new Audio();
slashsound6.src = hitenemysound.src
slashsound6.volume = 0.25;
slashsound6.play();
}});
 if(weapon=="godwand"){
    updateStamina(-1)
  const typesof = ["godmagic"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle + Math.random()*0.5-0.25; bat.width=32;bat.height=32; ;renderedEnemies.push(bat); bat.speed=4
  } for (let i = 0; i < 30; i++) {
  setTimeout(function() {
    spawnEnemyNearPlayer();
  }, i * 25);
}}else if(weapon=="hyperblastwand"){
updateStamina(-10)
  const typesof = ["hyperblast"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32;bat.height=32; ;renderedEnemies.push(bat); bat.speed=4
  } for (let i = 0; i < 20; i++) {
  setTimeout(function() {
    spawnEnemyNearPlayer();
  }, i * 45);
}

}else if(weapon=="magicwandofsharp"){
    updateStamina(-5)
  const typesof = ["magicsharp"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle ;renderedEnemies.push(bat); bat.speed=4
  } spawnEnemyNearPlayer();
} else if(weapon=="magicwand"){
    updateStamina(-3)
  const typesof = ["magic"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle ;renderedEnemies.push(bat); bat.speed=4
  } spawnEnemyNearPlayer();
}else if(weapon=="greenwand"){
    updateStamina(-5)
  const typesof = ["greenmagic"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer(dx,dy) {
    const enemyX = playerCenterX+dx; const enemyY = playerCenterY+dy;
    const spellangle = Math.atan2((enemyY - (playerCenterY)), (enemyX - (playerCenterX)));
    let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle ;renderedEnemies.push(bat); bat.speed=4
  } spawnEnemyNearPlayer(32,0); spawnEnemyNearPlayer(-32,0); spawnEnemyNearPlayer(0,32);spawnEnemyNearPlayer(0,-32); spawnEnemyNearPlayer(32,-32); spawnEnemyNearPlayer(32,32); spawnEnemyNearPlayer(-32,-32); spawnEnemyNearPlayer(-32,32);
}else if(weapon=="boomerang"){
    if(weponDelay<2){
        weponDelay=10
updateStamina(-2)
  const typesof = ["boomerang"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
  }  
    spawnEnemyNearPlayer();
    
    }}else if(weapon=="bow"){
    if(weponDelay<2){
        
updateStamina(-2)
let boostatk=0
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=6
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
        
    }}else if(weapon=="nightbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=25
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
    boostatk+=5
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=6
    boostatk+=16
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="darkbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=40
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
    boostatk+=5
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=6
    boostatk+=20
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="quantumbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=60
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=2
    boostatk+=40
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=6
    boostatk+=30
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="hellbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=60
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
    boostatk+=25
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=6
    boostatk+=30
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="rainbowbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=200
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
    boostatk+=30
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=3
    boostatk+=30
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="moltenbow"){
    if(weponDelay<2){
         
updateStamina(-2);

let boostatk=140
if(options.dropany==0){
if(checkIfItems("goodarrows",1)){
    useItemDurability2(-1,"goodarrows")
    weponDelay=8
    boostatk+=25
  const typesof = ["goodarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("powerfullarrows",1)){
    useItemDurability2(-1,"powerfullarrows")
    weponDelay=3
    boostatk+=30
  const typesof = ["powerfullarrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }else if(checkIfItems("arrows",1)){
    useItemDurability2(-1,"arrows")
    weponDelay=10
  const typesof = ["arrow"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
    bat.atkplus=boostatk
  }  
    spawnEnemyNearPlayer();
    
    }
        
    }}
        
    }else if(weapon=="titanium_boomerang"){
    if(weponDelay<2){
        weponDelay=6
updateStamina(-2)
  const typesof = ["titanium_boomerang"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
  }  
    spawnEnemyNearPlayer();
    
    }}else if(weapon=="good_boomerang"){
    if(weponDelay<2){
        weponDelay=6
updateStamina(-2)
  const typesof = ["good_boomerang"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
  }  
    spawnEnemyNearPlayer();
    
    }
}else if(weapon=="hell_boomerang"){
    if(weponDelay<2){
        weponDelay=4
updateStamina(-2)
  const typesof = ["hell_boomerang"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
  }  
    spawnEnemyNearPlayer();
    
    }
}else if(weapon=="draco_boomerang"){
    if(weponDelay<2){
        weponDelay=4
updateStamina(-1)
  const typesof = ["draco_boomerang"];
  const randomSpell = typesof[Math.floor(Math.random() * typesof.length)];function spawnEnemyNearPlayer() {
    const enemyX = playerCenterX; const enemyY = playerCenterY;const spellangle = Math.atan2((y - (playerCenterY - offsetY)), (x - (playerCenterX - offsetX))); let bat = new Enemy(enemyX, enemyY, randomSpell); bat.angle = spellangle; bat.width=32+16;bat.height=32+16; ;renderedEnemies.push(bat); bat.speed=5
  }  
    spawnEnemyNearPlayer();
    
    }
}

  if (cooldownatk==false) {
    handleWeaponUse(weapon,x,y)
  attackEnemyAtPosition(x, y)
  }
}
function checkIfPlayerHasAnyWeapon() {
  for (const weapon in itemsAndDamage) {
    if (checkIfItems(weapon, 1)) {
      return weapon; // Zwraca nazwę broni, którą posiada gracz
    }
  }
  return null; // Jeśli gracz nie posiada żadnej broni
}
 
function attackEnemyAtPosition(x, y) {
  let playerCenterX = player.x + offsetX + player.width * 2;
  let playerCenterY = player.y + offsetY + player.height * 2;
  playerCenterX -= 32 + 32;
  playerCenterY -= 32 + 33;

  const weapon = checkIfPlayerHasAnyWeapon();
  if (!weapon) return; // Nie wykonujemy ataku, jeśli brak broni
  
  const range = itemsAndDamage[weapon].range; // Pobranie zasięgu broni
let fddg=0


  renderedEnemies = renderedEnemies.filter(enemy => {
    const dx = x - (enemy.x + enemy.width) + offsetX;
    const dy = y - (enemy.y + enemy.height) + offsetY;
    const distanceClick = Math.sqrt(dx * dx + dy * dy);

    const distanceFromPlayer = Math.sqrt(
      (enemy.x - playerCenterX) ** 2 + (enemy.y - playerCenterY) ** 2
    );

    // Sprawdzenie, czy wróg jest w zasięgu ataku
    if (distanceClick <= range && distanceFromPlayer <= range) {
      
      if(enemy.hp<9999*9999){
      fddg=1
}
      if (checkIfItems(weapon, 1) && !itemsAndDamage[weapon].kill.includes(enemy.type)) {
        updateStamina(-0.5)
        enemy.hp -= itemsAndDamage[weapon].dmg;

      } else {
 if (langPlactive == 1) {
    showTextInCanvas("ta broń nie działa na : " + enemy.type);
} else {
    showTextInCanvas("current weapon doesn't work on this enemy: " + enemy.type);
}
        
      }
      
      
    }else{
      
    }

        if (enemy.hp <= 0) {
          updateStamina(-1.5); 
          if(enemy.type=="spikegod"){
            let r = Math.floor((dx + player.x * 32) / 32)
let r2 = Math.floor((dy + player.y * 32) / 32)
        //    buildBlockAtPosition(r,r2,"titaniumbar")
            
             
             achievementget("No you're not a god ", 1)
             
            
            if(Math.random()<0.65){
              buildBlockAtPosition(r,r2,"nightgem")
            buildBlockAtPosition(r,r2,"evilsummoner")
            
            }else{
              buildBlockAtPosition(r, r2, "nightgem")
              buildBlockAtPosition(r,r2,"aquaticevent")
            }
            
            
            curseofgos=1
if (langPlactive == 1) {
    showTextInCanvas("dostałeś klątwę gos ...")
} else {
    showTextInCanvas("now after killing gos has a curse . .")
}
        
            
          }
if (enemy.type == "2medusa") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  buildBlockAtPosition(r, r2, "titaniumbar")
  playRandomMusic()
  achievementget("You beat it! <span style='color:cyan' > Aquatic Event</span>",2)
  if (Math.random() < 0.15) {
    showTextInCanvas("soul of sharp is rare item just try again ")
  } else {
    buildBlockAtPosition(r, r2, "soulofsharp")
  }
}
if (enemy.type == "flesher") {
    let r = Math.floor((dx + player.x * 32) / 32)
    let r2 = Math.floor((dy + player.y * 32) / 32)

    if (Math.random() < 0.021) {
        buildBlockAtPosition(r, r2, "titaniumbar")
        buildBlockAtPosition(r, r2, "hellessence")

    } else if (Math.random() < 0.021) {
        buildBlockAtPosition(r, r2, "hellgem")
    } else if (Math.random() < 0.020) {
        buildBlockAtPosition(r, r2, "warporb")
    }
}
if (enemy.type == "hellskull") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  
  if (Math.random() < 0.005) {
    buildBlockAtPosition(r, r2, "titaniumbar")
    buildBlockAtPosition(r, r2, "hellessence")
    achievementget("The fragment of hell", 1)
  }else if (Math.random() < 0.030) {
  buildBlockAtPosition(r, r2, "hellgem")
}else if (Math.random() < 0.015) {
    buildBlockAtPosition(r, r2, "warporb")
} else {
    if (Math.random() < 0.5) {
  const slimeTypes = ['flesher'];
  let randomSlime = slimeTypes[Math.floor(Math.random() * slimeTypes.length)];
  const spawnDistance = 9 * blockSize;
  let enemyY; let enemyX;
  function spawnEnemyNearPlayer() {
if (Math.random() >= 0.3) { enemyX = offsetX + spawnDistance;  } else { enemyX = offsetX;}
if (Math.random() >= 0.3) {enemyY = offsetY + spawnDistance; } else { enemyY = offsetY; }
    let bat = new Enemy(enemyX, enemyY, randomSlime);
    renderedEnemies.push(bat);
    bat.speed=4.2
  }
 spawnEnemyNearPlayer();
}
  }
}
if (enemy.type == "flesh") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  buildBlockAtPosition(r, r2, "voltary_essence")
    buildBlockAtPosition(r, r2, "fleshvolume")
    playRandomMusic();
    achievementget("The flesh ", 1)
  
}
if (enemy.type == "soulcat") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  if(Math.random()<0.2){
  buildBlockAtPosition(r, r2, "abyssgem")
  }  if (Math.random() < 0.005) {
    buildBlockAtPosition(r, r2, "warporb")
}
}
if (enemy.type == "frozenghost") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  if (Math.random() < 0.18) {
    buildBlockAtPosition(r, r2, "frozeningot")
  }
  if (Math.random() < 0.02) {
  buildBlockAtPosition(r, r2, "magicgem");
}
}
if (enemy.type == "insaneuniversegod") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  buildBlockAtPosition(r, r2, "universefragment")
  playRandomMusic();
  achievementget("Killed Universe !", 1)
}
if (enemy.type == "aquagod") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  buildBlockAtPosition(r, r2, "aquacore")
  achievementget("<span style='color:coral' >Gg Aquamarine..  </span>",2)
  if(Math.random()<0.5){
    
  }else{
    buildBlockAtPosition(r, r2, "aquacore")
  }
}
          if (enemy.type == "greenslime"||enemy.type == "blueslime"||enemy.type == "pinkslime") {
            let r = Math.floor((dx + player.x * 32) / 32)
            let r2 = Math.floor((dy + player.y * 32) / 32)
            if(Math.random()<0.3){
            buildBlockAtPosition(r, r2, "gel")
            achievementget("Something sticky is here ?", 0)
          }}
          if(enemy.type=="bunny"){
            let r = Math.floor((dx+player.x*32) /32)
            let r2 = Math.floor((dy+player.y*32) /32)
            if(Math.random()<0.8){
                achievementget("Bunny meat", 0)
            buildBlockAtPosition(r,r2,"bunnmeat")
          }}
if (enemy.type == "voltary") {
  let r = Math.floor((dx + player.x * 32) / 32)
let r2 = Math.floor((dy + player.y * 32) / 32)
 // buildBlockAtPosition(r, r2, "anvil")
 achievementget("First but not he last", 1)
 if (Math.random() < 0.6) {
  buildBlockAtPosition(r, r2, "voltary_essence")
}
if (Math.random() < 0.2) {
  buildBlockAtPosition(r, r2, "nightgem")
}
  buildBlockAtPosition(r, r2, "spikegod_essence")
  
   if(Math.random()<0.11){
     buildBlockAtPosition(r, r2, "thundersword")
   }
   if (Math.random() < 0.2) {
  buildBlockAtPosition(r, r2, "healthregenerator");
   }
   if(curseofgos==1){
       if (langPlactive == 1) {
    showTextInCanvas("usunięto klątwę gos ...")
} else {
    showTextInCanvas(" magically removed gos curse ")
}
     
   }
  curseofgos=0
  
}
if (enemy.type === "duck" && enemy.hp <= 0) {
    let r = Math.floor((dx + player.x * 32) / 32)
    let r2 = Math.floor((dy + player.y * 32) / 32)
    
if (Math.random() < 0.4) {
        buildBlockAtPosition(r, r2, "eggs");
}if (Math.random() < 0.2) {
    buildBlockAtPosition(r, r2, "eggshells");
}if (Math.random() < 0.4) {
    buildBlockAtPosition(r, r2, "feather");
}if (Math.random() < 0.2) {
    buildBlockAtPosition(r, r2, "rarefeather");
}if (Math.random() < 0.03) {
    buildBlockAtPosition(r, r2, "mythicfeather");
    achievementget("Ohh shiny feather", 0)
}

}

if (enemy.type === "raven" && enemy.hp <= 0) {
    let r = Math.floor((dx + player.x * 32) / 32)
    let r2 = Math.floor((dy + player.y * 32) / 32)
if (Math.random() < 0.4) {
        buildBlockAtPosition(r, r2, "eggs");
}if (Math.random() < 0.4) {
    buildBlockAtPosition(r, r2, "eggshells");
}if (Math.random() < 0.4) {
    buildBlockAtPosition(r, r2, "feather");
}if (Math.random() < 0.2) {
    buildBlockAtPosition(r, r2, "rarefeather");
}if (Math.random() < 0.2) {
    buildBlockAtPosition(r, r2, "mythicfeather");
}

}
// Kiedy głowa zostaje pokonana
if (enemy.type === "trueuniversehead" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
let r2 = Math.floor((dy + player.y * 32) / 32)
if (Math.random() < 0.3) {
    buildBlockAtPosition(r, r2, "universefragment");

}
  buildBlockAtPosition(r, r2, "trueuniverseorb");
  
  buildBlockAtPosition(r, r2, "statueofgods");
playRandomMusic();
achievementget("<span style='color: crimson;' > End Of The World </span>", 1)
  setTimeout(function() {
      
      
   if (langPlactive == 1) {
showTextInCanvas("to koniec..");

playRandomMusic();
setTimeout(function() {
    showTextInCanvas("ty graczu . ");
    setTimeout(function() {
        showTextInCanvas(" przeszedłeś tą grę");
        setTimeout(function() {
            showTextInCanvas("wspaniale choć to nie koniec");
            setTimeout(function() {
                showTextInCanvas("mam w planach dodać więcej rzeczy do tej gry");
                setTimeout(function() {
                    showTextInCanvas("więc możesz poczekać ");
setTimeout(function() {
    showTextInCanvas2("gra zrobiona przez : kashumy/Krystian");
}, 5000);
                }, 3000);
            }, 3000);
        }, 6000);
    }, 3000);
}, 3000);
       } else {
showTextInCanvas("that's it ..");

playRandomMusic();
setTimeout(function() {
showTextInCanvas("you . player ");
setTimeout(function() {
    showTextInCanvas(" beat this game.");
    setTimeout(function() {
        showTextInCanvas("its really awesome ! ... but this isn't end ");
        setTimeout(function() {
            showTextInCanvas("i will add more stuffs to this game ");
            setTimeout(function() {
                showTextInCanvas("so .. wait and enjoy ");
 setTimeout(function() {
    showTextInCanvas2("game created by : kashumy/Krystian");
}, 5000);
            }, 3000);
        }, 3000);
    }, 6000);
}, 3000);
}, 3000);

       }
  }, 3000);

  // Usuń wszystkie segmenty robaka
  renderedEnemies = renderedEnemies.filter(e => e.type !== "trueuniversebody");
  renderedEnemies = renderedEnemies.filter(e => e !== enemy); // Usuń głowę
  
}
if (enemy.type === "abyssdevourerhead" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
let r2 = Math.floor((dy + player.y * 32) / 32)
  if (Math.random() < 0.015) {
    buildBlockAtPosition(r, r2, "warporb")
}
  if (Math.random() < 0.05) {
    buildBlockAtPosition(r, r2, "abysscore");
  }
  if (Math.random() < 0.010) {
  buildBlockAtPosition(r, r2, "healmedalion");
}}
if (enemy.type === "desertelemental" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)

  if (Math.random() < 0.010) {
    buildBlockAtPosition(r, r2, "magicgem");
  }
  if (Math.random() < 0.03) {
    buildBlockAtPosition(r, r2, "desertcore");
  }
  if (Math.random() < 0.03) {
  buildBlockAtPosition(r, r2, "healthregenerator");
}
}
if (enemy.type === "desertscourgehead" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
 
  if (Math.random() < 0.04) {
    buildBlockAtPosition(r, r2, "speedmedalion");
  }
  if (Math.random() < 0.06) {
  buildBlockAtPosition(r, r2, "desertcore");
}
  return true;

  renderedEnemies = renderedEnemies.filter(e => e.type !== "desertscourgebody");
  renderedEnemies = renderedEnemies.filter(e => e !== enemy); // Usuń głowę

}
if (enemy.type === "deepgodhead" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  playRandomMusic();
  if (Math.random() < 0.8) {
    buildBlockAtPosition(r, r2, "aquagem");
    buildBlockAtPosition(r, r2, "coloressence")
  }
  if (Math.random() < 0.5) {
  buildBlockAtPosition(r, r2, "aquagem");
}
if (Math.random() < 0.5) {
  buildBlockAtPosition(r, r2, "aquagem");
}
  return true;
  renderedEnemies = renderedEnemies.filter(e => e.type !== "deepgodtorso");
  renderedEnemies = renderedEnemies.filter(e => e !== enemy);
}
if (enemy.type === "hellscourgehead" && enemy.hp <= 0) {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)

  if (Math.random() < 0.005) {
    buildBlockAtPosition(r, r2, "iron_bar");
  }
  if (Math.random() < 0.015) {
  buildBlockAtPosition(r, r2, "hellessence");
}
if (Math.random() < 0.02) {
  buildBlockAtPosition(r, r2, "bone");
}
  if (Math.random() < 0.003) {
    buildBlockAtPosition(r, r2, "speedmedalion");
  }
  return true;

  renderedEnemies = renderedEnemies.filter(e => e.type !== "hellscourgebody");
  renderedEnemies = renderedEnemies.filter(e => e !== enemy); // Usuń głowę

}

if (enemy.type == "darkeye") {
  let r = Math.floor((dx + player.x * 32) / 32)
  let r2 = Math.floor((dy + player.y * 32) / 32)
  // buildBlockAtPosition(r, r2, "anvil")
  playRandomMusic()
  achievementget("<span style='color:red' > Evil is evil </span>",2)
   if (Math.random() < 0.2) {
  buildBlockAtPosition(r, r2, "nightgem")
}
  if (Math.random() < 0.7) {
    buildBlockAtPosition(r, r2, "evileye")
    
  }else{
    buildBlockAtPosition(r, r2, "nightgem")
    nightpower=1
    showTextInCanvas(" evil eye is rare try again")
  }
  //curseofgos = 0
}
          return false; // Usuwa wroga z ekranu
        }
    
    return true; // Wróg zostaje na ekranie
  });
  if(fddg==0){
    if(!(weapon=="magicwand"||weapon=="greenwand"||weapon=="magicwandofsharp"||weapon=="hyperblastwand"||weapon=="godwand"  ||weapon=="boomerang"||weapon=="titanium_boomerang"||weapon=="good_boomerang" ||weapon=="hell_boomerang"||weapon=="draco_boomerang"||weapon=="bow"||weapon=="hellbow"||weapon=="darkbow"||weapon=="nightbow"||weapon=="moltenbow"||weapon=="rainbowbow"||weapon=="quantumbow")){
    playslash2()
  }}
}


// Obiekt przechowujący stany bloków
const floorblocks = ["stone_floor", "fiber_floor", "grasslayer", "yellow", "violet", "clayblock", "clayblock1", "dandelion", "toadstool", "sandblock2", "gypsumblock", "glass", "fern", "planks_floor", "log_floor", "ashblock", "ashfloor", "brickfloor", "daffodil","flax","myosotis" ,"fiber_floor", "bed1", "magnetite", "nettle", "stone_floor", "emeraldfloor", "sapphirefloor", "rubyfloor", "clayblock1", "clayblock","violetfloor","grass","toadstool","stones","thistle","ryeroof","houseroof","housewall","brickhouse","gelblock","gypsum_dirt","roadfloor","brickfloor2","road","deadgrassfloor2","grass2","forestgrasslayer","deadgrassfloor2","deadgrassfloor","forestgrass","forestgrasslayer","hill1","climbhill","gypsumroof","gypsumhouse","gypsumdoor","polishedfloor","snowgrass2","snowgrass"];
 
function deleteFromChunk(x, y, types) {
  
  const globalX = x + offsetX;
  const globalY = y + offsetY;
  const snappedGlobalX = Math.floor(globalX / blockSize) * blockSize;
  const snappedGlobalY = Math.floor(globalY / blockSize) * blockSize;
  const chunkX = Math.floor(snappedGlobalX / blockSize);
  const chunkY = Math.floor(snappedGlobalY / blockSize);
  const chunkKey = `${chunkX},${chunkY}`;
  let chunkBlocks = chunks[chunkKey];
  if (!chunkBlocks) return;  
  for (let i = chunkBlocks.length - 1; i >= 0; i--) {
    let block = chunkBlocks[i];
    if (types.includes(block.type)) {
      chunkBlocks.splice(i, 1);   
    }
  }
}


function isBlockFloor(x, y) {
 //   const blockType = getBlockTypeAtPosition(x, y); 
    
    if (options.dontbreakfloor === 1) {
 
        
        return floorblocks.includes(blockType); 
    }
    
 
    
    
    return false;  
}


function getBlockTypeAtPosition(x, y) {

    }
 var VISIBLEIDS=[]
let Delay=0


let touchTD;

function process_target(e){
  e.preventDefault()
    if(Delay==1){
    return;
  }
Delay = 1
setTimeout(function() {
  Delay = 0
}, 500)
  if(!(checkIfHasEnemy("trueuniversehead",1))&&!(checkIfHasEnemy("deepgodhead",1))&&!(checkIfHasEnemy("flesh",1))&&!(checkIfHasEnemy("insaneuniversegod",1)) &&!(checkIfHasEnemy("2medusa",1)) &&!(checkIfHasEnemy("darkeye",1)) ){
       if (!currentTrack || currentTrack.paused) {
      playMusic();

    }

      if (((isStayOn("grass") || isStayOn("water")) && !isStayOn("snowgrass") &&!isStayOn("snowgrass2")) && isPlayingDesertMusic || isPlayingSnowyMusic) {
        stopDesertMusic();
      }
      if (isStayOn("water") && isPlayingSnowyMusic) {
        stopSnowyMusic();
      }
      if (isStayOn("desertsand") || isStayOn("snowgrass") ||isStayOn("snowgrass2")) {
        checkPlayerOnDesertSand();
      }
  }else{
stopDesertMusic(); stopSnowyMusic();
  }
let scaledX = 0
let scaledY = 0
/*
zapobiega nadpisaniu eventu następnym eventem lol
*/
if (e.changedTouches) {
    for (let i = 0; i < e.changedTouches.length; i++) {
    const touch = e.changedTouches[i];
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    if (touch.clientX && touch) {
        scaledX = (touch.clientX - rect.left) * scaleX + 15 - zoomedDELTA / 3; // Upewnij się, że dodanie 15 jest zamierzone
        scaledY = (touch.clientY - rect.top) * scaleY + 15 - zoomedDELTA / 3;
    }
    console.log(`Scaled X: ${scaledX}, Scaled Y: ${scaledY}`);
}
} else {
    const rect = canvas.getBoundingClientRect();
    scaledX = (e.clientX - rect.left) * (canvas.width / rect.width) + 15 - zoomedDELTA / 3;
    scaledY = (e.clientY - rect.top) * (canvas.height / rect.height) + 15 - zoomedDELTA / 3;
    console.log(`Scaled X: ${scaledX}, Scaled Y: ${scaledY}`);
}
     
     
    
    
  


    const weapon = checkIfPlayerHasAnyWeapon();
x = (Math.floor(scaledX / blockSize) * blockSize) - 5;
y = (Math.floor(scaledY / blockSize) * blockSize) - 5;
if (options.zoomout == 1 && options.biggerzoomout == 1) {
    y = (Math.floor(scaledY / blockSize) * blockSize) + 5;
    x = (Math.floor(scaledX / blockSize) * blockSize) + 5
}
    removeBatAtPosition(scaledX, scaledY);
    
    if(options.fightmode==1){
      return;
    }
/*if (isBlockFloor(x, y)) {
  return; // Nie wykonujemy żadnej dalszej logiki
}*/
let radius5=1.5*blockSize
const playerCenterX = offsetX + canvas.width / 2 * 32 * 32 * blockSize;
const playerCenterY = offsetY + canvas.height / 2 * 32 * 32 * blockSize;
 
const distX2 = Math.abs(playerCenterX / blockSize / blockSize / blockSize- x);
const distY2 = Math.abs(playerCenterY / blockSize / blockSize /blockSize- y);
 
if (distX2 <= radius5 && distY2 <= radius5) {
  
}else{
  blockedsound()
// customAlert(distanceFromPlayer)
/*
if(langPlactive==1){
showTextInCanvas("nie jesteś wystarczająco blisko")
}else{
showTextInCanvas("you are not close enough")
}
*/
return;
}
                

    console.log(`Click Position: (${x}, ${y})`);
const blockTypes = ["stones", "rock", "sticks", "nettle", "kite", "tallgrass", "yellow", "violet", "treebark", "toadstool", "fern", "shiny", "blackberry","stick","fiber","stone_axe","handrill-kit","blackberry-fruit","woodboard","briar","kite"];
if (["algae1"].some(tree => checkBlockAtPosition(x, y, tree))) {
 if (checkEmptySlots(1)) {
  updateStamina(-5)
  
  deleteFromChunk(x, y, ["algae1", "algae2", "algae0"])
  addItem("algae_item", 1);
 } else {
  showTextInCanvas("no space for algae ");
 }
 return;
}
if (["a1bed"].some(tree => checkBlockAtPosition(x, y, tree))) {
    if (checkEmptySlots(1)) {
        updateStamina(-5)

        deleteFromChunk(x, y, ["a1bed", "a2bed"])
        addItem("bed", 1);
    } else {
        showTextInCanvas("no space for bed ");
    }
    return;
}
if ( checkBlockAtPosition(x, y, "fence") && checkEmptySlots(0)) {
  addItem("itemfence",1)
  removeBlockAtPosition(x,y,"fence")
  return;
}
if (checkBlockAtPosition(x, y, "log0") && checkEmptySlots(0)) {
  addItem("log", 1)
  removeBlockAtPosition(x, y, "log0")
  return;
}
if (checkBlockAtPosition(x, y, "road") && checkEmptySlots(0)) {
  addItem("itemroad", 1)
  removeBlockAtPosition(x, y, "road")
  return;
}
if (checkBlockAtPosition(x, y, "unknown") && checkEmptySlots(0)) {
  
if (checkIfItems("trueuniversespawner", 1)) {
  if (!checkIfHasEnemy("trueuniversebody", 1)) {
  

  deleteItems("trueuniversespawner", 1);
startLightning2()
achievementget("Summoning isn't a great idea ...", 0)
showTextInCanvas("GOD IS COMING BRO :)  ")
playTrueTrack()
setTimeout(function(){
createTrueUniverse()
},12000)}}

if (checkIfItems("deepgodspawner", 1)) {
  if (!checkIfHasEnemy("deepgodhead", 1)) {
    if(isunderwater==1){
  deleteItems("deepgodspawner", 1);
startLightning2()

showTextInCanvas(" ? ? ?  ")
setTimeout(function(){
createDeepgod()
playBoss1()
},12000)} else { showTextInCanvas("true aqua god can be only summoned underwater ")
  }
  }
  }

  if (checkIfItems("voltary_essence", 1)) {
  deleteItems("voltary_essence", 1); // Zyskujesz 1 rock
  let bat = new Enemy(offsetX + 64, offsetY - 32, 'voltary');
  isRaining = true;
  nightpower = 2

  renderedEnemies.push(bat);
  showTextInCanvas("V O L T A R Y summoned ...")
  return;
}
if (checkIfItems("aquagodshell", 1)) {
  if(isunderwater==1){
  deleteItems("aquagodshell", 1); // Zyskujesz 1 rock
  setTimeout(function (){
  let bat = new Enemy(offsetX + 64, offsetY - 32, 'aquagod');
  isRaining = true;
  nightpower = 2

  renderedEnemies.push(bat);
  },1500);
  showTextInCanvas(" something screaming underwater ")
  return;
}else{
  showTextInCanvas(" you need be underwater to do that ")
}}
if (checkIfItems("universeechoes", 1)) {
  deleteItems("universeechoes", 1); // Zyskujesz 1 rock
  startLightning2()
  setTimeout(function() {
   playBoss4()
    let bat = new Enemy(offsetX + 64, offsetY - 32, 'insaneuniversegod');
    isRaining = true;
    nightpower = 2

    renderedEnemies.push(bat);
  }, 13000);
  showTextInCanvas(" ... this isn't a  'god'  idea");
  return;
}
if (checkIfItems("fleshdumbass", 1)) {
  deleteItems("fleshdumbass", 1); // Zyskujesz 1 rock
  let bat = new Enemy(offsetX + 64, offsetY - 32, 'flesh');
  isRaining = false;
  nightpower = 3
playBoss3()
  renderedEnemies.push(bat);
  showTextInCanvas("you feel hurt from inside of your flesh")
  return;
}else if (checkIfItems("evilsummoner", 1)) {
  deleteItems("evilsummoner", 1); // Zyskujesz 1 rock
  let bat = new Enemy(offsetX + 64, offsetY - 32, 'darkeye');
  isRaining = false;
  nightpower = 3
  renderedEnemies.push(bat);
  playBoss4()
  showTextInCanvas("darkeye is approaching . .")
  return;
}else if (checkIfItems("spikegod_essence", 1)) {
  deleteItems("spikegod_essence", 1); // Zyskujesz 1 rock
  let bat = new Enemy(offsetX + 64, offsetY - 32, 'spikegod');


  renderedEnemies.push(bat);
  showTextInCanvas("the god is approaching . . .")
  return;
}else if (checkIfItems("aquaticevent", 1)) {
  deleteItems("aquaticevent", 1);  
  let bat = new Enemy(offsetX + 64, offsetY - 32, '2medusa');
  renderedEnemies.push(bat);
  playBoss4()
  showTextInCanvas("aquatic even started kill `medusa  `. . .")
  return;
}else {
    

    removeBlockAtPosition(x, y, "unknown");
    addItem("unknown", 1);
  }
  return;
}
 
if (checkBlockAtPosition(x, y, "candy") && checkEmptySlots(0)) {
  if (currentStamina > 95) {
    addItem("candy", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "candy");
  } else {
    updateStamina(40)

    removeBlockAtPosition(x, y, "candy");
  }
  return;
}
if (checkBlockAtPosition(x, y, "dandelion2") && checkEmptySlots(0)) {
  

    removeBlockAtPosition(x, y, "dandelion2");
buildBlockAtPosition(x, y, "dandelion");
addItem("dandelionseeds",1)
  return;
}
if (checkBlockAtPosition(x, y, "energybowl") && checkEmptySlots(0)) {
  if (currentStamina > 95) {
    addItem("energybowl", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "energybowl");
  } else {
    updateStamina(90)
dropItemAtPlayerPosition("bowl")
    removeBlockAtPosition(x, y, "energybowl");
  }
  return;
}
if (checkBlockAtPosition(x, y, "healthbowl") && checkEmptySlots(0)) {
  if (currentHP > 99) {
    addItem("healthbowl", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "healthbowl");
  } else {
    updateHealth(100)
dropItemAtPlayerPosition("bowl")
    removeBlockAtPosition(x, y, "healthbowl");
  }
  return;
}
if (checkBlockAtPosition(x, y, "honey_mushrooms") && checkEmptySlots(0)) {
  if (currentHP > 95) {
    addItem("honey_mushrooms", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "honey_mushrooms");
  } else {
    updateHealth(10)

    removeBlockAtPosition(x, y, "honey_mushrooms");
  }
  return;
}
if (checkBlockAtPosition(x, y, "beer") && checkEmptySlots(0)) {
  if (currentHP > 95) {
    addItem("beer", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "beer");
  } else {
    updateHealth(80)
dropItemAtPlayerPosition("bowl")
    removeBlockAtPosition(x, y, "beer");
  }
  return;
}
if (checkBlockAtPosition(x, y, "bread") && checkEmptySlots(0)) {
  if (currentHP > 80) {
    addItem("bread", 1); // Zyskujesz 1 rock
    removeBlockAtPosition(x, y, "bread");
  } else {
    updateHealth(80)
    removeBlockAtPosition(x, y, "bread");
  }
  return;
}
if (checkBlockAtPosition(x, y, "kite1") && checkEmptySlots(0)) {
  if (currentHP > 90) {
    addItem("kite", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "kite1");
    buildBlockAtPosition(x, y, "mycelium");
  } else {
    updateHealth(15)

    removeBlockAtPosition(x, y, "kite1");
    buildBlockAtPosition(x, y, "mycelium");
  }
  return;
}
if (checkBlockAtPosition(x, y, "thistle1") && checkEmptySlots(0)) {
  
    addItem("thistle", 1); 

    removeBlockAtPosition(x, y, "thistle1");
    buildBlockAtPosition(x, y, "thistleseeds");

  return;
}
if (checkBlockAtPosition(x, y, "rye1") && checkEmptySlots(0)) {
  
    addItem("rye", 1); 

    removeBlockAtPosition(x, y, "rye1");
    buildBlockAtPosition(x, y, "rye_seeds");

  return;
}
if (checkBlockAtPosition(x, y, "cavewallwithsalt") && checkEmptySlots(0)) {
  addItem("salt", 1);
  removeBlockAtPosition(x, y, "cavewallwithsalt");

  return;
}


if (["lamp"].some(tree => checkBlockAtPosition(x, y, tree)) ) {
  if (checkEmptySlots(1)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
    updateStamina(-5)
    addItem("lamptorch", 1);
    deleteFromChunk(x, y, ["lamp", "lamp2"])
  } else {
    showTextInCanvas("no space ");
  }
  return;
}
if (["statue1_1"].some(tree => checkBlockAtPosition(x, y, tree))) {
 if (checkEmptySlots(1)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
  updateStamina(-5)
  addItem("statue1", 1);
  deleteFromChunk(x, y, ["statue1_1", "statue1_2"])
 } else {
  showTextInCanvas("no space ");
 }
 return;
}
if (["statue2_1"].some(tree => checkBlockAtPosition(x, y, tree))) {
  if (checkEmptySlots(1)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
    updateStamina(-5)
    addItem("statue2", 1);
    deleteFromChunk(x, y, ["statue2_1", "statue2_2"])
  } else {
    showTextInCanvas("no space ");
  }
  return;
}
if (["black_elderberry"].some(tree => checkBlockAtPosition(x, y, tree)) && checkIfItems("stone_axe",1)) {
  if (checkEmptySlots(1)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
    updateStamina(-5)
    addItem("black_elderberry_tree", 1);
    if (generateCave !== 1) {
 // setblockatposition(x, y, "grass");
} else {
//  setblockatposition(x, y, "cave_floor");
}
deleteFromChunk(x,y,["black_elderberry","black_elderberry2"])

  } else {
    showTextInCanvas("no space ");
  }
  return;
} else if (["black_elderberry"].some(tree => checkBlockAtPosition(x, y, tree))) {
  if (checkEmptySlots(1)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
    updateStamina(-5)
    addItem("black_elderberries", 2);
    if(generateCave!==1){
    deleteFromChunk(x,y,["black_elderberry","black_elderberry2"])
    }else{
      deleteFromChunk(x,y,["black_elderberry","black_elderberry2"])
    }
    buildBlockAtPosition(x, y, "empty_black_elderberry");
    buildBlockAtPosition(x, y - 32, "empty_black_elderberry2");
  } else {
    showTextInCanvas("no space ");
  }
  return;
}

if (checkBlockAtPosition(x, y, "carrot2") && checkEmptySlots(1)) {

    addItem("carrot", 1);
    addItem("wildcarrot", 1);
    if(Math.random()<0.12){
        addItem("wildcarrot", 1);
    }
    removeBlockAtPosition(x, y, "carrot2")
     
    return;

}


    // Sprawdzenie, jaki blok został kliknięty
    Object.keys(allItems).forEach(itemName => {
  if (checkBlockAtPosition(x, y, itemName) && checkEmptySlots(0)) {
    if (itemName !== "blackberry-fruit" && itemName !== "briar-fruit" && itemName !== "grasslayer" && itemName !== "clayblock" && itemName !== "clayblock1" && itemName !== "sandblock2" && itemName !== "fireplow" && itemName !== "fireroll" && itemName !== "furnace"&& itemName !== "kiln"&& itemName!=="extinguished_campfire"&& itemName !== "magnetite"&& itemName !== "blackberry-fruit"&& itemName !== "cooked_thistleroot"&& itemName !== "cooked_bunnmeat"&& itemName !== "cooked_sharkmeat"&& itemName !== "briar-fruit"&& itemName !== "kite"&& itemName !== "rock"&& itemName !== "cave_wall"&& itemName !== "cavewall"&& itemName !== "black_elderberries"&& itemName !== "hill1"&& itemName !== "tallgrass"&& itemName !== "snowgrass2"&& itemName !== "forestgrasslayer"&& itemName !== "deadgrassfloor2"&& itemName !== "deadgrassfloor") {
      addItem(itemName, 1); // Dodajemy przedmiot o tej samej nazwie, co nazwa w allItems
      removeBlockAtPosition(x, y, itemName); // Usuwamy blok po kliknięciu

      return;

    }
  }
});
if (checkBlockAtPosition(x, y, "stonewithgypsum") && checkIfItems("pickaxe",1)&& checkEmptySlots(0)) {

  addItem("gypsum", 1);
  removeBlockAtPosition(x, y, "stonewithgypsum")
useItemDurability(-3)
  return;

}
if (checkBlockAtPosition(x, y, "diamante1") && checkIfItems("pickaxe", 1) && checkEmptySlots(0)) {

    addItem("diamante", 1);
    removeBlockAtPosition(x, y, "diamante1")
    useItemDurability(-4)
    achievementget("Diamonds !", 1)
    return;
}

if (checkBlockAtPosition(x, y, "abyssblock") && checkIfItems("pickaxe", 1) && checkEmptySlots(0)) {

  removeBlockAtPosition(x, y, "abyssblock")
  useItemDurability(-2)
  return;

}
if (checkBlockAtPosition(x, y, "hook") ) {

  addItem("fishing_rod", 1);
  removeBlockAtPosition(x, y, "hook")
  cannotmove=0
  if (langPlactive == 1) {
    showTextInCanvas("nic nie bierze")
} else {
    showTextInCanvas("nothing catched")
}
    
    
  
  return;

}
if (checkBlockAtPosition(x, y, "catchhook") ) {

addItem("fishing_rod", 1);

removeBlockAtPosition(x, y, "catchhook")
cannotmove=0
if (Math.random() < 0.2) {
    achievementget("„Fish something”", 0)
  addItem("salmon", 1)
  showTextInCanvas("you catch salmon  ")
}else if (Math.random() < 0.5) {
    achievementget("„Fish something”", 0)
  addItem("trout", 1)
  showTextInCanvas("you catch trout  ")
}else {
  if (langPlactive == 1) {
      showTextInCanvas("było blisko ! spróbuj ponownie ")
  } else {
      showTextInCanvas("it was close ... try again")
  }
}


return;

}
if (checkBlockAtPosition(x, y, "pyritestone") && checkIfItems("pickaxe",1)&& checkEmptySlots(0)) {

  addItem("pyrite", 1);
  removeBlockAtPosition(x, y, "pyritestone")
  useItemDurability(-1)
  return;

}

if(checkIfItems("pickaxe",1) && checkBlockAtPosition(x, y, "cave_wall")&&checkEmptySlots(0) ){
    removeBlockAtPosition(x, y, "cave_wall"); buildBlockAtPosition(x, y, "broken_cavewall");
    updateStamina(-4)
    achievementget("Caveman Journey", 0)
    addItem("stone",1)
useItemDurability(-3)
return;}
if(checkIfItems("pickaxe",1) && checkBlockAtPosition(x, y, "hellwall")&&checkEmptySlots(0) ){
    removeBlockAtPosition(x, y, "hellwall"); 
    updateStamina(-15)
    addItem("hellwall2",1)
    if(Math.random()<0.04){
      addItem("pyrite",1)
    }
useItemDurability(-8)
return;}


// Przykład użycia w kontekście Twojego kodu
if (checkIfItems("cavemakingpickaxe", 1) && checkBlockAtPosition(x, y, "dirt") && checkEmptySlots(0)) {
    removeBlockAtPosition(x, y, "dirt");
    buildBlockAtPosition(x, y, "customcaveentrance");

allCaveEntrances.push([Math.floor((offsetX+(canvas.height/2))/32)*32,Math.floor((offsetY+(canvas.height/2))/32)*32])
achievementget("Just a Hole", 0)

    deleteItems("cavemakingpickaxe", 1);
    showTextInCanvas("your pickaxe broke");

    return;
}else if(checkIfItems("cavemakingpickaxe", 1)){
  showTextInCanvas("you can only make caves on DIRT ")
}
if (checkIfItems("pickaxe", 1) && checkBlockAtPosition(x, y, "customcaveentrance") && checkEmptySlots(2)) {
    removeBlockAtPosition(x, y, "customcaveentrance");
    buildBlockAtPosition(x, y, "dirt");


    addItem("cavemakingpickaxe", 1);
    showTextInCanvas("your pickaxe broke");

    return;
}else if(checkBlockAtPosition(x, y, "customcaveentrance")){
  showTextInCanvas(" use pickaxe to remove cave entrance ")
}

if(checkIfItems("pickaxe",1) && checkBlockAtPosition(x, y, "broken_cavewall")&& checkEmptySlots(0)){
    removeBlockAtPosition(x, y, "broken_cavewall"); 
    addItem("bigrock",1)
    useItemDurability(-2)
return;}

if (checkBlockAtPosition(x, y, "extinguished_campfire") ) {
    
if(checkIfItems("palmlog",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("palmlog",1)
    achievementget(" Fire won't last forever ", 0)
return;}else  if(checkIfItems("stick",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("stick",1)
    achievementget(" Fire won't last forever ", 0)
return;}else if(checkIfItems("log",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("log",1)
    achievementget(" Fire won't last forever ", 0)
return;}else if(checkIfItems("treebark",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("treebark",1)
    achievementget(" Fire won't last forever ", 0)
return;} else if(checkIfItems("nettle",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("nettle",1)
    achievementget(" Fire won't last forever ", 0)
return;}else if(checkIfItems("birch-powder",1)){
    removeBlockAtPosition(x, y, "extinguished_campfire"); buildBlockAtPosition(x, y, "campfire");deleteItems("birch-powder",1)
    achievementget(" Fire won't last forever ", 0)
return;} else if(checkEmptySlots(1)){
  removeBlockAtPosition(x, y, "extinguished_campfire");
  if (langPlactive == 1) {
    showTextInCanvas("jeżeli masz materiały łatwopalne możesz zapalić ognisko ponownie")
} else {
    showTextInCanvas("if you have fuel like materials you can \n fire the campfire for crafting")
}
  
  addItem("extinguished_campfire", 1);
}else{
  if (langPlactive == 1) {
    showTextInCanvas("brak miejsca")
} else {
    showTextInCanvas("no space")
}
}
  

  return;
}
if (checkBlockAtPosition(x, y, "furnace") ) {
  if(checkIfItems("palmlog",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("palmlog",1)
return;} else if(checkIfItems("longstick",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("longstick",1)
return;} else if(checkIfItems("stick",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("stick",1)
return;}else if(checkIfItems("log",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("log",1)
return;}else if(checkIfItems("treebark",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("treebark",1)
return;} else if(checkIfItems("coal",1)){
    removeBlockAtPosition(x, y, "furnace"); buildBlockAtPosition(x, y, "lit_furnace");deleteItems("coal",1)
return;} else if(checkEmptySlots(1)){
  removeBlockAtPosition(x, y, "furnace");
  if (langPlactive == 1) {
    showTextInCanvas("jeżeli masz materiały łatwopalne możesz zapalić piec ponownie")
} else {
    showTextInCanvas("if you have fuel like materials you can \n fire the furnace for crafting")
}
  
  addItem("furnace", 1);
}else{
  showTextInCanvas("no space for furnace ")
}
  

  return;
}

if (checkBlockAtPosition(x, y, "kiln") ) {
 if(checkIfItems("palmlog",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("palmlog",1)
return;} else if(checkIfItems("longstick",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("longstick",1)
return;} else if(checkIfItems("stick",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("stick",1)
return;}else if(checkIfItems("log",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("log",1)
return;}else if(checkIfItems("treebark",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("treebark",1)
return;} else if(checkIfItems("coal",1)){
    removeBlockAtPosition(x, y, "kiln"); buildBlockAtPosition(x, y, "lit_kiln");deleteItems("coal",1)
return;} else if(checkEmptySlots(1)){
  removeBlockAtPosition(x, y, "kiln");
  if (langPlactive == 1) {
    showTextInCanvas("jeżeli masz materiały łatwopalne możesz zapalić kiln ponownie")
} else {
    showTextInCanvas("if you have fuel like materials you can \n fire the kiln for crafting")
}
  
  addItem("kiln", 1);
}else{
  showTextInCanvas("no space for kiln ")
}
  

  return;
}

    if (checkBlockAtPosition(x, y, "clayblock")&& checkEmptySlots(1)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  removeBlockAtPosition(x, y, "clayblock");
  addItem("clay", 2);

 // buildBlockAtPosition(x, y, "dirt");

  
}
if (checkBlockAtPosition(x, y, "clayblock1")  && checkEmptySlots(1)) {
  removeBlockAtPosition(x, y, "clayblock1");
  addItem("clay", 2);
  return;
}
if (checkBlockAtPosition(x, y, "cactus") && checkEmptySlots(0)) {
// Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"

if(Math.random()<0.5){
addItem("cactus_fruit", 1);
buildBlockAtPosition(x,y,"cactusempty");
removeBlockAtPosition(x, y, "cactus");
}else{
if (langPlactive == 1) {
    showTextInCanvas("cholera dostałeś obrażenia od kaktusa !")
} else {
    showTextInCanvas("damn you taken damage from penetration a cactus!")
}
  
  
  updateHealth(-4)
}
// buildBlockAtPosition(x, y, "dirt");

return;
}
    if (checkBlockAtPosition(x, y, "stones")&& checkEmptySlots(0)) {
        addItem("stone", Math.random() < 0.5 ? 1 : 2);  // Możesz zdobyć 1 lub 2 kamienie
        updateStamina(-1)
  removeBlockAtPosition(x, y, "stones")
  return;

    }
    if (checkBlockAtPosition(x, y, "sticks") && checkEmptySlots(0)) {
        const randomItem = Math.random() < 0.5 ? "stick" : (Math.random() < 0.5 ? "treebark" : "longstick");
        addItem(randomItem, 1);  // Możesz zdobyć stick, treebark lub longstick
        updateStamina(-2)
  removeBlockAtPosition(x, y, "sticks")
  return;

    }
        if (checkBlockAtPosition(x, y, "gypsum_dirt") && checkEmptySlots(0)) {
      
      addItem("gypsum", 1); 
      removeBlockAtPosition(x, y, "gypsum_dirt")
      return;

    }
    if (checkBlockAtPosition(x, y, "rock")&& checkEmptySlots(0)) {
        addItem("bigrock", 1);  // Zyskujesz 1 rock
        updateStamina(-4)
  removeBlockAtPosition(x, y, "rock")
  return;

    }
if (checkBlockAtPosition(x, y, "briar")&& checkEmptySlots(0)) {
  addItem("briar-fruit", 1); // Zyskujesz 1 rock
  buildBlockAtPosition(x,y,"briarempty");
  removeBlockAtPosition(x, y, "briar")
  return;

}

if (checkBlockAtPosition(x, y, "blackberry")&& checkEmptySlots(0)) {
  addItem("blackberry-fruit", 1); // Zyskujesz 1 rock
  buildBlockAtPosition(x,y,"emptyblackberry"); 
  removeBlockAtPosition(x, y, "blackberry")
  return;
}


if (checkBlockAtPosition(x, y, "blackberry-fruit") && checkEmptySlots(0)) {
  if (currentHP > 80) {
    addItem("blackberry-fruit", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "blackberry-fruit");
  } else {
    updateHealth(20)

    removeBlockAtPosition(x, y, "blackberry-fruit");
  }
  return;
}

if (checkBlockAtPosition(x, y, "cactus_fruit") && checkEmptySlots(0)) {
  if (currentHP > 95) {
    addItem("cactus_fruit", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "cactus_fruit");
  } else {
    updateHealth(20)

    removeBlockAtPosition(x, y, "cactus_fruit");
  }
  return;
}if (checkBlockAtPosition(x, y, "black_elderberries") && checkEmptySlots(0)) {
  if (currentHP > 95) {
    addItem("black_elderberries", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "black_elderberries");
  } else {
    updateHealth(5)

    removeBlockAtPosition(x, y, "black_elderberries");
  }
  return;
}
if (checkBlockAtPosition(x, y, "cooked_bunnmeat") && checkEmptySlots(0)) {
  if (currentHP > 90) {
    addItem("cooked_bunnmeat", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "cooked_bunnmeat");
  } else {
    updateHealth(50)

    removeBlockAtPosition(x, y, "cooked_bunnmeat");
  }
  return;
}
if (checkBlockAtPosition(x, y, "cooked_salmon") && checkEmptySlots(0)) {
  if (currentHP > 90) {
    addItem("cooked_salmon", 1); // Zyskujesz 1 rock

    removeBlockAtPosition(x, y, "cooked_salmon");
  } else {
    updateHealth(30)

    removeBlockAtPosition(x, y, "cooked_salmon");
  }
  return;
}
if (checkBlockAtPosition(x, y, "kite") && checkEmptySlots(0)) {
  if (currentHP > 90) {
    addItem("kite", 1); // Zyskujesz 1 rock
    
    removeBlockAtPosition(x, y, "kite");
    
  } else {
    updateHealth(15)
    
    removeBlockAtPosition(x, y, "kite");
  }
  return;
}
if (checkBlockAtPosition(x, y, "cooked_thistleroot") && checkEmptySlots(0)) {
  if (currentHP > 60) {
    addItem("cooked_thistleroot", 1); // Zyskujesz 1 rock
     
    removeBlockAtPosition(x, y, "cooked_thistleroot");
  } else {
    updateHealth(40)
     
    removeBlockAtPosition(x, y, "cooked_thistleroot");
  }
  return;
}

if (checkBlockAtPosition(x, y, "briar-fruit") && checkEmptySlots(0)) {
  if (currentHP > 70) {
    addItem("briar-fruit", 1); // Zyskujesz 1 rock
     
    removeBlockAtPosition(x, y, "briar-fruit");
  } else {
    updateHealth(40)
     
    removeBlockAtPosition(x, y, "briar-fruit");
  }
  return;
}
if (checkBlockAtPosition(x, y, "fireplow") && checkEmptySlots(0)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  
  blockTypes.forEach(type => removeBlockAtPosition(x, y, type));
  if(Math.random()>0.1){
    addItem("fireplow", 1);
  removeBlockAtPosition(x, y, "fireplow");
  yourItems = yourItems.map(item => item === "fiber" ? "ignited_fiber" : item);
  igniteFiberAround(x, y, 64);
  
  return;
}else{
  
  if (langPlactive == 1) {
    showTextInCanvas("nie udało się spróbuj ponownie")
} else {
    showTextInCanvas("fiber doesn't ignited try again ")
}
}
return;
}
if (checkBlockAtPosition(x, y, "fireroll") && checkEmptySlots(0)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  
  blockTypes.forEach(type => removeBlockAtPosition(x, y, type));
  if(Math.random()>0.9){
    addItem("fireroll", 1);
  removeBlockAtPosition(x, y, "fireroll");
  yourItems = yourItems.map(item => item === "fiber" ? "ignited_fiber" : item);
  igniteFiberAround(x, y, 64);
  
  return;
}else{
  if (langPlactive == 1) {
    showTextInCanvas("nie udało się spróbuj ponownie")
} else {
    showTextInCanvas("fiber doesn't ignited try again ")
}
}
return;
}
if (checkBlockAtPosition(x, y, "forestgrasslayer") && checkEmptySlots(0) && (checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1))) {
    // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
    removeBlockAtPosition(x, y, "forestgrasslayer");
    addItem("forestgrasslayer", 1);
    achievementget(" Go touch some grass ", 0)
    updateStamina(-2)
    return;
}if (checkBlockAtPosition(x, y, "deadgrassfloor2") && checkEmptySlots(0) && (checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1))) {
   
    removeBlockAtPosition(x, y, "deadgrassfloor2");
    addItem("deadgrassfloor2", 1);
    achievementget(" Go touch some grass ", 0)
    updateStamina(-2)
    return;
}

if (checkBlockAtPosition(x, y, "grasslayer") && checkEmptySlots(0) && ( checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1) ) ) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  removeBlockAtPosition(x, y, "grasslayer");
  addItem("grasslayer", 1);
  achievementget(" Go touch some grass ", 0)
  updateStamina(-2)
  return;
}
if (checkBlockAtPosition(x, y, "tallgrass")) {
  removeBlockAtPosition(x, y, "tallgrass");
  return;
}
if (checkBlockAtPosition(x, y, "deadgrass")) {
  removeBlockAtPosition(x, y, "deadgrass");
  buildBlockAtPositionBefore(x, y, "grass");
  return;
}
if (checkBlockAtPosition(x, y, "magnetite") && checkEmptySlots(0)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  removeBlockAtPosition(x, y, "magnetite");
  addItem("magnetite_powder", 1);
  updateStamina(-3)
  if (Math.random() < 0.2) {

  } else {

  }
  return;
}
if (["palm1"].some(tree => checkBlockAtPosition(x, y, tree))) {
    if (checkIfItems("stone_axe", 1) && checkEmptySlots(3)) {
     
        addItem("palmlog", 2);
        addItem("palmsapling", 1);
        if (Math.random() < 0.3) {
            addItem("palmsapling", 1);
        }
        deleteFromChunk(x, y, ["palm1", "palm2","palm3"]);
        deleteFromChunk(x, y, ["palm12", "coconutpalm", "palm32"]);
removeBlockAtPosition(x, y-(32), "palm3");
removeBlockAtPosition(x, y-(32*2), "palm2");
removeBlockAtPosition(x, y - (32), "palm32");
removeBlockAtPosition(x, y - (32 * 2), "coconutpalm");
}
    return;
}
if (["palm12"].some(tree => checkBlockAtPosition(x, y, tree))) {
    if ( checkEmptySlots(1)) {
        if (!checkBlockAtPosition2(x, y, "coconutpalm")) {
            addItem("coconut", 1);
             
            if (Math.random() < 0.5) {
                addItem("coconut", 1);
                achievementget("Coconut On the Coconut palm",0)
            }
            deleteFromChunk(x, y, ["palm1", "palm2","palm3"])
            deleteFromChunk(x, y, ["palm12", "coconutpalm", "palm32"]);
removeBlockAtPosition(x, y , "palm12");
removeBlockAtPosition(x, y - (32), "palm32");
removeBlockAtPosition(x, y - (32 * 2), "coconutpalm");
          buildBlockAtPosition(x,y,"palm1")
            buildBlockAtPosition(x,y-32,"palm3")
            
            buildBlockAtPosition(x,y-64,"palm2")
        }
    }
    return;
}
if (["abysstree0"].some(tree => checkBlockAtPosition(x, y, tree))) {
    if (checkIfItems("stone_axe", 1) && checkEmptySlots(3)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
        updateStamina(-5)
        addItem("abysssapling", 1);
        addItem("abysslog", 1);
        
        if (Math.random() < 0.5) {
            addItem("abysssapling", 1);
            addItem("abyssgel", 2);
        }  if (Math.random() < 0.6){
            addItem("abysswood", 1);
        }
        deleteFromChunk(x, y, ["abysstree0", "abysstree1", "abysstree2"])

    } else {
        if (langPlactive == 1) {
    showTextInCanvas("potrzebne ci narzędzie")
} else {
    showTextInCanvas("you need a tool ")
}
    }
    return;
}
if (["helltree0"].some(tree => checkBlockAtPosition(x, y, tree))) {
    if (checkIfItems("stone_axe", 1) && checkEmptySlots(3)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
        updateStamina(-5)
        addItem("hellsapling", 1);
addItem("helllog", 1);
        if (Math.random() < 0.5) {
            addItem("hellsapling", 1);
            addItem("hellwood", 1);
addItem("helllog", 1);
        }
        deleteFromChunk(x, y, ["helltree0", "helltree1", "helltree2"])

    } else {
        if (langPlactive == 1) {
    showTextInCanvas("potrzebne ci narzędzie")
} else {
    showTextInCanvas("you need a tool ")
}
    }
    return;
}
    if (["tree0"].some(tree => checkBlockAtPosition(x, y, tree))) {
        if (checkIfItems("stone_axe", 1) && checkEmptySlots(3)) {  // Potrzebujesz siekiery i 2 miejsc w ekwipunku
        achievementget("Cut down some trees", 0)
        updateStamina(-5)
            addItem("log", 3);
            addItem("sapling", 1);
            if(Math.random()<0.3){
            addItem("treebark", 1);
            }else if (Math.random() < 0.6) {
  addItem("longstick", 1);
  addItem("sapling", 1);
}else{
addItem("stick", 1);
addItem("sapling", 1);
 }
            deleteFromChunk(x,y,["tree0","tree1","tree2"])
             
        } else {
            if (langPlactive == 1) {
    showTextInCanvas("potrzebne ci narzędzie")
} else {
    showTextInCanvas("you need a tool ")
}
        }
        return;
    }
    if (["pine0"].some(tree => checkBlockAtPosition(x, y, tree))) {
  if (checkIfItems("stone_axe", 1) && checkEmptySlots(2)) { // Potrzebujesz siekiery i 2 miejsc w ekwipunku
  achievementget("Cut down some trees", 0)
    addItem("log", 2);
    updateStamina(-5)
    addItem("resin", 1);
addItem("sapling", 1);
if (Math.random() < 0.3) {
  addItem("treebark", 1);
} else {
  addItem("stick", 1);
  addItem("sapling", 1);
}
deleteFromChunk(x,y,["pine0","pine1","pine2"])
}
      return;
    }
if (["birch0"].some(tree => checkBlockAtPosition(x, y, tree))) {
  if (checkIfItems("stone_axe", 1) && checkEmptySlots(2)) { 
      achievementget("Cut down some trees", 0)
addItem("log", 2); 
addItem("birch-powder", 1);
updateStamina(-5)
addItem("sapling", 1);
if (Math.random() < 0.3) {
  addItem("longstick", 1);
} else {
  addItem("stick", 1);
  addItem("sapling", 1);
}
deleteFromChunk(x,y,["birch0","birch1","birch2"])
}
  return;
}
if (["snowpine1"].some(tree => checkBlockAtPosition(x, y, tree))) {
  if (checkIfItems("stone_axe", 1) && checkEmptySlots(2)) {
    addItem("log", 2);
    updateStamina(-5)
    addItem("sapling", 1);
    if (Math.random() < 0.8) {
      addItem("longstick", 1);
    } else {
      addItem("stick", 1);
      addItem("sapling", 1);
    }
    deleteFromChunk(x, y, ["snowpine1", "snowpine2", "snowpine3"])
  }
  return;
}
if (checkBlockAtPosition(x, y, "deadgrassfloor") && checkEmptySlots(1)) {
  addItem("deadgrassfloor2", 2)
  removeBlockAtPosition(x, y, "deadgrassfloor");
  buildBlockAtPositionBefore2(x, y, "grass");
}
if (checkBlockAtPosition(x, y, "hill1") && checkEmptySlots(0) && checkIfItems("iron_shovel", 1)) {
 removeBlockAtPosition(x, y, "hill1");
 addItem("hill1", 1);
 updateStamina(-8)
 return;
}
  if ((checkBlockAtPosition(x, y, "grass")) && checkEmptySlots(0) && ( checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1) )) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  achievementget(" Go touch some grass ", 0)
  updateStamina(-2)
if (Math.random() < 0.08) {
  buildBlockAtPosition(x, y, "itemroad");
}
if (Math.random() < 0.15) {
  buildBlockAtPosition(x, y, "grass2");
}
  if(Math.random()<0.2){
  buildBlockAtPositionBefore2(x, y, "clayblock");
  }else   if (Math.random() < 0.05) {
    buildBlockAtPositionBefore2(x, y, "gypsum_dirt");
  }else if (Math.random() < 0.08) {
    buildBlockAtPositionBefore2(x, y, "magnetite")
   
  
}else if (Math.random() < 0.02) {
  buildBlockAtPositionBefore2(x, y, "chalcopyrite")
   
  
}else if (Math.random() < 0.09) {
  buildBlockAtPositionBefore2(x, y, "stones")
  
  
}else if (Math.random() < 0.09) {
  buildBlockAtPositionBefore2(x, y, "bigrock")
  
  
}else{ if (Math.random() < 0.5){
    buildBlockAtPositionBefore2(x, y, "grasslayer");}
}

removeBlockAtPosition(x, y, "grass");
addItem("grasslayer", 1);
setTimeout(function (){
buildBlockAtPositionBefore2(x, y, "dirt");
},100)
return;
}
if (checkBlockAtPosition(x, y, "forestgrass") && checkEmptySlots(0) && ( checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1) )) {
  updateStamina(-2)
  if (Math.random() < 0.2) {
  buildBlockAtPosition(x, y, "itemroad");
}
  if(Math.random()<0.2){
  buildBlockAtPositionBefore2(x, y, "clayblock");
  }else   if (Math.random() < 0.05) {
    buildBlockAtPositionBefore2(x, y, "gypsum_dirt");
  }else if (Math.random() < 0.08) {
    buildBlockAtPositionBefore2(x, y, "magnetite")
   
  
}else if (Math.random() < 0.02) {
  buildBlockAtPositionBefore2(x, y, "chalcopyrite")
   
  
}else if (Math.random() < 0.09) {
  buildBlockAtPositionBefore2(x, y, "stones")
  
  
}else if (Math.random() < 0.09) {
  buildBlockAtPositionBefore2(x, y, "bigrock")
  
  
}else{ if (Math.random() < 0.5){
    buildBlockAtPositionBefore2(x, y, "forestgrasslayer");}
}
removeBlockAtPosition(x, y, "forestgrass");
addItem("forestgrasslayer", 1);
setTimeout(function (){
buildBlockAtPositionBefore2(x, y, "dirt");
},100)
return;
}
if (checkBlockAtPosition(x, y, "mercuryliquid") && checkEmptySlots(0) && checkIfItems("bottle", 1)) {
    achievementget("Ohh good this metal is fluid", 0)
    removeBlockAtPosition(x, y, "mercuryliquid");
    deleteItems("bottle", 1)
    updateStamina(-5)
    addItem("mercurybottle", 1);
    return;
}
if (checkBlockAtPosition(x, y, "water") && checkEmptySlots(0) && checkIfItems("bowl", 1)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  achievementget("Grab some water", 0)
  removeBlockAtPosition(x, y, "water");
  buildBlockAtPositionBefore2(x, y, "grass");
  deleteItems("bowl",1)
  updateStamina(-5)
  addItem("bowl_with_seawater", 1);
  
  return;
}
if (checkBlockAtPosition(x, y, "water1") && checkEmptySlots(0) && checkIfItems("bowl", 1)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  achievementget("Grab some water", 0)
  removeBlockAtPosition(x, y, "water1");
   updateStamina(-5)
  deleteItems("bowl", 1)
  addItem("bowl_with_seawater", 1);

  return;
}

if (checkBlockAtPosition(x, y, "water") && checkEmptySlots(0) && checkIfItems("leafbowl", 1)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  achievementget("Grab some water", 0)
  removeBlockAtPosition(x, y, "water");
  buildBlockAtPositionBefore2(x, y, "grass");
  deleteItems("leafbowl", 1)
  updateStamina(-5)
  addItem("leafbowlwithwater", 1);

  return;
}
if (checkBlockAtPosition(x, y, "water1") && checkEmptySlots(0) && checkIfItems("leafbowl", 1)) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  achievementget("Grab some water", 0)
  removeBlockAtPosition(x, y, "water1");
  updateStamina(-5)
  deleteItems("leafbowl", 1)
  addItem("leafbowlwithwater", 1);

  return;
}


if (checkBlockAtPosition(x, y, "sand") && checkEmptySlots(0) && ( checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1) )) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  removeBlockAtPosition(x, y, "sand");
  buildBlockAtPositionBefore2(x, y, "grass");
achievementget("Maybe its time to make glass?", 0)
  addItem("grains_of_sand", 1);

  return;
}
if (checkBlockAtPosition(x, y, "sandblock2") && checkEmptySlots(0) && ( checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1) )) {
  // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
  removeBlockAtPosition(x, y, "sandblock2");
  

  addItem("grains_of_sand", 1);

  return;
}
if (checkBlockAtPosition(x, y, "snowgrass") && checkEmptySlots(0) && (checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1))) {
    // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
    removeBlockAtPosition(x, y, "snowgrass");
buildBlockAtPositionBefore2(x, y, "grass");

    addItem("snowgrass2", 1);

    return;
}
if (checkBlockAtPosition(x, y, "snowgrass2") && checkEmptySlots(0) && (checkIfItems("stoneshovel", 1) || checkIfItems("iron_shovel", 1))) {
    // Przeszukujemy otaczające bloki w promieniu 64px i zamieniamy "fiber" na "ignited_fiber"
    removeBlockAtPosition(x, y, "snowgrass2");
    

    addItem("snowgrass2", 1);

    return;
}
}
 
  
function isPC() {
    const userAgent = navigator.userAgent;
    const isWindows = userAgent.includes("Windows");
    const isMac = userAgent.includes("Macintosh");
    const isLinux = userAgent.includes("Linux") && !userAgent.includes("Android"); // Wykluczamy Android
    return isWindows || isMac || isLinux;
}
 
if (isPC()) {
    customAlert("PC device : <br><br>"+navigator.userAgent+"Use WSAD TO MOVE")
    canvas.addEventListener(
    "click",
    (e) => {
        process_target(e);
    });
} else {
    canvas.addEventListener(
    "touchstart",
    (e) => {
        process_target(e);
    });

}




// Funkcja sprawdzająca, czy na danej pozycji znajduje się blok typu 'type'
function checkBlockAtPosition(x, y, type) {
    // Oblicz pozycje globalne z przesunięciem
    const globalX = x + offsetX;
    const globalY = y + offsetY;
if(floorblocks.includes(type) && options.dontbreakfloor==1){
  return false;
}
    // Funkcja zaokrąglająca do najbliższej wielokrotności rozmiaru bloku
    const snappedGlobalX = Math.floor(globalX / blockSize) * blockSize;
    const snappedGlobalY = Math.floor(globalY / blockSize) * blockSize;

    // Iterowanie przez chunki, ale tylko te, które są w pobliżu kliknięcia
    const chunkX = Math.floor(snappedGlobalX / blockSize);
    const chunkY = Math.floor(snappedGlobalY / blockSize);

    const neighboringChunks = [
        `${chunkX},${chunkY}`,   // dokładnie ten chunk

    ];

    // Sprawdzamy tylko sąsiednie chunki
    for (let chunkKey of neighboringChunks) {
        let chunkBlocks = chunks[chunkKey];
        if (!chunkBlocks) continue; // pomiń chunk, jeśli nie istnieje

        // Iterujemy przez wszystkie bloki w danym chunku
        for (let i = 0; i < chunkBlocks.length; i++) {
            let block = chunkBlocks[i];

            // Sprawdzamy najpierw, czy typ pasuje, aby ograniczyć liczbę operacji
            if (block.type !== type) continue;

            let blockGlobalX = block.x + chunkX * blockSize;
            let blockGlobalY = block.y + chunkY * blockSize;

            // Jeśli pasuje współrzędna, zwracamy true
            if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
                return true;
            }
        }
    }
    return false;  // Nie znaleziono bloku o zadanym typie
}
function checkBlockAtPosition2(x, y, type) {
  // Oblicz pozycje globalne z przesunięciem
  const globalX = x + offsetX;
  const globalY = y + offsetY;
  // Funkcja zaokrąglająca do najbliższej wielokrotności rozmiaru bloku
  const snappedGlobalX = Math.floor(globalX / blockSize) * blockSize;
  const snappedGlobalY = Math.floor(globalY / blockSize) * blockSize;

  // Iterowanie przez chunki, ale tylko te, które są w pobliżu kliknięcia
  const chunkX = Math.floor(snappedGlobalX / blockSize);
  const chunkY = Math.floor(snappedGlobalY / blockSize);

  const neighboringChunks = [
        `${chunkX},${chunkY}`, // dokładnie ten chunk

    ];

  // Sprawdzamy tylko sąsiednie chunki
  for (let chunkKey of neighboringChunks) {
    let chunkBlocks = chunks[chunkKey];
    if (!chunkBlocks) continue; // pomiń chunk, jeśli nie istnieje

    // Iterujemy przez wszystkie bloki w danym chunku
    for (let i = 0; i < chunkBlocks.length; i++) {
      let block = chunkBlocks[i];

      // Sprawdzamy najpierw, czy typ pasuje, aby ograniczyć liczbę operacji
      if (block.type !== type) continue;

      let blockGlobalX = block.x + chunkX * blockSize;
      let blockGlobalY = block.y + chunkY * blockSize;

      // Jeśli pasuje współrzędna, zwracamy true
      if (blockGlobalX === snappedGlobalX && blockGlobalY === snappedGlobalY) {
        return true;
      }
    }
  }
  return false; // Nie znaleziono bloku o zadanym typie
}
// Funkcja sprawdzająca, czy w ekwipunku jest wystarczająco dużo wolnych miejsc
function checkEmptySlots(number) {
  const emptySlots = slots - yourItems.length;
  
  if (emptySlots <= number) {
    if (langPlactive == 1) {
    showTextInCanvas("'brak miejsca ")
} else {
    showTextInCanvas("'lack of space'")
}
    blockedsound()
    return false;
  }
  return true;
}

// Show save names modal
// Function to show the save names modal with detected save slots
async function showsaves() {
    const saveNames = [];

    try {
        const db = await initDB(); // Inicjalizujemy bazę danych
        const transaction = db.transaction("gameStates", "readonly"); // Transakcja w trybie tylko do odczytu
        const store = transaction.objectStore("gameStates");

        // Pobierz wszystkie zapisy gry
        const allSavesRequest = store.getAll();

        allSavesRequest.onsuccess = function (event) {
            const gameStates = event.target.result;

            // Iterujemy przez wszystkie zapisy gry i dodajemy ich sloty
            gameStates.forEach(gameState => {
                const slot = gameState.slot;
                if (slot !== undefined) {
                    saveNames.push(slot); // Dodajemy sloty zapisów do listy
                }
            });

            // Wyświetlanie zapisanych slotów w interfejsie
            document.getElementById('saveNamesList').innerText = saveNames.join(', ');
            document.getElementById('saveNamesModal').style.display = 'flex';
        };

        allSavesRequest.onerror = function (error) {
            console.log("Failed to fetch saved games from IndexedDB", error);
        };
    } catch (error) {
        customAlert("Error reading save data: " + error);
    }
}


// Function to close the save names modal
function closeSaveNamesModal() {
    document.getElementById('saveNamesModal').style.display = 'none';
}




</script>
<div onclick="openInventory()" id="Q1EQ" style="position: absolute; bottom: 12vh; right:5px; width:11px; height:11px; background: rgba(181, 181, 181, 0.20) ; background: url('./joystick.png') ;
background-size: 100%;
opacity:0.5;  color: rgba(0, 200, 255, 1); padding: 25px;image-rendering: pixelated; font-size: 15px;
font-family: Arial, Helvetica, sans-serif;">EQ</div>
<script>

let inventoryOpen = false;
document.addEventListener('keydown', function(event) {
    if (event.key === 'x' || event.key === 'X'|| event.key === "z") { 
        if (inventoryOpen) {
            closeInventory();
            inventoryOpen = false;
            advanced.style.display ="none"
        } else {
            openInventory();
            inventoryOpen = true;
        }
    }
});

</script>
    <style>
/* Ciemny retro styl */

.inventory-container {
    position: fixed;
    font-family: 'Courier New', Courier, monospace;
    color: white;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.75);
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 7px;
    visibility: hidden; /* Ukryty domyślnie */
    box-sizing: border-box;
}

.close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: #333;
    border: none;
    color: #00ff00;
    padding: 5px 10px;
    cursor: pointer;
}

.slots {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 10px;
    width:100vw; height :85px; overflow: hidden scroll;
    margin-top: 20px;
    width: 100%; /* Gwarantuje dopasowanie do szerokości */
    box-sizing: border-box;
}

.slot {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    aspect-ratio: 1/1; /* Gwarantuje, że sloty są kwadratowe */
    background-color: #0C0C0C;
    border: 2px solid #474747;
    justify-content: center;
    border-radius: 2px;
}

.slot img {
    max-width: 70%;
    max-height: 70%;
}

.slot-name {
    margin-top: 5px;
    font-size: 50%;
    text-align: center;
}

.crafting-recipes {
    display: flex;
    flex-direction: column;
    font-size: 10px;
    margin-bottom: 0px;
    width: calc(100% - 70px );
    max-height: calc(100% - 95px);
    overflow-y: auto; /* W przypadku dużej liczby receptur, pojawi się przewijanie */
}

.recipe {
    background-color: #2C2828;
    padding: 5px;
    margin-bottom: 5px;
    border-radius: 5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    flex-direction: row;
    display: flex;
flex-wrap: wrap;
}

.recipe:hover {
    background-color: #444;
}

.recipe img {
    width: 25px;
    image-rendering: pixelated;
    vertical-align: middle;
}

.recipe-name {
    margin-top: 5px;
    font-size: 10px;
    text-align: center;
}
.itemImg{
width: 26px;
background-size: 60%;
image-rendering:pixelated;
}
.hover:hover{
  color:#3DFF00
}
#advanced{
  position: fixed;
  
  z-index: 99999;
  width:100vw;
  height:100vh;
  background: rgba(22, 19, 19, 0.72);
  display: none;
  flex-direction: column;
justify-content: center;
align-items: center;
overflow: hidden ;
overflow-y: scroll ;
}
#advanced button {
  color: #000000;
  width:50%;
  background: #505050;
  outline: none;
  margin-top: 5px;
}#advanced textarea {
  color: #000000;
  background: #505050;
  outline: none;
  width:50%;
  
}
.hover{
    font-size: 12.5px;
}
.cheatButton1{
  background-color:#959595;
}
    </style>
<style>
#allachievements{ display:none; height :100vh; overflow: hidden scroll; } #achievement{ display:none; }
@keyframes easeUp{0%{ top:-50px; }100%{} }
@keyframes easeUp2 {0% {}100% { top: -50px; } }
</style>



<script>
    var achievements = [];
    function achievementget(text, rank){ let cangive=1; for (var i = 0; i < achievements.length; i++) { if(achievements[i][1]==text){
        cangive=0;}
    } if(cangive==1){
    document.getElementById("achievement").style.display="block";document.getElementById("achievement").style.animation ="easeUp 2s";document.getElementById("achievementTEXT").innerHTML=text;
        if(rank==2){document.getElementById("achievementimg").style.backgroundImage="url('./platinum.gif')";}else if(rank){document.getElementById("achievementimg").style.backgroundImage="url('./diamond.gif')";}else{document.getElementById("achievementimg").style.backgroundImage="url('./coin.gif')";}
        setTimeout(function() {document.getElementById("achievement").style.animation = "easeUp2 2s"}, 4000)
        setTimeout(function (){document.getElementById("achievement").style.display="none"},5000)
       if(rank==2){achievements.push([2,text]);}else if(rank){achievements.push([1,text]);}else{achievements.push([0,text]);}
    }}
    function openAchievmentsMenu(){
        document.getElementById("allachievements").style.display="block";
        document.getElementById("allachievements2").innerHTML=""
        for (var i = 0; i < achievements.length; i++) {
            let d=`
<div   
style="width:100%; height:30px; background:rgb(20,20,20); margin-top:5px;"
>
<pre style="margin-left:35px; margin-top: 0; position : absolute; color:white; width: calc(100% - 30px); white-space: pre-wrap; ">${achievements[i][1]}</pre>
<div style="width:30px; height:100%; background: rgb(50,50,50); background-size:100% 100%; image-rendering: pixelated;"><div style="width:30px; height:100%; background-image:`
if(achievements[i][0]==2){ d+= "url('./platinum.gif'); "; }else if(achievements[i][0]){ d+= "url('./diamond.gif'); "; }else{ d+= "url('./coin.gif');"; }
d+=`background-size:100% 100%; image-rendering: pixelated;" ></div></div>
</div>`;

document.getElementById("allachievements2").innerHTML+=d
        }
    }
</script>

    <div class="inventory-container" style="overflow: scroll; height:100%;"  id="inventory">
      <input   style="position:absolute; top:40px; right:0 ; width:50px; background:#666666;z-index: 999; border:none; outline: none; font-size: 8px;" class="hover" placeholder="save name " id="savename" ></input>
      <div onclick="saveGameState(document.getElementById('savename').value || '' );" style="position:absolute; top:60px; right:0 ; background:#666666;z-index: 999; font-size: 10px;" class="hover">save game</div>
      <div data-var="dropany" id="shootbtn" onclick="toggleAndStyleButton(this);" style="position:absolute; top:5px; left:0 ;z-index: 999; background:#666666; display:none;font-size: 10px; " > Dont shoot </div> 
      <div onclick="loadGameState(document.getElementById('savename').value || '');"  style="position:absolute; top:90px; right:0 ;z-index: 999; background:#666666;"class="hover">load game</div>
<div onclick="toggleAllRecipes()"  style="position:absolute; top:120px; right:0 ; z-index: 999; background:#666666;"class="hover">Show all</div>
<div onclick="showsaves();" style="position:absolute; top:140px; right:0 ; background:#666666;z-index: 999; " class="hover">save names</div>
<div onclick="toggleadvanced()"  style="position:absolute; top:160px; right:0 ; z-index: 999; background:#666666;"class="hover"> settings</div>
<div onclick="loadGameState2(document.getElementById('savename').value || '');"  style="position:absolute; bottom:10px; right:0 ;z-index: 999; background:#666666;"class="hover">load oldgame</div>
     <!-- <div onclick="toggleadvanced()"  style="position:absolute; top:160px; right:0 ; z-index: 999; background:#666666;"class="hover">advanced </div>-->
        <button class="close-button" onclick="closeInventory()">Close</button>

        <div class="crafting-recipes" id="crafting">
            <!-- Crafting recipes will be displayed here -->
        </div>

        <div class="slots" id="slots">
        </div>
    </div>

<div id="advanced" style="display:none; height:100vh; overflow: hidden scroll;">
  <ffd style=" width :100%; height:99%; overflow: hidden scroll ; ">
  <button   id="cheatButton" onclick="openCheatModal();" >Activate Cheats</button> <br>
  
    <div onclick="toggleAdvanced()" style="position:absolute; top:160px; right:10px; z-index:999; background:#666; color:white; padding:5px; cursor:pointer;">
        Close
    </div>
    <button data-var="autoclose" onclick="toggleAndStyleButton(this);">Auto Close</button> <br>
    <button data-var="creativemode" onclick="toggleAndStyleButton(this);" class="cheatButton1">Creative mode</button> <br>
    <button data-var="noclip" onclick="toggleAndStyleButton(this);" class="cheatButton1">Noclip modr</button> <br>
    <button data-var="dropany" onclick="toggleAndStyleButton(this);">Drop any item (fishing rod)</button> <br>
    <button data-var="dontbreakfloor" onclick="toggleAndStyleButton(this);">Dont break floors</button>
    <button data-var="autopause" onclick="toggleAndStyleButton(this);">auto pause</button>
    <button data-var="fancygraphic" onclick="toggleAndStyleButton(this);">fancygraphic</button>
    <button data-var="quickinventory" onclick="toggleAndStyleButton(this); updateInventory()">quickinventory</button>
    <button data-var="fightmode" onclick="toggleAndStyleButton(this);">fightmode prevent destroying blocks </button>
    <button data-var="zoomout" onclick="toggleAndStyleButton(this);">zoom out</button>
    <button data-var="biggerzoomout" onclick="toggleAndStyleButton(this);">bigger zoom out</button>
    <button data-var="invertControls" onclick="toggleAndStyleButton(this);">invertControls</button>
    <button data-var="hideBlocksnumber" onclick="toggleAndStyleButton(this);">hideBlocksnumber</button>
<button onclick="openAchievmentsMenu()">your achievements</button>
    <button data-var="Fskipping" onclick="toggleAndStyleButton(this);">frames skipping</button>
    <br>

    

<button onclick="removeSaveFile(document.getElementById('savename').value || '')"> DELETE DATA FROM SELECTED SLOT  </button>
<br> <br>
<button onclick="document.getElementById('loadingMenu').style.display = 'none'; document.getElementById('MainMenu').style.display = 'block'; cancontinue=1; document.getElementById('continuebtn').style.display='block'; document.getElementById('advanced').style.display='none'; document.getElementById('gamescontainer').style.display='none'; paused=1 ;">backtomenu</button>
</ffd>
</div>
<!-- Modal dla kodu cheatów -->
<div id="cheatModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeCheatModal()">&times;</span>
        <h2>Are you sure to activate cheats in your save ?</h2>
        <p>Rewrite this code to confirm:</p>
        <p id="cheatCode" style="font-weight: bold; color: #fff;"></p>
        <input type="text" id="cheatInput" placeholder="Enter code here">
        <button onclick="verifyCheatCode()">Confirm</button>
    </div>
</div>
<!-- Modal for displaying save names -->
<div id="saveNamesModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeSaveNamesModal()">&times;</span>
        <h2>Save Names</h2>
        <p id="saveNamesList"></p>
    </div>
</div>

<style>
/* Styl dla modalu */
.modal {
    display: none;
    position: fixed;
    z-index: 99999999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: #fefefe;
    padding: 20px;
    border: 1px solid #888;
    width: 300px;
    border-radius: 8px;
    text-align: center;
}

.close {
    color: #aaa;
    float: right;
    font-size: 24px;
    cursor: pointer;
}

.close:hover {
    color: #000;
}
</style>

<script>


async function removeSaveFile(slot) {
    let slotHTML = `<span style="color:red;">${slot || "-"}</span>`;
    const confirmations = [
        `Are you sure to delete this game state on this slot ?`,
        `Are you really sure, bro? `,
        `Are you sure to delete this? You will not be able to undo this. `,
        `Jesteś pewien usunąć ten slot: ${slotHTML}?`,
        `Bist du sicher, diesen Slot: ${slotHTML} zu löschen? `,
        `Êtes-vous sûr de supprimer ce slot: ${slotHTML}? `,
        `¿Estás seguro de eliminar este slot: ${slotHTML}? `,
        `Sei sicuro di eliminare questo slot: ${slotHTML}? `,
        `Você tem certeza de excluir este slot: ${slotHTML}? `,
        `このスロット : ${slotHTML} を削除してもよろしいですか？ `,
        `<span style="color:yellow"> THIS IS THE LAST MESSAGE. ARE YOU SURE TO REMOVE THIS SLOT: ${slotHTML}</span>`
    ];

    // Krok 1: Poproś o przepisanie kodu przed potwierdzeniem
    const isCodeConfirmed = await confirmWithCode();
    if (!isCodeConfirmed) {
      //  customAlert("Deletion cancelled. Incorrect code.");
        return;
    }

    // Krok 2: Pytania potwierdzające
    let confirmed = true;
    for (let i = 0; i < confirmations.length; i++) {
        confirmed = await new Promise((resolve) => {
            showModal(confirmations[i], function() {
                resolve(true);
            }, function() {
                resolve(false);
            });
        });

        if (!confirmed) {
            customAlert("Deletion cancelled.");
            return; // Użytkownik przerwał proces
        }
    }

    // Krok 3: Usuń zapis
    try {
        const db = await initDB();
        const transaction = db.transaction("gameStates", "readwrite");
        const store = transaction.objectStore("gameStates");

        const request = store.delete(slot);

        request.onsuccess = function() {
            customAlert("Save file in slot " + slot + " deleted successfully.");
        };

        request.onerror = function(event) {
            customAlert("Failed to delete save file: " + event.target.error.message);
        };
    } catch (error) {
        customAlert("Error while deleting save file: " + error);
    }
}

let currentConfirmationCode = "";

// Funkcja do generowania i weryfikowania kodu przed usunięciem
async function confirmWithCode() {
    currentConfirmationCode = generateRandomCode(6);
    return new Promise((resolve) => {
        // Wyświetl modal z kodem
        document.getElementById("confirmationCode").textContent = currentConfirmationCode;
        document.getElementById("confirmationModal").style.display = "flex";

        // Przycisk potwierdzający
        document.getElementById("confirmCodeButton").onclick = function() {
            const userInput = document.getElementById("confirmationInput").value;
            if (userInput === currentConfirmationCode) {
                closeConfirmationModal();
                resolve(true);
            } else {
                customAlert("Incorrect code. Please try again.");
                resolve(false);
            }
        };

        // Przycisk anulowania
        document.getElementById("cancelCodeButton").onclick = function() {
            closeConfirmationModal();
            resolve(false);
        };
    });
}

// Zamknięcie modalu kodu
function closeConfirmationModal() {
    document.getElementById("confirmationModal").style.display = "none";
}

// Funkcja generująca losowy kod
function generateRandomCode(length) {
    const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}



let activatedCheats = 0
let currentCheatCode = "";

// Funkcja do otwierania modalu
function openCheatModal() {
    if (activatedCheats === 1) return;

    currentCheatCode = generateRandomCode(6);
    document.getElementById("cheatCode").textContent = currentCheatCode;
    document.getElementById("cheatModal").style.display = "flex";
}

// Funkcja do zamykania modalu
function closeCheatModal() {
    document.getElementById("cheatModal").style.display = "none";
}

// Funkcja generująca losowy kod
function generateRandomCode(length) {
    const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

// Funkcja weryfikująca kod wpisany przez użytkownika
function verifyCheatCode() {
    const userCode = document.getElementById("cheatInput").value;
    if (userCode === currentCheatCode) {
        activatedCheats = 1;
        localStorage.setItem('activatedCheats', '1');
        activateCheatButton();
        closeCheatModal();
    } else {
        
    }
}

// Aktywacja przycisku cheatów po poprawnym wpisaniu kodu
function activateCheatButton() {
    const cheatButton = document.getElementById("cheatButton");
    cheatButton.style.opacity = "1.0";
    cheatButton.disabled = true; // Wyłączenie przycisku po aktywacji cheatów
}

// Funkcje zarządzające stylem i działaniem pozostałych przycisków
function toggleAndStyleButton(button) {
    const varName = button.getAttribute('data-var');
    if(varName!=="creativemode" &&varName!=="noclip" ){
    options[varName] = options[varName] === 0 ? 1 : 0;
    updateButtonStyle(button, options[varName]);
    }else{
      if(activatedCheats==1){
        options[varName] = options[varName] === 0 ? 1 : 0;
updateButtonStyle(button, options[varName]);
      }else{
        button.style.backgroundColor = "gray"
      }
}

}

function updateButtonStyle(button, value) {
  const varName = button.getAttribute('data-var');
  if(varName!=="creativemode"&&varName!=="noclip"){
    button.style.backgroundColor = value === 0 ? "darkred" : "green";
  }else{
    button.style.backgroundColor = value === 0 ? "grey" : "green";
  }
}

function toggleAdvanced() {
    const advanced = document.getElementById("advanced");
    advanced.style.display = (advanced.style.display === "none" || advanced.style.display === "") ? "flex" : "none";
}

// Sprawdzenie przy załadowaniu strony, czy cheaty są aktywowane
document.addEventListener("DOMContentLoaded", () => {
    if (activatedCheats === 1) {
        activateCheatButton();
    }
});

// Inicjalizacja przycisków na podstawie wartości w options
document.querySelectorAll('button[data-var]').forEach(button => {
    const varName = button.getAttribute('data-var');
    updateButtonStyle(button, options[varName]);
});
</script>


</div>

 
    <script>
    // Funkcja pokazująca lub ukrywająca "advanced"
function toggleadvanced() {
  const advanced = document.getElementById("advanced");
  advanced.style.display = (advanced.style.display === "none" || advanced.style.display === "") ? "flex" : "none";
}
let langPlactive=0;
var langPl = {
     
    items:{
    hellsapling: "Sadzonka piekieł",
    abysssapling: "Sadzonka otchłani",
    hell_boomerang: "Piekielny boomerang",
    hallucinate: "haludzyngi >:] ",
    a1bed: "Łóżko 1",
    a2bed: "Łóżko 2",
    can: "Puszka",
    carpet: "Dywan",
    polishedfloor: "Polerowana podłoga",
    road2: "Droga 2",
    candle: "Świeca",
    bed: "Łóżko",
    draco_boomerang: "Drako boomerang",
    helllog: "Piekielny pień",
    hellwood: "Piekielne drewno",
    abyssgel: "Żel otchłani",
    abysswood: "Drewno otchłani",
    abysslog: "Pień otchłani",
    hellgrass: "Piekielna trawa",
    hellplank: "Piekielna deska",
    abyssgrass: "Trawa otchłani",
    abyssplank: "Deska otchłani",
    warporb: "Kula teleportacyjna",
    titanium_boomerang: "Tytanowy boomerang",
    good_boomerang: "Dobry boomerang",
    boomerang: "Boomerang",
    dracobuff: "Draco buff",
    briarempty: "Dzika róża",
    iron_shovel: "Żelazna łopata",
    algae_item: "wodorosty",
    goldnugget: "Złoty nugget",
    leafbowl: "Miseczka z liści",
    leafbowlwithwater: "Miseczka z liści z wodą",
    leafbowlwithcleanwater: "Miseczka z liści z czystą wodą",
    statue2: "Statua 2",
    statue1: "Statua 1",
    blower: "Dmuchawa",
    kiln: "Piec",
    hill_climber: "Wspinacz wzgórz",
    hill1: "Wzgórze",
    climbhill: "Wejście Na Wzgórze",
    blueflower2: "Niebieski kwiat 2",
    redflower2: "Czerwony kwiat 2",
    deepblues: "kwiatek :)",
    lightwhite: "kozi kwaitek",
    grassdeco: " trawa",
    extinguished_campfire: "Wygaszone ognisko",
    cactusempty: "Kaktus",
    deadgrass: "Martwa trawa",
    godwand: "Różdżka boga",
    itemroad: "Droga",
    grass2: "Trawa 2",
    statueofgods: "Statua bogów",
    leaves: "Liście",
    deadgrassfloor2: "Podłoga z martwej trawy",
    healthregenerator: "Regenerator zdrowia",
    staminaregenerator: "Regenerator staminy",
    myosotis: "\nNiezapominajka",
    redanvil: "Czerwone kowadło",
    magicwand: "magiczna Różdżka",
    greenwand: "Zielona różdżka",
    magicwandofsharp: "Różdżka cięcia",
    hyperblastwand: "Różdżka hiperbłysków",
    forestgrasslayer: "Warstwa leśnej trawy",
    broom: "Miotła",
    blush: "Róż",
    forestleaf: "Liść leśny",
    gravestone: "Nagrobek",
    moltensword: "Miecz Magmy",
    hellsword: "Piekielny miecz",
    knive: "Nóż",
    hellknive: "Piekielny nóż",
    aquagem: "Akwamaryna",
    darkore: "Ruda Ciemnoty",
    hellessence: "Piekielna esencja",
    celestialfragment: "Nieziemski Fragment",
    celestialspawner: "Przywołaj Niebiański ",
    roadfloor: "Droga",
    lamptorch: "Zwykła Lampa",
    granite: "Granit",
    basalt: "Bazalt",
    hellgem: "Piekielny klejnot",
    hellwall2: "Piekielna ściana",
    titaniumbuff:  "tytanowy buff",
    hellbuff: "Piekielny buff",
    table: "Stół",
    compass: "Kompas",
    defensering: "Pierścień obrony",
    sing: "Tabliczka",
    stonesing: "Kamienna tabliczka",
    deepgodspawner: "Morska Bestia",
    itemfence: "Ogrodzenie",
    emptyblackberry: "Jeżyny",
    brickfloor2: "Podłoga z cegieł",
    godstatue: "Statua boga",
    icemedalion: "Lodowy medalion",
    speedmedalion: "Medalion prędkości",
    healmedalion: "Medalion uzdrawiający",
    magiclanter: "Magiczna latarnia",
    magicgem: "Magiczny klejnot",
    desertcore: "Rdzeń pustyni",
    geyser: "Gejzer",
    abysscore: "Rdzeń otchłani",
    icesword: "Lodowy miecz",
    frozeningot: "Zamarznięty ingot",
    snowflower: "Śnieżny kwiat",
    truegodsword: "Prawdziwy miecz boga",
    thistleseeds: "Nasiona ostu",
    gel: "Żel",
    abyssgem: "Klejnot otchłani",
    gelblock: "Blok żelu",
    crystal1: "Kryształ 1",
    crystal2: "Kryształ 2",
    crystal3: "Kryształ 3",
    universeechoes: "Echa wszechświata",
    trueuniversesword: "Prawdziwy miecz wszechświata",
    trueuniverseorb: "Prawdziwa kula wszechświata",
    seashiny: "Morskie klejnoty",
    aquacore: "Morski Rdzeń",
    aquagodshell: "Muszla boga wody",
    universesword: "Miecz wszechświata",
    universefragment: "Fragment wszechświata",
    shell: "Muszla",
    corruptioncore: "Rdzeń zepsucia",
    coral1: "Korala 1",
    coral2: "Korala 2",
    aquawall: "Ściana wody",
    echofabric: "Tkanina echa",
    echorocks: "Kamienie echa",
    aquaspear: "Wodna włócznia",
    blossomblock: "Blok kwiatowy",
    glowblossom: "Świecący kwiat",
    aquaore: "Ruda wody",
    corruptedchalcopyrite: "Zepsuty chalkopiryt",
    fleshvolume: "Objętość mięsa",
    fleshdumbass: "Zespawnuj Mięso",
    fleshsaber: "Miecz mięsa",
    coloressence: "Esencja kolorów",
    rainbow: "Miecz Tęcza",
    iron_mace: "Żelazny Buzdygan",
    nightgem: "Nocny klejnot",
    nightsword: "Nocny miecz",
    goodmace: "Dobry Buzdygan",
    goodsword: "Dobry miecz",
    thundersword: "Miecz Zeusa",
    evileye: "Oko Grozy",
    evilsummoner: "Przywołaj Zło",
    soulofsharp: "Dusza ostrości",
    aquaticevent: "Wydarzenie wodne",
    sharpsaw: "Ostra piła",
    sharpmace: "Ostra maczuga",
    dandelionseeds: "Nasiona mniszka",
    candy: "Cukierek",
    energybowl: "Miska energii",
    healthbowl: "Miska zdrowia",
    iron_sword: "Żelazny miecz",
    spikegod_essence: "Esencja boga kolców",
    voltary_essence: "Esencja voltary'ego",
    unknown: "???",
    violetfloor: "Fioletowa podłoga",
    black_elderberry_tree: "Krzew Bzu",
    house_wall: "Ściana domu",
    gypsumhouse: "Dom gipsowy",
    gypsumdoor: "Drzwi gipsowe",
    gypsumroof: "Dach gipsowy",
    heavybag: "Ciężka torba",
    houseroof: "Dach domu",
    ryeroof: "Dach żyta",
    poppy: "Mak",
    brickhouse: "Ceglany dom",
    rockhouse: "Kamienny dom",
    door: "Drzwi",
    mycelium: "Grzybnia",
    rye_seeds: "Nasiona żyta",
    yeast: "Drożdże",
    beer: " Piwo ",
    bread_sample: "Forma chleba",
    black_elderberries: "CzarnyBez",
    fermentator: "Fermentor",
    flour: "Mąka",
    sugar: "Cukier",
    waterdrop: "Kropla wody",
    smoother: "Wygładzacz",
    bread: "Chleb",
    smooth_stone: "Gładki kamień",
    trout: "Pstrąg",
    gypsumfloor: "Podłoga gipsowa",
    cave_wall: "Ściana jaskini",
    rock: "Kamień",
    cooked_trout: "Usmażony pstrąg",
    rye: "Żyto",
    honey_mushrooms: "Opieńki",
    cinnabar: "Cynabar",
    mercury: "Rtęć",
    pipette: "Pipeta",
    ilmenite: "Ilmenit/Tytan",
    salmon: "Łosoś",
    cooked_salmon: "Usmażony łosoś",
    fishing_rod: "Wędka",
    opal: "Opal ",
    opalblock: "Blok opalu ",
    emeraldblock: "Blok szmaragdu",
    sapphireblock: "Blok szafiru",
    rubyblock: "Blok rubinu",
    sapphirefloor: "Podłoga szafiru",
    rubyfloor: "Podłoga rubinu",
    emeraldfloor: "Podłoga szmaragdu",
    emerald: "Szmaragd ",
    glass: "Szkło",
    pyrite: "Piryt",
    pickaxe: "Kilof",
    cavemakingpickaxe: "Kilof",
    ruby: "Rubin",
    sapphire: "Szafir",
    bed1: "Łóżko 1",
    cactus_fruit: "Owoc kaktusa",
    alchemy_table: "Stół alchemiczny",
    gypsum: "Gips",
    wood_manipulator: "Manipulator drewna",
    sulfur: "Siarka",
    grains_of_sand: "Ziarna piasku",
    planks: "Deski",
    planks_floor: "Podłoga z desek",
    gypsum_dirt: "Gipsowa ziemia",
    bone: "Kość",
    bone_sword: "Miecz z kości",
    bowl: "Miska",
    bowl_with_seawater: "Miska z wodą morską",
    bowl_with_water: "Miska z wodą",
    sandblock2: "Blok piasku ",
    gypsumblock: "Blok gipsowy",
    copper: "Miedź",
    chalcopyrite: "Chalkopiryt",
    bunnmeat: "Mięso królika",
    cooked_bunnmeat: "Usmażone mięso królika",
    iron: "Żelazo",
    iron_bar: "Żelazny stop",
    copper_bar: "Miedziany stop",
    extrabag: "Dodatkowa torba",
    fiber_fabric: "Tkanina",
    magnetite_powder: "Proszek magnetytu",
    coal: "Węgiel",
    iron_spear: "Żelazna włócznia",
    copper_spear: "Miedziana włócznia",
    anvil: "Kowadło",
    stonedirt: "Ziemia kamienista",
    larger_bag: "Większa torba",
    lit_furnace: "Rozpalony piec",
    furnace: "Piec",
    fiber: "Włókno",
    hand_torch: "Ręczna pochodnia",
    clayblock1: "Blok gliny",
    long_spear: "Długa włócznia",
    raw_sharkmeat: "Surowe mięso rekina",
    cooked_sharkmeat: "Usmażone mięso rekina",
    decrafter: "Defragmentator nwm?",
    sapling: "Sadzonka",
    grasslayer: "trawa",
    stoneshovel: "Kamienna łopata",
    clay: "Glina",
    clayblock: "Blok gliny",
    brick: "Cegła",
    brickwall: "Ceglana ściana",
    brickfloor: "Ceglana podłoga",
    ash: "Popiół",
    ashfloor: "Podłoga z popiołu",
    log_floor: "Podłoga z pnia",
    nettle: "Pokrzywa",
    bigrock: "Duży kamień",
    stone: "Kamień",
    sharpstone: "Ostry kamień",
    stick: "Patyk",
    longstick: "Długi patyk",
    woodboard: "Deska drewniana",
    treebark: "Kora drzewa",
    yew: "Cis",
    "briar-fruit": "Języnka",
    kite: "Czubajka Kania",
    resin: "Żywica",
    ignited_fiber: "Rozpalone włókno",
    handdrill_kit: "Zestaw wiertarki ręcznej",
    fireroll: "Rolka ognia",
    cordage: "Sznur",
    dowel: "Kołek",
    log: "Pień",
    stone_axe: "Kamienna siekiera",
    stone_scyte: "Kamienna kosa",
    fireplow: "Pług ognia",
    birch_powder: "Proszek brzozowy",
    blackberry_fruit: "Owoc jeżyny",
    stone_floor: "Kamienna podłoga",
    stone_wall: "Kamienna ściana",
    fiber_floor: "Podłoga z włókna",
    log_wall: "Ściana z pnia",
    daffodil: "Żonkil",
    flax: "Len",
    fern: "Paprotka",
    trueuniversespawner: "PrawdziwyWszechświat",
    thistle: "Oset",
    toadstool: "Muchomor",
    violet: "Fiołek",
    yellow: "Żółty",
    dandelion: "Mniszek",
    torch: "Pochodnia",
    campfire: "Ognisko",
    ignited_fiber: "Rozpalone włókno",
    pointed_stick: "Spiczasty patyk",
    thistleroot: "Korzeń ostu",
    cooked_thistleroot: "Usmażony korzeń ostu",
    titaniumsword: "Tytanowy miecz",
    titaniummace: "Tytanowy Buzdygan",
    salt: "Sól",
    titaniumbar: "Tytan",
    titaniumdioxide: "Dwutlenek tytanu",
    
    coconut:"Kokos ",
    palmlog:"Drewno Palmowe",
    palmsapling:"Sadzonka Palmy",
    stonesing: " Kamienna Tabliczka",
    snowgrass2: "Śnieg",
    snowgrass: "Śnieg",
    bow: "łuk",
    arrows: "strzały", 
    powerfullarrows: "potężne strzały",
    goodarrows: "potężne strzały",
    hellbow: "piekielny łuk",
    quantumbow: " łuk kwantowy",
    moltenbow: "stopiony łuk",
    rainbowbow: "tęczowy łuk",
    nightbow: " łuk nocy ",
    darkbow: " łuk ciemnoty ",
    plantmaker:" Stuł Botaniczny",
    bottle:" Butelka",
    cauldron:" Kocioł",
    fountain:" Fontanna",
    nametag:" Znacznik",
    carrot:" Marchewka",
    shell1:" Muszla",shell2:" Muszla",shell3:" Muszla",
    wildcarrot1:" Marchew",
    soup:" Zupa ",
    textstone:" Kamień z tekstem"
}};

        var slots = 8;  // Max slots
        var allItems = { // Definicja tekstur przedmiotów

carrot: "./carrot.png",
sushi: "./sushi.png",
shell1: "./shell1.png",
shell2: "./shell2.png",
shell3: "./shell3.png",
wildcarrot: "./wildcarrot1.png",
     
soup: "./soup.png",

bottle: "./bottle.png",
plantmaker: "./plantmaker.png",
    cauldron: "./cauldron1.png",
    fountain: "./fountain1.png",
    textstone: "./textstone.png",
    nametag: "./nametag.png",
tallgrass: "./grass2.png",
bush: "./bush.png",
plantmaker: "./plantmaker.png" ,
    mercurybottle: "./mercurybottle.png",
     bow: "./bow.png",
     nightbow: "./nightbow.png",
     darkbow: "./darkbow.png",
     arrows: "./arrow.png",
     powerfullarrows:"./powerfullarrow.png",
     goodarrows: "./goodarrow.png",
     rainbowbow: "./rainbowbow.png",
    quantumbow: "./quantumbow.png",
    moltenbow: "./moltenbow.png",
     hellbow: "./hellbow.png",
    eggs: "./eggs.png",
    eggshells: "./eggshells.png",
    friedegg: "./friedegg.png",
    feather: "./feather.png",
    rarefeather: "./rarefeather.png",
    mythicfeather: "./mythicfeather.png",
    calciumacetylide: "./calciumacetylide.png",
    cigarettes: "./cigarettes.png",
     
    diamante: "./diamante.png",
    cinnabargeode: "./cinnabargeode.png",
        
        palmlog: "./palm1.png",
    coconut: "./coconut.png",
    palmsapling: "./palmsapling.png",
    stonesing: "./stonesing.png",
    
hellsapling: "./hellsapling.png",
abysssapling: "./abysssapling.png",
snowgrass2:"./snowgrass.png",
hell_boomerang: "./hell_boomerang.png",
hallucinate: "./hallucinate1.png",
a1bed: "./1bed.png",
    a2bed: "./2bed.png",
    can: "./can.png",
    carpet: "./carpet.png",
    polishedfloor: "./polishedfloor.png",
    road2: "./road2.png",
    candle: "./candle.png",
    bed:"./bed.png",
    draco_boomerang: "./draco_boomerang.png",
    helllog: "./helltree0.png",
    hellwood: "./hellwood.png",
    abyssgel: "./abyssgel.png",
    abysswood: "./abysswood.png",
    abysslog: "./abysstree0.png",
hellgrass: "./hellgrass1.png",
    hellplank: "./hellplank1.png",
    abyssgrass: "./abyssgrass1.png",
    abyssplank: "./abyssplank1.png",
    warporb: "./warporb1.png",
     titanium_boomerang:"./titanium_boomerang.png",
     good_boomerang:"./good_boomerang.png",
    boomerang: './boomerang.png',
    dracobuff: './dracobuff.png',
    
briarempty: './briarempty.png',
iron_shovel: './iron_shovel.png',
algae_item: './algae_item.png',
 goldnugget: './goldnugget.png',
 leafbowl: './leafbowl.png',
 leafbowlwithwater: './leafbowlwithwater.png',
 leafbowlwithcleanwater: './leafbowlwithcleanwater.png',

statue2: './statue2_2.png',
 statue1: './statue1_2.png',
 blower: './blower.png',
 kiln: './kiln.png',
hill_climber: './hill_climber.png',
hill1: './chunk.png',
climbhill: './climbhill.png',
 blueflower2: './blueflower2.png',
 redflower2: './redflower2.png',
deepblues: './deepblues.png',
 lightwhite: './lightwhite.png',
grassdeco: './grassdeco1.png',
extinguished_campfire: './extinguished_campfire1.png',
 cactusempty: './cactusempty.png',
  deadgrass: './dead grass.png',
  godwand: './godwand.png',
  itemroad: './road.png',
  grass2:"./grass2none.png",
  statueofgods: './statueofgods1.png',
  leaves: './leaves.png',
  deadgrassfloor2: './deadgrass.png',
        healthregenerator: './healthregenerator.png',
        staminaregenerator: './staminaregenerator.png',
        myosotis:"./Myosotis.png",
        redanvil: './redanvil.png',
        magicwand: './magicwand.png',
        greenwand:"./greenwand.png",
        magicwandofsharp: './wandofsharp.png',
  hyperblastwand: './hyperblastwand.png',
        forestgrasslayer:"./forestgrass.png",
        broom: './broom.png',
        blush: './forestblush.png',
  forestleaf: './forestleaf.png',
  gravestone: './gravestone.png',
        moltensword: './moltensword.png',
  hellsword: './hellsword.png',
  knive: './knive.png',
  hellknive: './hellknive.png',
        aquagem: './aquagem.png',
  darkore: './darkore.png',
  hellessence: './hellessence.png',
  celestialfragment: './celestialfragment.png',
  celestialspawner: './celestialspawner.png',
  darkore: './darkore.png',
  
        
        roadfloor:"./roadfloor.png",
        lamptorch:"./lamp2.png",
  granite: './granite.png',
  basalt: './basalt.png',
        hellgem:"./hellgem.png",
        hellwall2:"./hellwall1.png",
        titaniumbuff:"./titaniumbuff.png",
        hellbuff:"./hellbuff.png",
        table:"./table.png",
  compass:"./compass.png",
  defensering:"./defensering.png",
  sing:"./sing.png",
  deepgodspawner:"./deepgodspawner.png",
  itemfence: "./itemfence.png",
  emptyblackberry: "./emptyblackberry.png",
  brickfloor2: "./brickfloor2.png",
  godstatue: "./godstatue.png",
  icemedalion: "./icemedalion.png",
  speedmedalion: "./speedmedalion.png",
  healmedalion: "./cursedmedalion.png",
  magiclanter: "./magiclantern.png",
  magicgem: "./magicgem.png",
  desertcore: "./desertcore.png",
geyser:"./geyser1.png",
abysscore:"./coreofabyss.png",
icesword:"./icesword.png",
frozeningot: "./frozeningot.png",
  snowflower: "./snowflower.png",
truegodsword:"./truegodsword.png",
thistleseeds:"./thistleseeds.png",
gel: "./gel.png",
abyssgem:"./abyssgem.png",
  gelblock: "./gelfloor.png",
crystal1: "./crystal1.png",
  crystal2: "./crystal2.png",
  crystal3: "./crystal3.png",
universeechoes:"./universeechoes.png",
trueuniversesword:"./trueuniversesword.png",
trueuniverseorb:"./trueuniverseorb.png",
seashiny: "./seashiny.png",
  aquacore: "./aquacore.png",
  aquagodshell: "./aquagodshell.png",
        universesword:"./universesword.png",
  universefragment:"./universefragment.png",
  shell:"./shell.png",
  corruptioncore:"./corruptioncore.png",
  coral1:"./coral1.png",
  coral2:"./coral2.png",
  aquawall:"./aquawall1.png",
  echofabric:"./echofabric.png",
  echorocks:"./echorocks.png",
  aquaspear:"./aquaspear.png",
  blossomblock:"./blossomblock.png",
  glowblossom:"./glowblossom.png",
  aquaore:"./aquaore.png",
  corruptedchalcopyrite:"./corruptedchalcopyrite.png",
  
  
        
fleshvolume:"./fleshvolume.png",
  fleshdumbass:"./fleshdumbass.png",
  fleshsaber:"./fleshsaber.png",
  coloressence:"./colorsessence.png",
rainbow:"./rainbow.png",
  
        
        
        iron_mace: './iron-mace.png',
        nightgem: "./nightgem.png",
  nightsword: "./nightsword.png",
  goodmace: "./godmace.png",
  goodsword: "./godsword.png",
  thundersword: "./thundersword.png",
        evileye: "./evileye.png",
  evilsummoner: "./evilsummoner.png",
  soulofsharp: "./soulofsharp.png",
  aquaticevent: "./aquaticevent.png",
  soulofsharp: "./soulofsharp.png",
  sharpsaw: "./sharpsaw.png",
  sharpmace: "./sharpmace.png",
  
        dandelionseeds:"./dandelionseeds.png",
        candy: "./candy.png",
  energybowl: "./energybowl.png",
  healthbowl: "./healthbowl.png",

  iron_sword: './iron-sword.png',
  spikegod_essence: './spikegodspawner.png',
  voltary_essence: './voltaryspawner.png',
  unknown: './unknown1.png',
  violetfloor: './violetfloor.png',
  
        black_elderberry_tree: './black_elderberry_tree.png',
        house_wall: './housewall.png',
        gypsumhouse: './gypsumhouse.png',
    gypsumdoor: './gypsumdoor.png',
    gypsumroof: './gypsumroof.png',
        heavybag: './heavybag.png',
        houseroof: './rooftop.png',
        ryeroof: './ryeroof.png',
  poppy: './poppy.png',
  brickhouse: './brickhouse.png',
  rockhouse: './rockhouse.png',
  table: './table.png',
  door: './door.png',
  mycelium: './mycelium.png',
  rye_seeds: './rye_seeds.png',
  yeast: './yeast.png',
  beer: './beer.png',
  bread_sample: './bread_sample.png',
  black_elderberries: './black_elderberries.png',
  fermentator: './fermentator.png',
  flour: './flour.png',
  sugar: './sugar.png',
  waterdrop: './waterdrop.png',
  fermentator: './fermentator.png',
  smoother: './smoother.png',
  bread: './bread.png',
  smooth_stone: './smooth-stone.png',
  
        trout: './trout.png',
        gypsumfloor: './gypsumfloor.png',
        cave_wall: './cavewall.png',
       rock: './rock.png',
  cooked_trout: './cooked_trout.png',
        rye: './rye.png',
  flour: './flour.png',
  honey_mushrooms: './honey-mushroom.png',
        cinnabar: './cinnabar.png',
  mercury: './mercury.png',
  pipette: './pipete.png',
  ilmenite: './ilmenite.png',
  
  salmon: './salmon.png',
  cooked_salmon: './cooked_salmon.png',
  
  fishing_rod: "./fishing_rod.png",
  
        opal: './opal1.png',
  opalblock: './opalblock1.png',
  emeraldblock: './emeraldblock.png',
  sapphireblock: './sapphireblock.png',
  rubyblock: './rubyblock.png',
  sapphirefloor: './sapphirefloor.png',
  rubyfloor: './rubyfloor.png',
  emeraldfloor: './emeraldfloor.png',
  emerald: './emerald.png',
        glass: './glass.png',
        pyrite : './pyrite.png',
        pickaxe: './pickaxe.png',
        cavemakingpickaxe: './great-cave-making-pickaxe.png',
  ruby: './ruby.png',
  sapphire: './sapphire.png',
        bed1: './fiberbed.png',
  cactus_fruit: './cactus-fruit.png',
        alchemy_table: './alchemy_table.png',
  gypsum: './gypsum.png',
  wood_manipulator: './wood_manipulator.png',
  sulfur: './sulfur.png',
  grains_of_sand: './sand2.png',
  planks: './planks.png',
  planks_floor: './planks_floor.png',
  gypsum_dirt: './gypsum_dirt.png',
  bone: './bone.png',
  bone_sword: './bone_sword.png',
  bowl: './bowl.png',
  bowl_with_seawater: './bowl_with_seawater.png',
  bowl_with_water: './bowl_with_water.png',
  sandblock2: './sandblock.png',
  gypsumblock: './gypsumblock.png',
  
        copper: './copper.png',
        chalcopyrite: './chalcopyrite.png',
        bunnmeat: './bunnmeat.png',
  cooked_bunnmeat: './cooked_bunnmeat.png',
iron: './iron.png',
iron_bar: './iron-bar.png',
copper_bar: './copper-bar.png',
copper: './copper.png',
extrabag: './extra-bag.png',
fiber_fabric: './fiber-fabric.png',
magnetite_powder: './magnetite-powder.png',
coal: './coal.png',
iron_spear: './iron-spear.png',
copper_spear: './copper-spear.png',
anvil: './anvil.png',
  stonedirt: './dirt-with-stones.png.png',
  larger_bag: './larger-bag.png',
  lit_furnace: './lit_furnace.png',
  furnace: './furnace.png',
"fiber": "./fiber.png",
hand_torch: './hand-torch.png',
  magnetite: './magnetite.png',
"clayblock1": "./clayblock.png",
long_spear: './long-spear.png',
  raw_sharkmeat: './raw_sharkmeat.png',
  cooked_sharkmeat: './cooked_sharkmeat.png',
coal: './coal.png',
decrafter  :"./decrafter.png",
sapling  :"./sapling.png",
"grasslayer": "./grass.png",
"stoneshovel": "./shovel.png",
clay: './clay.png',
clayblock: './clayblock.png',
brick: './brick.png',
brickwall: './brickwall.png',
brickfloor: './brickfloor.png',
ash: './ash1.png',
ashfloor: './ashblock.png',
"log_floor": "./log_floor.png",
            "nettle": "./nettle.png",
            "bigrock": "./largerock.png",
            "stone": "./stones.png",
            "sharpstone": "./sharpstone.png",
            "stick": "./sticks.png",
            "longstick": "./longstick.png",
            "woodboard": "./board.png",
            "treebark": "./treebark.png",
            "yew": "./yew-fruit.png",
            "briar-fruit": "./briar-fruit.png",
            "kite": "./kite.png",
            "resin": "./resin.png",
"woodboard": "./board.png","ignited_fiber": "./ignited_fiber.png",
"handdrill-kit": "./handdrill.png",
"fireroll": "./fireroll.png",
"cordage": "./cordage.png",
"dowel": "./dowel.png",
"log": "./tree0.png",
"stone_axe": "./stone_axe.png",
"stone_scyte": "./stone_scyte.png",
"fireplow": "./fireplow.png",
"birch-powder": "./birch-powder.png",
"blackberry-fruit": './blackberry-fruit.png',
stone_floor: './stone_floor.png',
  stone_wall: './stone_wall.png',
  fiber_floor: './fiber_floor.png',
  log_wall: './log_wall.png',
  daffodil: './daffodil.png',
  flax: './flax0.png',
  fern: './fern.png',
  trueuniversespawner:"./trueuniversespawner.png",
  thistle: './thistle.png',
  toadstool: './toadstool.png',
  violet: './violet.png',
  yellow: './yellow.png',
  dandelion: './dandelion.png',
  torch: './torch.png',
  campfire: './campfire.png',
  ignited_fiber: './embered_fiber.png',
  pointed_stick: './pointed_stick.png',
  thistleroot: './thistleroot.png',
  cooked_thistleroot: './cooked_thistleroot.png',
  titaniumsword: "./titaniumsword.png",
  titaniummace: "./titaniummace.png",
  salt: './salt.png',
  titaniumbar: './titaniumbar.png',
  titaniumdioxide: './titaniumdioxide.png',
        };

        // Definicja receptur
        var recipes = {
"fiber": [["treebark", "treebark"]],
"fishing_rod": [["longstick", "cordage","cordage","sharpstone"]],
"bed1": [["fiber_fabric","fiber_fabric"]],
"sandblock2": [["grains_of_sand"]],
"long_spear": [["longstick", "pointed_stick","sharpstone","cordage"]],
"torch": [["resin", "stick","ignited_fiber"]], 
"decrafter": [["stone", "woodboard","woodboard","stone","woodboard"]],
"campfire": [["stone", "stone","ignited_fiber"]],
"log_floor": [["log", "log","log"]],
"sharpstone": [["stone","bigrock"]],
"fireplow": [["longstick", "woodboard"]],
"woodboard": [["log", "sharpstone"]],
"pointed_stick": [["longstick", "sharpstone"]],
"fireroll": [["fiber", "fiber","woodboard","woodboard","birch-powder"]],
"stone_floor": [["stone", "stone", "stone", "stone", "stone", "stone"]],
"fiber_floor": [["fiber", "fiber", "fiber", "fiber", "fiber", "fiber"]],
"log_wall": [["log", "log", "log", "log"]],
"stone_wall": [["bigrock", "bigrock", "bigrock", ]],
"cordage": [["fiber", "treebark"]],
"stone_axe": [["longstick", "sharpstone","cordage"]],
"stoneshovel": [["longstick", "sharpstone","cordage","cordage"]],
"thistleroot": [["thistle"]],
"brickwall": [["clay", "brick", "brick", "brick"]],
"brickfloor": [["clay", "brick", "brick", "brick"]],
"clayblock1": [["clay", "clay"]],
"ashfloor": [["ash", "ash","ash"]],
"fiber_fabric": [["fiber", "fiber","fiber"]],
"extrabag": [["fiber_fabric", "fiber_fabric","fiber_fabric"]],
"wood_manipulator":[["iron_bar","woodboard","log_wall","log_wall"]],
"gypsumfloor":[["gypsum","gypsum"]],
"fermentator": [["bowl", "fiber_fabric", "fiber_fabric"]],
"flour": [["rye", "rye"]],
"opalblock": [["opal"]],
"emeraldblock": [["emerald"]],
"sapphireblock": [["sapphire"]],
"rubyblock": [["ruby"]],
"emeraldfloor": [["emerald"]],
"sapphirefloor": [["sapphire"]],
"rubyfloor": [["ruby"]],
"gypsum_dirt": [["gypsum"]],
"bone_sword": [["bone","bone","bone","sharpstone"]],
"gypsum": [["gypsum_dirt"]],
"leafbowl": [["forestleaf","forestleaf"]], 
"gelblock": [["gel","gel","gel"]],
"boomerang": [["woodboard","woodboard","gelblock"]],
"truegodsword": [["truegodsword"]],
"godwand": [["godwand"]],
"hill_climber": [["longstick","longstick","woodboard","stick","cordage"]],
"climbhill": [["hill1", "grasslayer"]],
"blower": [["woodboard", "stick","stick","woodboard"]],
"warporb": [["abyssgel", "abyssgel", "abyssgem", "abyssgem"],["helllog","hellgem","hellwood"],["aquaore","echorocks","geyser"]],
"hellplank": [["hellwood", "helllog"]],
"abyssplank": [["abysswood", "abysslog"]],
"sing": [["woodboard", "woodboard","longstick"]],
"stonesing": [["bigrock", "woodboard","longstick"]],

"carpet": [["fiber", "poppy"]],
"hallucinate": [["toadstool","gel"]],
"bed": [["bed1","poppy"]],
"bow": [["longstick","cordage","cordage"]],
"arrows": [["stick","feather","sharpstone"]],
"goodarrows": [["stick","rarefeather","sharpstone"]],
"powerfullarrows": [["stick","mythicfeather","sharpstone"]],
"plantmaker": [["woodboard","grasslayer","yellow","woodboard"]],
        };
        var canbedecrafted=["brickwall","clayblock1","ashfloor","cordage","fiber","fireplow","stone_wall","fiber_floor","torch","campfire","brickfloor","fireroll","decrafter","log_floor","log_wall","sharpstone","pointed_stick","thistleroot","woodboard","hand_torch","stoneshovel","stone_axe","iron_spear","copper_spear","fiber_fabric","extrabag","cavemakingpickaxe","pickaxe","opalblock","emeraldblock","emeraldfloor","sapphireblock","sapphirefloor","rubyfloor","rubyblock","planks","planks_floor","houseroof","house_wall","furnace","kiln","campfire","decrafter","log_floor","log_wall","stone_floor","gelblock","aquaspear","goodsword","universesword","sharpsaw","nightsword","fleshsaber","goodmace","truegodsword","trueuniversesword","iron_mace","iron_sword","sharpmace","aquagodshell","deepgodspawner","voltary_essence",
        "fleshdumbass","housewall","houseroof","housefloor","planks_floor","planks","table","titaniumbuff","titaniumsword","lamptorch","brickfloor2","trueuniversespawner","deepgodspawner","hellbuff","hellsword","moltensword","knive","hellknive","magicwand","magicwandofsharp","hyperblastwand","greenwand","blower","forestleaf","titanium_boomerang","boomerang","good_boomerang","gypsumroof","gypsumhouse","gypsumdoor","sing","hallucinate","stonesing","dracobuff","plantmaker","cauldron","titaniumbar","fountain","textstone"
        ]
var plantmakerrecipes = {
    "grasslayer": [["gelblock"]],
    "deadgrassfloor2": [["gelblock"]],
    "snowgrass2": [["gelblock","gel"]],
    "yellow": [["gel","gel","gel"]],
    "deepblues": [["gel","gel","gel"]],
    "poppy": [["gel","gel","gel","gel"]],
    "redflower2": [["gel","gel","gel"]],
    "grassdeco": [["gel","gel","gel"]],
    "blush": [["gel","gel","gel"]],
    "forestgrasslayer": [["gel","gel","gel"]],
    "nettle": [["gel","gel","gel"]],
    "flax": [["gel","gel","gel"]],
    "fern": [["gel","gel","gel"]],
    "violet": [["gel","gel","gel"]],
    "daffodil": [["gel","gel","gel"]],
    "tallgrass": [["gel","gel","gel"]],
    "snowflower": [["gel","gel","gel"]],
}
var campfirerecipes = {
"cooked_thistleroot": [["thistleroot"]],
"ignited_fiber": [["fiber"]],
"candle": [["resin","treebark","glass"]],
"roadfloor":[["stone"]],
 "candy": [["sugar"]],
 "energybowl": [["sugar", "dandelion", "bowl_with_water"]],
"furnace": [["bigrock","bigrock","brick","brick","blower"]],
"kiln": [["bigrock","bigrock","clay","ash"]],
"copper": [["chalcopyrite","coal"]],

//"iron": [["magnetite_powder","magnetite_powder","magnetite_powder","magnetite_powder"]],
"coal": [["stick"]],
"hand_torch": [["torch","torch","torch"]],
"ash": [["stick"]],
"cooked_bunnmeat": [["bunnmeat"]],
"cooked_salmon": [["salmon"]],
"cooked_trout": [["trout"]],
"sugar": [["thistleroot","thistleroot"],["cooked_thistleroot","cooked_thistleroot"],["dandelion","dandelion","dandelion"],["blackberry-fruit"],["briar-fruit","briar-fruit"]],
"rye_seeds":[["rye","rye"]],
"bowl_with_water": [["bowl_with_seawater"]],
"leafbowlwithcleanwater": [["leafbowlwithwater"]],
"friedegg": [["eggs"]],
}
var wood_manipulator_recipes = {
  "treebark": [["log","log"]],
  "itemfence": [["log","stick"]],
  "table": [["log","stick","stick","log"]],
"planks_floor": [["log","log"]],
"planks": [["planks_floor","log"]],
"stick": [["log","log","log","log"]],
"door": [["house_wall", "house_wall","longstick"]],
"house_wall": [["planks", "planks"]],
"houseroof": [["house_wall","log"]],
"ryeroof": [["houseroof","rye","rye"]],
"violetfloor": [["violet", "planks_floor"]],
"gypsumhouse": [["house_wall", "gypsum"]],
"gypsumroof": [["houseroof", "gypsum"]],
"gypsumdoor": [["door", "gypsum"]],
"polishedfloor": [["bigrock","sharpstone"]],

}
var furnacerecipes = {
"copper": [["chalcopyrite", "coal"]],
"cooked_salmon": [["salmon"]],
 "candy":[["sugar","sugar"]],
 "energybowl":[["sugar","dandelion","bowl_with_water"]],
"healthbowl":[["briar-fruit","bowl_with_water"]],
"cooked_trout": [["trout"]],
"brickhouse":[["brick","brick"]],
"pickaxe": [["longstick", "iron_bar"]],
"iron_shovel": [["longstick", "iron_bar","cordage"]],
"cavemakingpickaxe": [["pickaxe", "iron_bar"]],
  "ignited_fiber": [["fiber"]],
  "copper_bar": [["copper", "copper", "copper"]],
"iron": [["magnetite_powder", "magnetite_powder", "magnetite_powder",], ["pyrite"]],
  "iron_bar": [["iron", "iron" ]],
  "anvil": [["iron_bar","iron_bar","iron_bar"]],
"cooked_bunnmeat": [["bunnmeat"]],
"glass": [["grains_of_sand","grains_of_sand"]],
"gypsumblock": [["gypsum","gypsum"]],
"bowl": [["clay","clay","clay","clay","clay","clay"]],
"bowl_with_water": [["bowl_with_seawater"]],
"leafbowlwithcleanwater": [["leafbowlwithwater"]],
"bread":[["bread_sample"]],
"titaniumbar": [["titaniumdioxide","salt"]],
"friedegg": [["eggs"]],
"cauldron": [["bigrock","iron_bar"]],
"fountain": [["bigrock","stick"]],
}
var cauldronrecipes = {
    "bowl": [["clay", "clay", "clay", "clay", "clay", "clay"]],
    "bowl_with_water": [["bowl_with_seawater"]],
    "cooked_salmon": [["salmon"]],
    "candy": [["sugar", "sugar"]],
    "energybowl": [["sugar", "dandelion", "bowl_with_water"]],
    "healthbowl": [["briar-fruit", "bowl_with_water"]],
    "soup": [["carrot","carrot", "bowl_with_water", "thistleroot"]],
    "friedegg": [["eggs"]],
}
var kiln_recipes = {
  "brick": [["clay", "ash"]],
  "brickfloor2": [["clay", "clay"]],
"statue1": [["bigrock", "clay", "clay", "log"]],
"statue2": [["bigrock", "clay", "clay", "log"]],
  "brickwall": [["clay", "brick", "brick", "brick"]],
  "brickfloor": [["clay", "brick", "brick", "brick"]],
  "bowl": [["clay","clay","clay","clay","clay","clay"]],
  "bowl_with_water": [["bowl_with_seawater"]],
"bread": [["bread_sample"]],
"ignited_fiber": [["fiber"]],
"cooked_salmon": [["salmon"]],
"candy": [["sugar", "sugar"]],
"energybowl": [["sugar", "dandelion", "bowl_with_water"]],
"healthbowl": [["briar-fruit", "bowl_with_water"]],
"textstone": [["bigrock", "woodboard","sharpstone"]],
}
var unknownrecipes={
  "voltary_essence": [["emeraldblock", "sapphireblock", "rubyblock", "ilmenite"]],
  "aquaticevent": [["evilsummoner", "abyssgem", "aquaore"]],
  "evilsummoner": [["aquaticevent", "abyssgem", "echorocks"]],
"aquagodshell": [["aquaore", "voltary_essence"]],
 "fleshdumbass": [["voltary_essence", "evileye"]],
 "deepgodspawner": [["aquaore", "aquacore", "fleshvolume"]],
 "universeechoes": [["aquagodshell","evilsummoner","aquaticevent","fleshdumbass","voltary_essence","spikegod_essence"]],
 "trueuniversespawner": [["universefragment","universeechoes","aquagem","aquagem"]],
}
var anvilrecipes = {
"iron_spear": [["iron_bar", "longstick"]],
"alchemy_table": [["iron_bar", "log"]],
"redanvil":[["anvil","evileye","magicgem"]],
"cavemakingpickaxe": [["pickaxe"]],
"copper_spear": [["copper_bar", "longstick"]],
"larger_bag": [["extrabag", "extrabag"]],
"heavybag": [["larger_bag", "larger_bag"]],
"rock": [["bigrock"]],
"unknown": [["emeraldblock","sapphireblock","rubyblock","anvil"]],
"compass":[["iron_bar","iron_bar","magnetite_powder","bowl_with_water"]],
//"spikegod_essence": [["voltary_essence","voltary_essence","voltary_essence","ilmenite"]],
"titanium_boomerang":[["boomerang","titaniumbar","titaniumbar","titaniumbar"]],
"good_boomerang":[["titanium_boomerang","soulofsharp","soulofsharp","fleshvolume",]],
"hell_boomerang":[["good_boomerang","hellessence","fleshvolume","desertcore"]],

"lamptorch": [["torch","iron_bar","longstick"]],
"iron_sword": [["iron_bar","iron_bar","iron_spear"]],
"titaniumsword": [["titaniumbar","titaniumbar","iron_sword"]],
"titaniumbuff": [["titaniumbar","titaniumbar","titaniumbar","evileye","evileye"]],
"hellbuff": [["titaniumbuff","hellgem","hellessence","evileye","evileye"]],
"dracobuff": [["universefragment","hellbuff","coloressence"]],
"titaniummace": [["titaniumbar","titaniumbar","iron_mace"]],
"iron_mace": [["iron_bar","iron_bar","iron_spear"]],
"sharpsaw": [["nightsword","evileye"]],
"hellsword": [["sharpsaw","evileye","hellessence","hellessence"]],

"rainbowbow": [["moltenbow", "coloressence","soulofsharp"]],
"moltenbow": [["hellbow", "fleshvolume","hellessence"]],
"quantumbow": [["hellbow", "soulofsharp","hellgem"]],
"hellbow": [["darkbow", "hellgem","hellessence"]],
"nightbow": [["bow", "evileye","nightgem","nightgem"]],
"darkbow": [["nightbow", "soulofsharp","soulofsharp"]],

"sharpmace": [["titaniummace","evileye","evileye"]],
"nightsword": [["nightgem","nightgem","nightgem","nightgem","nightgem","titaniumsword"]],
"aquaspear": [["nightsword","aquaore","aquaore","aquaore"]],
"goodsword": [["nightgem","evileye","evileye","soulofsharp","soulofsharp","sharpsaw"]],
"goodmace": [["nightgem","evileye","evileye","soulofsharp","soulofsharp","sharpmace"]],
"fleshsaber": [["goodsword","fleshvolume","evileye"]],
"moltensword": [["fleshsaber","hellgem","hellessence","hellessence","evileye"]],
"rainbow": [["moltensword","goodsword","coloressence","evileye"]],
"universesword": [["universefragment","rainbow","moltensword"]],
"draco_boomerang":[["hell_boomerang","rainbow","universefragment","desertcore","soulofsharp"]],
"trueuniversesword": [["trueuniverseorb","trueuniverseorb","universesword"]],
"can": [["titaniumbar"]],
"bottle": [["glass", "glass"]],
//"cave_wall": [["bigrock", "stone"]],
}
var redanvilrecipes={
  "broom":[["longstick","magicgem","speedmedalion","evileye","soulofsharp","hellgem"]],
  "magiclanter": [["magicgem","desertcore","abysscore","frozeningot","hand_torch","hand_torch"]],
  "greenwand": [["magicgem","stick","frozeningot","soulofsharp","forestleaf"]],
  "magicwand": [["magicgem","greenwand","abysscore","frozeningot","soulofsharp","desertcore"]],
  "magicwandofsharp": [["magicwand","magicgem","soulofsharp","soulofsharp","fleshvolume","fleshvolume"]],
  "hyperblastwand": [["magicwandofsharp","magicgem","magicgem","universefragment","coloressence"]],
}
let itemsDurabilities = { "pickaxe":90 , "arrows": 32 , "goodarrows": 50,"powerfullarrows": 50};
let yourItemsDurabilities = []; 
var alchemy_tableRecipes = {
  "sulfur": [["gypsum", "coal","coal"]],
  "titaniumdioxide": [["ilmenite"]],
  "mercurybottle": [["bottle","cinnabar","cinnabar"]],
  "cinnabargeode": [["cinnabar","cinnabar","cinnabar"]],
  "titaniumdioxide": [["ilmenite"]],
}
var fermentatorRecipes = {
"yeast": [["flour", "sugar", "bowl_with_water"]],
"bread_sample": [["flour", "yeast", "flour"]],
"beer": [["yeast", "bowl_with_water", "sugar","sugar"]],
}
function checkIfItems2(item, amount) {
    let existingItem = yourItemsDurabilities.find(d => d.name === item);
    if (!existingItem) {
        if (itemsDurabilities[item] !== undefined) {
            yourItemsDurabilities.push({ name: item, durability: itemsDurabilities[item] });
        } else {
            console.log(`Durability not defined for item: ${item}`);
        }
    }
}

function checkIfItemsAndDurabilities() {
  if(yourItemsDurabilities!==undefined && yourItemsDurabilities && yourItemsDurabilities!==null){
    yourItems.forEach(item => {
        if(item=="bow"|| item=="hellbow"||item=="rainbowbow"|| item=="moltenbow"||item=="quantumbow"|| item=="darkbow"){
            item="arrows"
        checkIfItems2(item, 1); // Sprawdzamy, czy mamy co najmniej 1 przedmiot danego typu w ekwipunku
        }else{
            checkIfItems2(item, 1);
        }
    });
     // Debugowanie
}else{
  yourItemsDurabilities=[]
}
}

function checkIfItemsAndDurabilities2(item) {
    if (yourItemsDurabilities !== undefined && yourItemsDurabilities && yourItemsDurabilities !== null) {
        yourItems.forEach(item => {
             
                
                checkIfItems2(item, 1); 
        });
        // Debugowanie
    } else {
        yourItemsDurabilities = []
    }
}
let totalAmountUsed=-9999;
let totalAmountUsed2=-9999;
function useItemDurability(amount) {
    checkIfItemsAndDurabilities();
    for (let i = 0; i < yourItemsDurabilities.length; i++) {
        let item = yourItemsDurabilities[i];
        if(item.name =="pickaxe"){
            if (item.durability ) {
                item.durability -= -amount;
            }
            if (item.durability <= 0) {
                updateInventory(); 
                item.durability = 0; 
                yourItemsDurabilities=[]
deleteItems(item.name, 1);
if (langPlactive == 1) {
    showTextInCanvas("' zepsuł ci się kilof ")
} else {
    showTextInCanvas("'your pickaxe broke")
}
            }
        }
    }
    if (totalAmountUsed < amount) {
        return; 
    }
    let nextItemName = yourItems.find(item => !yourItemsDurabilities.some(d => d.name === item));

    if (nextItemName) {
        let nextItemDurability = itemsDurabilities[nextItemName];
        if (nextItemDurability !== undefined) {
            yourItemsDurabilities.length = 0; 
            yourItemsDurabilities.push({ name: nextItemName, durability: nextItemDurability });
            
        } else {
            console.log(`Durability not defined for item: ${nextItemName}`);
        }
    }

}

function useItemDurability2(amount,name) {
    checkIfItemsAndDurabilities2(name);
   //  console.log(JSON.stringify(yourItemsDurabilities))
    for (let i = 0; i < yourItemsDurabilities.length; i++) {
        let item = yourItemsDurabilities[i];
        if (item.name  == name) {
            if (item.durability) {
                item.durability -= -amount;
            }
            if (item.durability <= 0) {
                updateInventory();
                item.durability = 0;
                yourItemsDurabilities = []
                deleteItems(item.name, 1);
                if (langPlactive == 1) {
                    showTextInCanvas("straciłeś strzały")
                } else {
                    showTextInCanvas("you lost arrows")
                }
            }
        }
    }
    if (totalAmountUsed < amount) {
        return;
    }
    let nextItemName = yourItems.find(item => !yourItemsDurabilities.some(d => d.name === item));

    if (nextItemName) {
        let nextItemDurability = itemsDurabilities[nextItemName];
        if (nextItemDurability !== undefined) {
            yourItemsDurabilities.length = 0;
            yourItemsDurabilities.push({ name: nextItemName, durability: nextItemDurability });

        } else {
            console.log(`Durability not defined for item: ${nextItemName}`);
        }
    }

}
function isNearPlanter(playerX, playerY) {
    // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
        // Sprawdź, czy blok jest typu 'decrafter'
        if (block.type === 'plantmaker') {
            // Ustal odległość bloku od gracza
            const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
            const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

            // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
            if (distanceX <= radius5 && distanceY <= radius5) {
                nearDecrafter = true;
            }
        }
    });

    return nearDecrafter;
}
function isNearDecrafter(playerX, playerY) {
    // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;
    
    let nearDecrafter = false;
    
    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
        // Sprawdź, czy blok jest typu 'decrafter'
        if (block.type === 'decrafter') {
            // Ustal odległość bloku od gracza
            const distanceX = Math.abs((block.x +offsetX)- playerCenterX);
            const distanceY = Math.abs((block.y +offsetY)- playerCenterY);
            
            // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
            if (distanceX <= radius5 && distanceY <= radius5) {
                nearDecrafter = true;
            }
        }
    });

    return nearDecrafter;
}
function isNearUnknown(playerX, playerY) {
  let radius5 = 2 * blockSize;
  const playerCenterX = offsetX + canvas.width / 2;
  const playerCenterY = offsetY + canvas.height / 2;
  let nearDecrafter = false;
  renderedBlocks.forEach(block => {
    if (block.type === 'unknown') {
      const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
      const distanceY = Math.abs((block.y + offsetY) - playerCenterY);
      if (distanceX <= radius5 && distanceY <= radius5) {
        nearDecrafter = true;
      }
    }
  });
  return nearDecrafter;
}
function isNearRedanvil(playerX, playerY) {
  let radius5 = 2 * blockSize;
  const playerCenterX = offsetX + canvas.width / 2;
  const playerCenterY = offsetY + canvas.height / 2;
  let nearDecrafter = false;
  renderedBlocks.forEach(block => {
    if (block.type === 'redanvil') {
      const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
      const distanceY = Math.abs((block.y + offsetY) - playerCenterY);
      if (distanceX <= radius5 && distanceY <= radius5) {
        nearDecrafter = true;
      }
    }
  });
  return nearDecrafter;
}
function isNearFermentator(playerX, playerY) {
  // Ustawienie promienia
  let radius5 = 2 * blockSize;
  // Ustalenie środka gracza
  const playerCenterX = offsetX + canvas.width / 2;
  const playerCenterY = offsetY + canvas.height / 2;

  let nearDecrafter = false;

  // Iteracja przez zrenderowane bloki
  renderedBlocks.forEach(block => {
    // Sprawdź, czy blok jest typu 'decrafter'
    if (block.type === 'fermentator') {
      // Ustal odległość bloku od gracza
      const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
      const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

      // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
      if (distanceX <= radius5 && distanceY <= radius5) {
        nearDecrafter = true;
      }
    }
  });

  return nearDecrafter;
}
function isNearFurnace(playerX, playerY) {
      // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
      // Sprawdź, czy blok jest typu 'decrafter'
      if (block.type === 'lit_furnace') {
        // Ustal odległość bloku od gracza
        const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
        const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

        // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
        if (distanceX <= radius5 && distanceY <= radius5) {
          nearDecrafter = true;
        }
      }
    });

    return nearDecrafter;
}
function isNearCauldron(playerX, playerY) {
    // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
        // Sprawdź, czy blok jest typu 'decrafter'
        if (block.type === 'cauldron') {
            // Ustal odległość bloku od gracza
            const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
            const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

            // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
            if (distanceX <= radius5 && distanceY <= radius5) {
                nearDecrafter = true;
            }
        }
    });

    return nearDecrafter;
}
function isNearWoodManipulator(playerX, playerY) {
      // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
      // Sprawdź, czy blok jest typu 'decrafter'
      if (block.type === 'wood_manipulator') {
        // Ustal odległość bloku od gracza
        const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
        const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

        // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
        if (distanceX <= radius5 && distanceY <= radius5) {
          nearDecrafter = true;
        }
      }
    });

    return nearDecrafter;
}
function isNearAlchemyTable(playerX, playerY) {
      // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
      // Sprawdź, czy blok jest typu 'decrafter'
      if (block.type === 'alchemy_table') {
        // Ustal odległość bloku od gracza
        const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
        const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

        // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
        if (distanceX <= radius5 && distanceY <= radius5) {
          nearDecrafter = true;
        }
      }
    });

    return nearDecrafter;
}
function isNearAnvil(playerX, playerY) {
      // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
      // Sprawdź, czy blok jest typu 'decrafter'
      if (block.type === 'anvil') {
        // Ustal odległość bloku od gracza
        const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
        const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

        // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
        if (distanceX <= radius5 && distanceY <= radius5) {
          nearDecrafter = true;
        }
      }
    });

    return nearDecrafter;
}
function deconstructItem(item) {
    let recipe = null;

    // Lista tablic z recepturami do przeszukania
    const recipeSources = [
        recipes,
        campfirerecipes,
        furnacerecipes,
        alchemy_tableRecipes,
        wood_manipulator_recipes,
        anvilrecipes ,
        unknownrecipes,
        redanvilrecipes,
        fermentatorRecipes,
        kiln_recipes,
        plantmakerrecipes,
        cauldronrecipes
    ];

    // Przechodzimy przez każdą tablicę z recepturami
    for (let source of recipeSources) {
        if (source[item] && source[item][0] !== undefined) {
            recipe = source[item][0];
            break; // Przerywamy, gdy znajdziemy recepturę
        }
    }

    // Sprawdzamy, czy znaleziono recepturę i wykonujemy rozkład przedmiotu
    if (recipe) {
        deleteItems(item, 1); // Usuwamy przedmiot

        // Rozkładamy przedmiot na komponenty i umieszczamy je na pozycji gracza
        recipe.forEach(material => {
            dropItemAtPlayerPosition(material);  // Upuść materiał na pozycję gracza
        });
        console.log(item + " has been deconstructed into its components.");
    } else {
        console.log("This item cannot be deconstructed.");
    }
}


        // Otwórz ekwipunek
        function openInventory() {
           
   offsetX = (Math.floor(offsetX / 32) * 32) + 17; // Zaokrąglamy offsetX
offsetY = (Math.floor(offsetY / 32) * 32) + 10; // Zaokrąglamy offsetY
   
     
  

          if(options.autopause==1){
          paused=1
          }else{
            paused=0
          }
            document.getElementById("inventory").style.visibility = "visible";
            document.getElementById("inventory").style.pointerEvents = "all";
            updateInventory();
            updateCrafting();
        }

        // Zamknij ekwipunek
        function closeInventory() {
          
if (options.autopause == 1) {
  paused = 1
  setTimeout(function(){paused=0; update() },300);
} else {
  paused = 1
  setTimeout(function(){paused=0; update() },300);
  
}
            document.getElementById("inventory").style.visibility = "hidden";
            document.getElementById("inventory").style.pointerEvents = "none";
        }

        // Funkcja dodawania przedmiotu do ekwipunku
        function addItem(item, amount) {
            for (let i = 0; i < amount; i++) {
                if (yourItems.length < slots) {
                    yourItems.push(item);
                } else {
                    console.log("Not enough space!");
                    return;
                }
            }
            updateInventory();
            updateCrafting();
        }

        // Funkcja sprawdzania ilości przedmiotów w ekwipunku
        

        // Funkcja usuwania przedmiotów z ekwipunku
        function deleteItems(item, amount) {
            let deleted = 0;
            for (let i = 0; i < yourItems.length && deleted < amount; i++) {
                if (yourItems[i] === item) {
                    yourItems.splice(i, 1);
                    i--;  // Cofnięcie indeksu, by nie przeskoczyć na kolejny element
                    deleted++;
                }
            }
            updateInventory();
        }

        // Funkcja craftingu – usuwa wymagane przedmioty i dodaje crafted item
        let achievementsfromcrafting={
            "iron_bar":["Metal century",0],
            "yellow":["Botanics !",0],
            "climbhill":["Fake environment creator",2],
            "campfire":["Fake environment creator",2],
            "copper_bar":["<span style='color:orange;' > Copper age</span>",0],
            "fermentator":["It smells bad",1],
            "beer":["Dont drunk yourself",0],
            "bottle":["<span style='color:lime;' > Bottle </span>",1],
            "wood_manipulator":["Wood is everywhere",2],
            "gelblock":["So sticky",0],
            "titaniumsword":["Fast sword !",0],
            "grasslayer":["<span style='color:lime;' > Get a grass </span>",2],
            "iron_sword":["Iron is really useful ",0],
            "fishing_rod":["Its time to catch a fish",0],
            "broom":["Harry Potter?",1],
            "greenwand":["Hagrid ?",2],
            "door":["<span style='color:yellow;' > Its Time to build a house</span>",0],
            "titaniumbuff":["Buff yourself ",0],
            "hellbuff":["Made in hell",2],
            "dracobuff":["Made in heaven",1],
            "titaniumbar":["Light and hard metal ",0],
            "boomerang":["BANG ! ",0],
            "cooked_bunnmeat":["Cook something",0],
            "cooked_salmon":["Cook something",0],
            "cooked_trout":["Cook something",0],
            "arrows":["Time to shoot something",0],
            "hellbow":["Bow from Hell ",2],
            "moltenbow":["<span style='color: orange;' >Kawaii Ist So </span><span style='color:red;' > Hot</span>",2], 
            "sing":["You don't have to be a poet to write",0],
            "bed":["This is a comfortable bed !",0],
            "warporb":["Go to the overworld ..",0],
            "draco_boomerang":["<span style='color:pink;' >Draco Boomerang</span>",1],
            "moltensword":["<span style='color:orange;' >IT BURNS !!</span>",2],
            "lamptorch":["From torch to lamp",0],
            "magiclanter":["Magic is everywhere",2],
            "torch":["Its glowing !",0],
            "trueuniversesword":["<span style='color:#AACCEE;' >Sword from heaven </span>",1],
            "compass":["<span style='color:cyan;' >Never get lost </span>",2],
            "friedegg":["Du bist <span style='color:red;' >heiss</span>",0],
            "energybowl":["I need more <span style='color:yellow;' >Energy</span> for coding",0],
            "pickaxe":[" <span style='color:yellow;' >Time</span> to mine",0],
            "decrafter":[" <span style='color:pink;' >Reverse</span> Engineering",2],
            "soup":[" <span style='color:pink;' >Mmm</span> Yummy ;)",2],
        }
         
        function craftItem(item) {
    let TheItem = item;
if(item=="yeast"){
  dropItemAtPlayerPosition("bowl")
}
    // Lista grupreceptur, po których będziemy iterować
    const recipeGroups = [
        recipes,
        campfirerecipes,
        anvilrecipes,
        furnacerecipes,
        wood_manipulator_recipes,
        alchemy_tableRecipes,
        fermentatorRecipes,
        unknownrecipes,
        redanvilrecipes,
        kiln_recipes,
        plantmakerrecipes,
        cauldronrecipes
    ];

    let recipesList = null;  // Zmienna do przechowywania znalezionej listy receptur
    let canCraft = false;
    let selectedRecipe = null;

    // Iteruj przez grupy receptur
    for (let group of recipeGroups) {
        recipesList = group[`${TheItem}`];  // Znajdź recepturę w aktualnej grupie

        // Sprawdź, czy istnieje przynajmniej jedna receptura
        if (recipesList) {
            console.log(`Available recipes for ${TheItem} in current group: ${JSON.stringify(recipesList)}`);
            
            // Sprawdzaj wszystkie warianty receptur
            for (let recipe of recipesList) {
                console.log(`Checking recipe: ${JSON.stringify(recipe)}`); // Debugging line
                if (canCraftRecipe(recipe)||options.creativemode==1) {
                    canCraft = true;
                    selectedRecipe = recipe;  // Zaznacz pierwszą możliwą do wyrobu recepturę
                    break;  // Przerywamy, jeśli znaleziono jedną możliwą recepturę
                }
            }
        }

        if (canCraft&&options.creativemode!==1) {
            break;  // Jeśli znaleziono recepturę, przerywamy iterację po grupach
        }
    }

    // Jeśli znaleziono możliwą do wyrobu recepturę, przystępujemy do wyrobu
    if (canCraft && selectedRecipe ) {
        let ingredientsCount = {};  // Licznik do przechowywania ilości wymaganych składników

        selectedRecipe.forEach(reqItem => {
            // Zliczamy wymagane składniki
            ingredientsCount[reqItem] = (ingredientsCount[reqItem] || 0) + 1;
        });

        // Usuwamy przedmioty tylko po sprawdzeniu
        for (let reqItem in ingredientsCount) {
            console.log(`Deleting ${ingredientsCount[reqItem]} of ${reqItem}`); // Debugging line
            deleteItems(reqItem, ingredientsCount[reqItem]);
        }
if (achievementsfromcrafting[TheItem]) {
    let achievement = achievementsfromcrafting[TheItem];
    
        achievementget(achievement[0], achievement[1]); 
}
        addItem(TheItem, 1);
        console.log(`${TheItem} crafted!`);
    } else if (options.creativemode==1){
      addItem(TheItem, 1);
    }else{
        blockedsound();
        console.log(`Not enough items to craft ${TheItem}`);
    }

    updateCrafting();
}


function canCraftRecipe(recipe) {
    // Check each unique item in the recipe
    for (let reqItem of new Set(recipe)) {
        const requiredQuantity = recipe.filter(item => item === reqItem).length;
        if (!checkIfItems(reqItem, requiredQuantity)) {
            return false;
        }
    }
    return true; // All items in this recipe variant arerecipesavailable in required quantities
}

// Checks if a specific item with a required quantity is present
function checkIfItems(item, quantity) {
    return yourItems.filter(inventoryItem => inventoryItem === item).length >= quantity;
}

// Updated deleteItems function to remove the required quantity of a specific item
function deleteItems(item, quantity) {
    let deleted = 0;
    for (let i = 0; i < yourItems.length && deleted < quantity; i++) {
        if (yourItems[i] === item) {
            yourItems.splice(i, 1);
            i--;  // Adjust index after removal
            deleted++;
        }
    }
    updateInventory();
}

// Checks if a specific item with a required quantity is present
function checkIfItems(item, quantity) {
    return yourItems.filter(inventoryItem => inventoryItem === item).length >= quantity;
}


        // Aktualizacja wyświetlania ekwipunku
        // Funkcja dodawania przedmiotu do aktualnej pozycji gracza
        
let autoclose = 1; // Flaga zamykania ekwipunku

// Aktualizacja wyświetlania ekwipunku z obsługą przycisków w mini-menu
function updateInventory() {
    const slotsContainer = document.getElementById("slots");
    slotsContainer.innerHTML = "";  // Czyszczenie slotów
autoclose=options.autoclose
if(checkIfItems("bow",1)||checkIfItems("nightbow",1)||checkIfItems("darkbow",1)||checkIfItems("hellbow",1)||checkIfItems("quantumbow",1)||checkIfItems("moltenbow",1) ||checkIfItems("rainbowbow",1)){
    document.getElementById("shootbtn").style.display="block"
}else{
    document.getElementById("shootbtn").style.display="none"
}
    for (let i = 0; i < slots; i++) {
        const slot = document.createElement("div");
        slot.classList.add("slot");
        slot.style.position = "relative"; // Ustawienie pozycji slotu do kontroli pozycji mini-menu

        if (yourItems[i]) {
            const itemImg = document.createElement("img");
            itemImg.src = allItems[yourItems[i]];
            itemImg.classList = "itemImg";
            const itemName = document.createElement("div");
            itemName.classList.add("slot-name");
            if(langPl.items[yourItems[i]] && langPlactive==1){
            itemName.innerText = langPl.items[yourItems[i]]
            }else{
            itemName.innerText = yourItems[i];
            }
            // Tworzenie i stylowanie mini-menu
            const miniMenu = document.createElement("div");
            miniMenu.classList.add("mini-menu");
            miniMenu.style.position = "absolute";
            miniMenu.style.bottom = "100%"; // Wyświetlanie nad slotem
            miniMenu.style.left = "50%";
            miniMenu.style.transform = "translateX(-50%)";
            miniMenu.style.backgroundColor = "#333"; // Ciemne tło
            miniMenu.style.color = "#fff"; // Jasny tekst
            miniMenu.style.padding = "5px";
            miniMenu.style.borderRadius = "5px";
            miniMenu.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
            miniMenu.style.zoom="0.8"
            miniMenu.style.display = "none"; // Ukrycie menu na początku

            // Przycisk "Drop"
            const dropButton = document.createElement("button");
            dropButton.innerText = "Drop/Use";
            dropButton.style.backgroundColor = "#444";
            dropButton.style.border = "none";
            dropButton.style.color = "#fff";
            dropButton.style.padding = "5px";
            dropButton.style.margin = "2px";
            dropButton.style.cursor = "pointer";
            dropButton.style.borderRadius = "3px";
            dropButton.addEventListener("click", () => {
if (yourItems[i] == "broom" && options.dropany == 0) {if (isflying == 0) {
item = "";isflying = 1;if (langPlactive == 1) {
    showTextInCanvas(".. latasz na miotle")
} else {
    showTextInCanvas("you are flying now")
}closeInventory();return;} else {
isflying = 0;item = "";if (langPlactive == 1) {
    showTextInCanvas(".. już nie latasz ")
} else {
    showTextInCanvas("you are on land now")
}closeInventory();return; }} else {dropItemAtPlayerPosition(yourItems[i]);} updateStamina(-5); yourItems.splice(i, 1); updateInventory(); updateCrafting();
miniMenu.style.display = "none";if (autoclose !== 0) { closeInventory(); }
});


            // Przycisk "Remove"
            const removeButton = document.createElement("button");
            removeButton.innerText = "Remove";
            removeButton.style.backgroundColor = "#444";
            removeButton.style.border = "none";
            removeButton.style.color = "#fff";
            removeButton.style.padding = "5px";
            removeButton.style.margin = "2px";
            removeButton.style.cursor = "pointer";
            removeButton.style.borderRadius = "3px";
            removeButton.addEventListener("click", () => {
                // Potwierdzenie usunięcia
                const confirmDiv = document.createElement("div");
                confirmDiv.classList.add("confirm-modal");
                confirmDiv.style.position = "fixed";
                confirmDiv.style.top = "50%";
                confirmDiv.style.left = "50%";
                confirmDiv.style.transform = "translate(-50%, -50%)";
                confirmDiv.style.backgroundColor = "#333";
                confirmDiv.style.color = "#fff";
                confirmDiv.style.padding = "10px";
                confirmDiv.style.borderRadius = "8px";
                confirmDiv.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
                confirmDiv.innerHTML = `
                    <div>Are you sure you want to do this action?</div>
                    <button id="yes-btn" style="background-color: #444; color: #fff; padding: 5px; margin: 5px; border: none; cursor: pointer; border-radius: 3px;">Yes</button>
                    <button id="no-btn" style="background-color: #444; color: #fff; padding: 5px; margin: 5px; border: none; cursor: pointer; border-radius: 3px;">No</button>
                `;
                document.body.appendChild(confirmDiv);

                // Obsługa kliknięcia "Yes"
                confirmDiv.querySelector("#yes-btn").addEventListener("click", () => {
                    yourItems.splice(i, 1);
                    updateInventory();
                    document.body.removeChild(confirmDiv);
if (autoclose !== 0){ closeInventory();}
                });

                // Obsługa kliknięcia "No"
                confirmDiv.querySelector("#no-btn").addEventListener("click", () => {
                    document.body.removeChild(confirmDiv);
                });
            });

            // Dodaj przyciski do mini-menu
            miniMenu.appendChild(dropButton);
           
            miniMenu.appendChild(removeButton);

            // Dodanie obsługi wyświetlania mini-menu po kliknięciu na slot
if(options.quickinventory==0){
            slot.addEventListener("click", () => {
                miniMenu.style.display = miniMenu.style.display === "none" ? "block" : "none";
            });
}else{
slot.addEventListener("click", () => {
if (yourItems[i] == "broom" && options.dropany == 0) {if (isflying == 0) {
item = "";isflying = 1;if (langPlactive == 1) {
    showTextInCanvas(".. latasz na miotle")
} else {
    showTextInCanvas("you are flying now")
}closeInventory();return;} else {
isflying = 0;item = "";if (langPlactive == 1) {
    showTextInCanvas(".. już nie latasz")
} else {
    showTextInCanvas("you are on land now")
}closeInventory();return; }} else {dropItemAtPlayerPosition(yourItems[i]);} updateStamina(-5); yourItems.splice(i, 1); updateInventory(); updateCrafting();
miniMenu.style.display = "none";if (autoclose !== 0) { closeInventory(); }
});
}
            // Dodaj mini-menu do slotu
            slot.appendChild(itemImg);
            slot.appendChild(itemName);
            slot.appendChild(miniMenu);
        }

        slotsContainer.appendChild(slot);
    }
}


        // Sprawdź, czy można stworzyć przedmiot
        function canCraft(recipe) {
            const neededItems = [...recipe];
            const inventoryCopy = [...yourItems];

            for (let i = 0; i < neededItems.length; i++) {
                const index = inventoryCopy.indexOf(neededItems[i]);
                if (index !== -1 ||options.creativemode==1) {
                    inventoryCopy.splice(index, 1);  // Usuń użyty przedmiot
                } else {
                    return false;  // Brak wymaganego przedmiotu
                }
            }
            return true;
        }
        
function isNearCampfire(playerX, playerY) {
        // Ustawienie promienia
    let radius5 = 2 * blockSize;
    // Ustalenie środka gracza
    const playerCenterX = offsetX + canvas.width / 2;
    const playerCenterY = offsetY + canvas.height / 2;

    let nearDecrafter = false;

    // Iteracja przez zrenderowane bloki
    renderedBlocks.forEach(block => {
      // Sprawdź, czy blok jest typu 'decrafter'
      if (block.type === 'campfire') {
        // Ustal odległość bloku od gracza
        const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
        const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

        // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
        if (distanceX <= radius5 && distanceY <= radius5) {
          nearDecrafter = true;
        }
      }
    });

    return nearDecrafter;
}
function isNearKiln(playerX, playerY) {
 // Ustawienie promienia
 let radius5 = 2 * blockSize;
 // Ustalenie środka gracza
 const playerCenterX = offsetX + canvas.width / 2;
 const playerCenterY = offsetY + canvas.height / 2;

 let nearDecrafter = false;

 // Iteracja przez zrenderowane bloki
 renderedBlocks.forEach(block => {
  // Sprawdź, czy blok jest typu 'decrafter'
  if (block.type === 'lit_kiln') {
   // Ustal odległość bloku od gracza
   const distanceX = Math.abs((block.x + offsetX) - playerCenterX);
   const distanceY = Math.abs((block.y + offsetY) - playerCenterY);

   // Sprawdź, czy blok znajduje się w promieniu radius5 od gracza
   if (distanceX <= radius5 && distanceY <= radius5) {
    nearDecrafter = true;
   }
  }
 });

 return nearDecrafter;
}
let showAllRecipes = false;  // Flaga kontrolująca tryb"pokazania wszystkich receptur"

function toggleAllRecipes() {
    showAllRecipes = !showAllRecipes;  // Przełącza tryb
    updateCrafting();  // Odświeża wyświetlanie crafting menu
}

// Helper function to check if a specific recipe variant can be crafted
// Helper function to check if a specific recipe variant can be crafted
function canCraft(recipe) {
    const inventoryCopy = [...yourItems];  // Copy of player inventory to manage item usage

    for (const requiredItem of recipe) {
        const index = inventoryCopy.indexOf(requiredItem);
        if (index !== -1) {
            inventoryCopy.splice(index, 1);  // Remove one instance of the item used in crafting
        } else {
            return false;  // If any required item is missing, crafting is not possible
        }
    }
    return true;  // All items in this recipe variant are available
}

// Helper function to check if any variant of a recipe can be crafted
function canCraftAny(recipeVariants) {
    return recipeVariants.some(variant => canCraft(variant));  // Checks each variant independently
}


// Helper function to check if any variant of a recipe can be crafted


function updateCrafting() {
    const craftingContainer = document.getElementById("crafting");
    craftingContainer.innerHTML = "";  // Clear current recipes

    let activeRecipes = { ...recipes };  // Base recipes

    // Check proximity to various stations and add relevant recipes
if (isNearFurnace(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...furnacerecipes };
    craftingContainer.innerHTML += "<h3>Discovered the Furnace!</h3>";
}
if (isNearCauldron(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...cauldronrecipes };
    craftingContainer.innerHTML += "<h3 style='color: pink' >Cauldron Cook something !</h3>";
}
if (isNearCampfire(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...campfirerecipes };
    craftingContainer.innerHTML += "<h3>It's really nice and hot</h3>";
}
if (isNearPlanter(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...plantmakerrecipes };
    craftingContainer.innerHTML += "<h3 style='color:lime;'>World is Green</h3>";
}
if (isNearKiln(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...kiln_recipes };
    craftingContainer.innerHTML += "<h3>Hard Bricks!</h3>";
}
if (isNearUnknown(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...unknownrecipes };
    craftingContainer.innerHTML += "Unknown is an ancient statue for summoning ancient bosses. <h3 style='color:red'> Note: Do not click it while you are holding special summons that you can craft because this can summon a boss while you're not ready for it. Make a save first before the boss.</h3>";
}
if (isNearRedanvil(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...redanvilrecipes };
    craftingContainer.innerHTML += "You can craft <h3 style='color:yellow'>Magic items</h3>";
}
if (isNearAlchemyTable(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...alchemy_tableRecipes };
    craftingContainer.innerHTML += "<h3>You are a skilled alchemist :)</h3>";
}
if (isNearFermentator(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...fermentatorRecipes };
    craftingContainer.innerHTML += "<h3>You can farm a bacteria colony's ;) </h3>";
}
if (isNearWoodManipulator(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...wood_manipulator_recipes };
    craftingContainer.innerHTML += "<h3>Using Wood Manipulator Station :)</h3>";
}
if (isNearAnvil(player.x, player.y)) {
    activeRecipes = { ...activeRecipes, ...anvilrecipes };
    craftingContainer.innerHTML += "<h3>Forge weapons and armor at the Anvil!</h3>";
}
//alert(JSON.stringify(activeRecipes))
    // Loop through active recipes and display those that can be crafted or should be shown
    for (const recipeName in activeRecipes) {
  //    alert(activeRecipes)
        const recipeVariants = activeRecipes[recipeName];
        const canCraftRecipe = canCraftAny(recipeVariants);

        // Create div for each recipe item
        const recipeDiv = document.createElement("div");
        recipeDiv.classList.add("recipe");

        // Set opacity if the item can't be crafted (in "show all" mode)
        if (!canCraftRecipe && showAllRecipes) {
            recipeDiv.style.opacity = "0.5";
            if(options.creativemode==1){
recipeDiv.style.opacity = "1";
            }
        }

        // Show the recipe if it can be crafted or we're in "show all" mode
        if (canCraftRecipe || showAllRecipes ) {
            recipeDiv.addEventListener("click", function() {
                if (canCraftRecipe||options.creativemode==1) {  // Craft if possible
                    craftItem(recipeName);
                    
                } else {
                    console.log(`Insufficient items to craft ${recipeName}`);
                    blockedsound();
                }
            });

            const recipeImg = document.createElement("img");
            recipeImg.src = allItems[recipeName];
            recipeDiv.appendChild(recipeImg);

            const recipeNameDiv = document.createElement("div");
            recipeNameDiv.classList.add("recipe-name");
          if (langPl.items[recipeName] && langPlactive == 1) {
              recipeNameDiv.innerText = langPl.items[recipeName]
          } else {
              recipeNameDiv.innerText = recipeName;
          }
             
            recipeDiv.appendChild(recipeNameDiv);

            const itemsContainer = document.createElement("div");
            itemsContainer.style.display = "flex";
            itemsContainer.style.flexWrap = "wrap";

            // Display each variant's ingredients
            recipeVariants.forEach(variant => {
                const variantDiv = document.createElement("div");
                variantDiv.classList.add("recipe-variant");
if(variant){
                variant.forEach(item => {
                    const itemImg = document.createElement("img");
                    itemImg.src = allItems[item];
                    itemImg.style.width = "30px";
                    itemImg.style.marginRight = "5px";

                    const itemName = document.createElement("span");
          if (langPl.items[item] && langPlactive == 1) {
                itemName.innerText = langPl.items[item]
            } else {
                itemName.innerText = item;
            }
                     
                    itemName.style.marginRight = "15px";

                    variantDiv.appendChild(itemImg);
                    variantDiv.appendChild(itemName);
                });
}
                itemsContainer.appendChild(variantDiv);
            });

            recipeDiv.appendChild(itemsContainer);
            craftingContainer.appendChild(recipeDiv);
        }
    }

    // Deconstruction feature if near the decrafter
    if (isNearDecrafter(player.x, player.y)) {
        craftingContainer.innerHTML = "<h3>Deconstruction Menu</h3>";

        canbedecrafted.forEach(item => {
            if (yourItems.includes(item)) {
                const recipeDiv = document.createElement("div");
                recipeDiv.classList.add("recipe");

                recipeDiv.addEventListener("click", function() {
                    deconstructItem(item);
                });

                const recipeImg = document.createElement("img");
                recipeImg.src = allItems[item];
                recipeDiv.appendChild(recipeImg);

                const recipeNameDiv = document.createElement("div");
                recipeNameDiv.classList.add("recipe-name");
 if (langPl.items[item] && langPlactive == 1) {
              recipeNameDiv.innerText = langPl.items[item]
          } else {
              recipeNameDiv.innerText = item;
          }

                recipeDiv.appendChild(recipeNameDiv);
                craftingContainer.appendChild(recipeDiv);
            }
        });
    }
}

        openInventory();
        closeInventory()
        

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("GameSaveDB", 1);

        request.onupgradeneeded = function (event) {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("gameStates")) {
                db.createObjectStore("gameStates", { keyPath: "slot" });
            }
        };

        request.onsuccess = function (event) {
            resolve(event.target.result);
        };

        request.onerror = function (event) {
            reject("Failed to open IndexedDB: " + event.target.errorCode);
        };
    });
}
// Funkcja do pokazania modalu z odpowiednią wiadomością
function showModal(message, onConfirmCallback) {
    const modal = document.getElementById('checkModal');
    const modalMessage = document.getElementById('modalMessage');
    const confirmBtn = document.getElementById('confirmBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    modalMessage.innerHTML = message; // Ustawienie wiadomości w modalu

    // Funkcja wykonana po kliknięciu "Confirm"
    confirmBtn.onclick = function() {
        onConfirmCallback(); // Wywołanie callbacku po potwierdzeniu
        closeModal(); // Zamknięcie modalu
    };

    // Funkcja wykonana po kliknięciu "Cancel"
    cancelBtn.onclick = closeModal;

    modal.style.display = 'flex'; // Pokazanie modalu
}
function showTextInput(message, onConfirmCallback) {
    const modal = document.getElementById('checkModal2');
    const modalMessage = document.getElementById('modalMessage2');
    const confirmBtn = document.getElementById('confirmBtn2');
const input = document.getElementById('input2');

    modalMessage.innerHTML = message; // Ustawienie wiadomości w modalu
 
    // Funkcja wykonana po kliknięciu "Confirm"
    confirmBtn.onclick = function() {
        if(input.value){
        onConfirmCallback(input.value);  
        closeModal2(); // Zamknięcie modalu
        closeInventory();
        }
    };

 

    modal.style.display = 'flex'; // Pokazanie modalu
}
// Funkcja do zamknięcia modalu
function closeModal() {
    const modal = document.getElementById('checkModal');
    modal.style.display = 'none'; // Ukrycie modalu
}
function closeModal2() {
    const modal = document.getElementById('checkModal2');
    modal.style.display = 'none'; // Ukrycie modalu
}

// Funkcja do wczytania zapisu
async function loadGameState(slot) {
  if(lightningActive2){
    customAlert("can't load game state when boss is loading "); return;
  }
    showModal("Are you sure you want to end this game to load save?", async function() {
        showLoadingScreen(); // Pokazanie ekranu ładowania

try {
  const db = await initDB();
  const transaction = db.transaction("gameStates", "readonly");
  const store = transaction.objectStore("gameStates");

  const request = store.get(slot);

  request.onsuccess = function(event) {
    const gameState = event.target.result;
    if (!gameState) {
  customAlert("No save found in slot " + slot);
  hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku braku zapisu
  return;
}
    if (gameState.achievements1!==null&&gameState.achievements1) {
    achievements = (gameState.achievements1);
 
} else {
    achievements = []
}
    updfixbug = 1
    if(gameState.dataChunksStructures){
      cavesempty = dataChunksStructures.cavesempty;
      cavesempty3 = dataChunksStructures.cavesempty3;
      cavesempty4 = dataChunksStructures.cavesempty4;
      cavesempty5 = dataChunksStructures.cavesempty5;
      cavesempty6 = dataChunksStructures.cavesempty6;
      cavesempty2 = dataChunksStructures.cavesempty2;
      deadlands= dataChunksStructures.deadlands;
      grassroad = dataChunksStructures.grassroad;
      islands = dataChunksStructures.islands;
      hills = dataChunksStructures.hills;
    }

if(gameState.AVAILABLE_IDS){
AVAILABLE_IDS=gameState.AVAILABLE_IDS
}
if (gameState.VISIBLEIDS) {
VISIBLEIDS = gameState.VISIBLEIDS
}

inhell=0;
    curseofgos = gameState.curseofgos;
    offsetX = gameState.offsetX;
    offsetY = gameState.offsetY;
    increasing = gameState.increasing;
    isRaining = gameState.isRaining;
    nightpower = gameState.nightpower;
    slots = gameState.slots;
    cannotmove = gameState.cannotmove;
    options = JSON.parse(gameState.options);
    activatedCheats = gameState.activatedCheats;
    yourItemsDurabilities = JSON.parse(gameState.yourItemsDurabilities),
      currentHP = gameState.currentHP;
    currentStamina = gameState.currentStamina;
    generateCave = gameState.generateCave;
    yourItems = JSON.parse(gameState.yourItems);
    overworldChunks = JSON.parse(gameState.overworldChunks);
    housechunks = JSON.parse(gameState.houseChunks);
    caveChunks = JSON.parse(gameState.caveChunks);
    seachunks = JSON.parse(gameState.seachunks);
    abysschunks = JSON.parse(gameState.abysschunks);
    
    if (gameState.hellchunks) {
  hellchunks = JSON.parse(gameState.hellchunks);
}
if (gameState.inhell) {
  inhell = gameState.inhell
}
    if (typeof gameState.renderedEnemies === "string") {
      renderedEnemies = JSON.parse(gameState.renderedEnemies);
    }else{
    renderedEnemies = (gameState.renderedEnemies);
    }
    
    oxygen = gameState.oxygen;
    inabyss = gameState.inabyss;
    isunderwater = gameState.isunderwater;
    isinhouse = gameState.isinhouse;
    chunks = JSON.parse(gameState.chunks);

    if (inabyss == 1) {
      chunks = abysschunks;
    } else if (isunderwater == 1) {
      chunks = seachunks;
    } else if (generateCave == 1) {
      chunks = caveChunks;
    } else if (isinhouse == 1) {
      chunks = housechunks;
    }else if (inhell == 1) {
  chunks = hellchunks;
}else{
  
}

    updateInventory();
    updateCrafting();
    customAlert("Game loaded successfully from slot " + slot);

    setTimeout(() => {
      hideLoadingScreen(); // Ukrycie ekranu ładowania po zakończeniu
      playMusic(); // Odtworzenie muzyki
    }, 500); // Minimalne opóźnienie, aby efekt był zauważalny
setTimeout(function() {
  updfixbug = 0
}, 1000)
    
    document.querySelectorAll('button[data-var]').forEach(button => {
      const varName = button.getAttribute('data-var');
      updateButtonStyle(button, options[varName]);
    });
    playMusic();
  };

  request.onerror = function(event) {
    customAlert("Failed to load game: " + event.target.errorCode);
    hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku błędu
  };
} catch (error) {
  customAlert("Error: " + error);
  hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku błędu
}
    });
}
async function loadGameState3(slot) {
  
    showLoadingScreen(); // Pokazanie ekranu ładowania

    try {
      const db = await initDB();
      const transaction = db.transaction("gameStates", "readonly");
      const store = transaction.objectStore("gameStates");

      const request = store.get(slot);

      request.onsuccess = function(event) {
        const gameState = event.target.result;
        if (!gameState) {
          customAlert("No save found in slot " + slot);
          hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku braku zapisu
          return;
        }

        updfixbug = 1


        if (gameState.AVAILABLE_IDS) {
          AVAILABLE_IDS = gameState.AVAILABLE_IDS
        }
        if (gameState.VISIBLEIDS) {
          VISIBLEIDS = gameState.VISIBLEIDS
        }
if (gameState.achievements1 !== null && gameState.achievements1) {
    achievements = (gameState.achievements1);
        
} else {
    achievements = []
}
        inhell = 0;
        curseofgos = gameState.curseofgos;
        offsetX = gameState.offsetX;
        offsetY = gameState.offsetY;
        increasing = gameState.increasing;
        isRaining = gameState.isRaining;
        nightpower = gameState.nightpower;
        slots = gameState.slots;
        cannotmove = gameState.cannotmove;
        options = JSON.parse(gameState.options);
        activatedCheats = gameState.activatedCheats;
        yourItemsDurabilities = JSON.parse(gameState.yourItemsDurabilities),
          currentHP = gameState.currentHP;
        currentStamina = gameState.currentStamina;
        generateCave = gameState.generateCave;
        yourItems = JSON.parse(gameState.yourItems);
        overworldChunks = JSON.parse(gameState.overworldChunks);
        housechunks = JSON.parse(gameState.houseChunks);
        caveChunks = JSON.parse(gameState.caveChunks);
        seachunks = JSON.parse(gameState.seachunks);
        abysschunks = JSON.parse(gameState.abysschunks);
        if (gameState.savedinworld) {
        player.savedinworld = (gameState.savedinworld);
        }
        if (gameState.hellchunks) {
          hellchunks = JSON.parse(gameState.hellchunks);
        }
        if (gameState.inhell) {
          inhell = gameState.inhell
        }
if (gameState.dayscount) {
    surviveddays = gameState.dayscount
}
 if (gameState.spawnX) {
            player.spawnX = gameState.spawnX
            player.spawnY = gameState.spawnY
        }
        if (typeof gameState.renderedEnemies === "string") {
          renderedEnemies = JSON.parse(gameState.renderedEnemies);
        } else {
          renderedEnemies = (gameState.renderedEnemies);
        }

        oxygen = gameState.oxygen;
        inabyss = gameState.inabyss;
        isunderwater = gameState.isunderwater;
        isinhouse = gameState.isinhouse;
        chunks = JSON.parse(gameState.chunks);

        if (inabyss == 1) {
          chunks = abysschunks;
        } else if (isunderwater == 1) {
          chunks = seachunks;
        } else if (generateCave == 1) {
          chunks = caveChunks;
        } else if (isinhouse == 1) {
          chunks = housechunks;
        } else if (inhell == 1) {
          chunks = hellchunks;
        } else {

        }

        updateInventory();
        updateCrafting();
        

        setTimeout(() => {
          hideLoadingScreen(); // Ukrycie ekranu ładowania po zakończeniu
          playMusic(); // Odtworzenie muzyki
        }, 500); // Minimalne opóźnienie, aby efekt był zauważalny
        setTimeout(function() {
          updfixbug = 0
        }, 1000)

        document.querySelectorAll('button[data-var]').forEach(button => {
          const varName = button.getAttribute('data-var');
          updateButtonStyle(button, options[varName]);
        });
        playMusic();
      };

      request.onerror = function(event) {
        customAlert("Failed to load game: " + event.target.errorCode);
        hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku błędu
      };
    } catch (error) {
      customAlert("Error: " + error);
      hideLoadingScreen(); // Ukrycie ekranu ładowania w przypadku błędu
    }
 
}
// Funkcja do zapisania stanu gry
let savedtimes = 0;
let saveTimer = null;

async function saveGameState(slot) {
    if (checkIfHasEnemy("trueuniversehead", 1)) {
        showModal("You are Fighting with TRUE UNIVERSE, saving isn't a good idea?", function () {});
        return; // Przerwij, jeśli gracz walczy
    }
    if (!saveTimer) {
    savedtimes = 1;
    saveTimer = setInterval(() => {
        if (savedtimes >= 5) {
            achievementget("Uhm...saving ONE time is enough, y'know?", 1);
            clearInterval(saveTimer);
            saveTimer = null;
        }
        savedtimes = 0;
    }, 30000);
}
savedtimes++;
 
    showModal("Are you sure to overwrite this game?", async function() {
        try {
            
            

            const db = await initDB();
            const transaction = db.transaction("gameStates", "readwrite");
            const store = transaction.objectStore("gameStates");

            const gameState = {
                slot,
                curseofgos,
                offsetX,
                offsetY,
                increasing,
                isRaining,
                nightpower,
                slots,
                VISIBLEIDS,
                AVAILABLE_IDS,
                cannotmove,
                options: JSON.stringify(options),
                yourItemsDurabilities: JSON.stringify(yourItemsDurabilities),
                activatedCheats,
                currentHP,
                currentStamina,
                generateCave,
                yourItems: JSON.stringify(yourItems),
                overworldChunks: JSON.stringify(overworldChunks),
                hellchunks: JSON.stringify(hellchunks),
                houseChunks: JSON.stringify(housechunks),
                caveChunks: JSON.stringify(caveChunks),
                
                seachunks: JSON.stringify(seachunks),
                abysschunks: JSON.stringify(abysschunks),
                renderedEnemies: (RENDEREDENEMIES2),
                oxygen,
                inabyss,
                isunderwater,
                isinhouse,
                inhell,
                dayscount:surviveddays,
                
                spawnX: player.spawnX ,
                spawnY: player.spawnY ,
                chunks: JSON.stringify(chunks),
                dataChunksStructures : dataChunksStructures,
                savedinworld: player.savedinworld,
                achievements1 : (achievements),
            };

            store.put(gameState);
            customAlert("Game saved successfully in slot " + slot);
        } catch (error) {
            customAlert("Failed to save game: " + error);
        }
    });
}




function showLoadingScreen() {
    const loadingScreen = document.createElement("div");
    loadingScreen.id = "loadingScreen";
    loadingScreen.style.position = "fixed";
    loadingScreen.style.top = "0";
    loadingScreen.style.left = "0";
    loadingScreen.style.width = "100vw";
    loadingScreen.style.height = "100vh";
    loadingScreen.style.opacity = "0.5";
    loadingScreen.style.backgroundColor = "black";
    loadingScreen.style.zIndex = "99999999999";
    loadingScreen.style.display = "flex";
    loadingScreen.style.justifyContent = "center";
    loadingScreen.style.alignItems = "center";
    loadingScreen.style.color = "white";
    loadingScreen.style.fontSize = "15px";
    loadingScreen.style.fontFamily = "Arial, sans-serif";
    loadingScreen.textContent = "be patient, loading can take some time ...";
    document.body.appendChild(loadingScreen);
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById("loadingScreen");
    if (loadingScreen) {
        loadingScreen.remove();
    }
}



    




    </script>
    

<script>
  function loadGameState2(slot) {
    showModal("Are you sure to load olddata.slot this is unstable in newest versions", async function() {
  if(slot==undefined ){
    slot=""
  }

  inabyss=0
  housechunks={}
  chunks={}
  overworldChunks={}
  caveChunks={}
  updfixbug=1
  seachunks={}
  renderedEnemies=[]
  isinhouse=0
  isunderwater=0
  generateCave=0
  abysschunks={}
  inabyss=0
  
if(isunderwater==1){

  isunderwater = 0;

}

if(localStorage.getItem('entities'+slot)){
renderedEnemies = JSON.parse(localStorage.getItem('entities'+slot))
}

    // Wczytaj pozycję gracza
    increasing=false
    const generatesea = localStorage.getItem('generatesea'+slot);
    let generateabyss = 0;
    if(localStorage.getItem('generateabyss'+slot)){
     generateabyss = parseInt(localStorage.getItem('generateabyss'+slot))
    }else{
      generateabyss =0
    }
    const storedsea = localStorage.getItem('seachunks'+slot);
    const storedabyss = localStorage.getItem('abysschunks'+slot);
    const storedPlayerX = localStorage.getItem('playerX'+slot);
    const storedPlayerY = localStorage.getItem('playerY'+slot);
    nightpower=localStorage.getItem('nightcycle'+slot)
    if(localStorage.getItem('options'+slot)){
    options=JSON.parse(localStorage.getItem('options'+slot))
    }
notabletoreturn987444=1
if(localStorage.getItem('oxygenlevel'+slot)) {
oxygen=parseInt(localStorage.getItem('oxygenlevel'+slot))
}

    if(localStorage.getItem('rainingcycle'+slot)){
      if(localStorage.getItem('rainingcycle'+slot)==true || localStorage.getItem('rainingcycle'+slot)=="true"){
    isRaining=true ;
      }else{
isRaining=false ;
      }
    }
    if(localStorage.getItem('Hp'+slot)){
      if(localStorage.getItem('Hp'+slot)!==null){
    currentHP=parseFloat(localStorage.getItem('Hp'+slot))
    
            // Aktualizacja szerokości paska życia w procentach
        const healthBar = document.getElementById('healthBar');
        const healthPercentage = (currentHP / maxHP) * 100;
        healthBar.style.width = healthPercentage + '%';
 
}}
    if(localStorage.getItem('slots'+slot)){
      if(localStorage.getItem('Hp'+slot)!==null){
    slots=parseFloat(localStorage.getItem('slots'+slot))
}}
if(localStorage.getItem('curseofgos'+slot)){
      if(localStorage.getItem('curseofgos'+slot)!==null){
    curseofgos=parseFloat(localStorage.getItem('curseofgos'+slot))
}}
if(localStorage.getItem('cheatsanabled'+slot)){
      if(localStorage.getItem('cheatsanabled'+slot)!==null){
    activatedCheats =parseFloat(localStorage.getItem('cheatsanabled'+slot))
}}
if(localStorage.getItem('cannotmove'+slot)){
      if(localStorage.getItem('cannotmove'+slot)!==null){
    cannotmove=parseFloat(localStorage.getItem('cannotmove'+slot))
}}
setTimeout(function (){
if (localStorage.getItem('increasing' + slot)) {
 // alert((localStorage.getItem('increasing' + slot)))
  if((localStorage.getItem('increasing' + slot))==true){
    increasing=true
  }
}
},2000)
if (localStorage.getItem('St'+slot)) {
  if (localStorage.getItem('St'+slot) !== null) {
    currentStamina = parseFloat(localStorage.getItem('St'+slot))
}}
    setTimeout(function (){
      increasing=true
    },5000)
    
    if (storedPlayerX !== null && storedPlayerY !== null) {
        offsetX = Infinity
        offsetY = Infinity 
    }
setTimeout(function(){
      if (storedPlayerX !== null && storedPlayerY !== null) {
      offsetX = parseFloat(storedPlayerX);
      offsetY = parseFloat(storedPlayerY);
    }
    
},200)
    const storedItems = localStorage.getItem('youritems'+slot);
    if (storedItems !== null) {
        yourItems = JSON.parse(storedItems);
        
        updateInventory();
updateCrafting();
    }

    // Wczytaj stan chunków
    const storedChunks = localStorage.getItem('chunks'+slot);
    if (storedChunks !== null) {
        chunks = JSON.parse(storedChunks);
        overworldChunks = chunks
    }
    const storedCave = localStorage.getItem('InCave'+slot);
const cavechunksg = localStorage.getItem('cave'+slot);
if (storedCave !== null && cavechunksg !== null) {

    if(storedabyss.length>5){
  abysschunks =JSON.parse(storedabyss);
  }
    setTimeout(function () {
      if (generateabyss == 1) { 
  playMusic();
  overworldChunks = JSON.parse(localStorage.getItem('overworldChunks'));
  chunks = JSON.parse(storedabyss);
  delayChangeDimension = 1;
  caveChunks = JSON.parse(cavechunksg);
  seachunks=JSON.parse(storedsea);
  if (localStorage.getItem('house' + slot) !== null) {
    housechunks = JSON.parse(localStorage.getItem('house' + slot))
  }
  inabyss = 1;
            setTimeout(function () {
                delayChangeDimension = 0;
            }, 5000);
            
} else  if(generatesea==1){
        isunderwater=1
        overworldChunks = JSON.parse(localStorage.getItem('overworldChunks'));
        abysschunks =JSON.parse(storedabyss);
        delayChangeDimension = 1;
        chunks = JSON.parse(storedsea);
        caveChunks = JSON.parse(cavechunksg);
      if (localStorage.getItem('house' + slot) !== null) {
        housechunks = JSON.parse(localStorage.getItem('house' + slot))
      }
      
setTimeout(function() {
  delayChangeDimension = 0;
}, 5000);
      } else {
        if(storedsea && storedsea!==null){
        seachunks= JSON.parse(storedsea);
        }
          if (localStorage.getItem('house' + slot) !== null) {
              housechunks = JSON.parse(localStorage.getItem('house' + slot))
            }
        if (parseInt(storedCave) == 1) {
            // Wejście do jaskini
            renderedEnemies = [];
            chunks = JSON.parse(cavechunksg); // Poprawione
            generateCave = 1;
            if (localStorage.getItem('house' + slot) !== null) {
  housechunks = JSON.parse(localStorage.getItem('house' + slot))
            }
             // Zachowaj obecne chunk-i
            delayChangeDimension = 1;
            // Ustaw jaskiniowe chunk-i
            setTimeout(function () {
                delayChangeDimension = 0;
            }, 5000);
            
        } else if (parseInt(storedCave) == 0) {
            // Wyjście z jaskini
            caveChunks = JSON.parse(cavechunksg);
            generateCave = 0;
            // chunks = overworldChunks; // Przywróć chunk-i świata
            delayChangeDimension = 1;
            setTimeout(function () {
                delayChangeDimension = 0;
            }, 5000);
            if (localStorage.getItem('isinhouse'+slot) !== 1) {
            }
            if(localStorage.getItem('isinhouse'+slot)){
  if(localStorage.getItem('house'+slot)){
      if(localStorage.getItem('house'+slot)!==null){
    housechunks = JSON.parse(localStorage.getItem('house'+slot))
    if (localStorage.getItem('isinhouse'+slot) == 1) {
  //  isinhouse=parseFloat(localStorage.getItem('isinhouse'))
  delayChangeDimension = 1;
 overworldChunks = JSON.parse(storedChunks);
 
  isinhouse = 1;
  //chunks = JSON.parse(storedChunks);
  chunks = housechunks;
  setTimeout(function() {
    synchronizeVisibleChunks()
    //showTextInCanvas(overworldChunks)
    overworldChunks = JSON.parse(storedChunks);
  }, 100);
}}
      
}}
            
        }
        
        setTimeout(function (){notabletoreturn987444=0},2000)
      }
    }, 500);
    
    if (Array.isArray(housechunks)) {
  housechunks = {}; 
}
}

if (paused == 1) {
  paused = 0
  update()
  paused = 1

}
setTimeout(function() {
  updfixbug = 0
}, 1000)
document.querySelectorAll('button[data-var]').forEach(button => {
  const varName = button.getAttribute('data-var');
  updateButtonStyle(button, options[varName]);
});
playMusic();

});
}


</script>


    <div id="checkModal">
    <div class="modal-content">
        <p id="modalMessage">Are you sure you want to continue?</p>
        <button class="cancel" id="cancelBtn">Cancel</button>
        <button id="confirmBtn">Confirm</button>
    </div>
    </div>
    
        <div id="checkModal2">
        <div class="modal-content">
            <p id="modalMessage2">type something .</p>
            <input type="text" id="input2" maxlength="25">
            <button id="confirmBtn2">Confirm</button>
         </div>
        </div>
        
<style> 
/* Styl dla modalu */
#checkModal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.7); /* Czarny przezroczysty background */
    z-index: 999999;
    justify-content: center;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 18px;
}
#checkModal2 {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.7);
    /* Czarny przezroczysty background */
    z-index: 999999;
    justify-content: center;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 18px;
}
 .modal-content {
    background-color: #333;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
}

#checkModal button {
    background-color: #f44336; /* Czerwony kolor przycisków */
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin: 10px;
}
#checkModal2 button {
    background-color: #f44336; /* Czerwony kolor przycisków */
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin: 10px;
}
#checkModal button.cancel {
    background-color: #9e9e9e; /* Szary przycisk anulowania */
}

</style>
    
    
    <script>


    
    function updateMovement(direction, isActive) {
        switch (direction) {
            case 'up-left':
                moveLeft = isActive;
                moveUp = isActive;
                break;
            case 'up':
                moveUp = isActive;
                break;
            case 'up-right':
                moveRight = isActive;
                moveUp = isActive;
                break;
            case 'left':
                moveLeft = isActive;
                break;
            case 'empty':
                // Nie robimy nic
                break;
            case 'right':
                moveRight = isActive;
                break;
            case 'down-left':
                moveLeft = isActive;
                moveDown = isActive;
                break;
            case 'down':
                moveDown = isActive;
                break;
            case 'down-right':
                moveRight = isActive;
                moveDown = isActive;
                break;
        }
    }

    // Dodawanie nasłuchiwaczy zdarzeń do przycisków
    const buttons = document.querySelectorAll('.button');
    buttons.forEach(button => {
        button.addEventListener('touchstart', () => {
            updateMovement(button.dataset.direction, true);
        });
        button.addEventListener('touchend', () => {
            updateMovement(button.dataset.direction, false);
        });
        button.addEventListener('touchend', () => {
            updateMovement(button.dataset.direction, false);
        });
    });


    
const joystick = document.getElementById('joystick');
const thumb = document.getElementById('thumb');
let joystickActive = false;
let thumbOffsetX = 0,
  thumbOffsetY = 0;
let currentTouchIndex = null; // Przechowuje index aktywnego dotyku na joysticku
let secondTouchIndex = null; // Przechowuje index drugiego dotyku, jeśli dotyczy

// Funkcja do zaokrąglania kąta do najbliższej wielokrotności (w tym przypadku 25 stopni)
function roundToNearest(degrees, roundTo = 10) {
  return Math.round(degrees / roundTo) * roundTo;
}

// Obsługa dotyku
const activeTouches = {}; // Obiekt do przechowywania aktywnych dotyków


// Obsługa joysticka
joystick.addEventListener('touchstart', (e) => {
  
  e.preventDefault();


  if (joystickActive) return;
  joystickActive = true;

  for (let i = 0; i < e.touches.length; i++) {
    const touch = e.touches[i];
    const joystickRect = joystick.getBoundingClientRect();
    if(touch.clientX && touch.clientX!==undefined){
    if (
      touch.clientX >= joystickRect.left &&
      touch.clientX <= joystickRect.right &&
      touch.clientY >= joystickRect.top &&
      touch.clientY <= joystickRect.bottom
    ) {
      
      currentTouchIndex = touch.identifier; // Użyj identyfikatora dotyku
      activeTouches[currentTouchIndex] = { x: touch.clientX, y: touch.clientY };
      thumb.style.display = 'block';

      // Ustawienie thumba w początkowej pozycji
      thumbOffsetX = touch.clientX - joystickRect.left - 20;
      thumbOffsetY = touch.clientY - joystickRect.top - 20;
      thumb.style.left = `${thumbOffsetX}px`;
      thumb.style.top = `${thumbOffsetY}px`;
    }
  }}
});



joystick.addEventListener('touchmove', (e) => {
  e.stopPropagation();
  e.preventDefault();

  if (!joystickActive || currentTouchIndex === null) return;

  // Używamy odpowiedniego dotyku, który jest aktywny
  let touch = e.touches[currentTouchIndex];

  // Jeżeli dotyku jest więcej niż jeden, weźmy pozycję pierwszego dotyku na joysticku
  if (e.touches.length > 1 && secondTouchIndex === null) {
    // Jeżeli jest więcej niż jeden dotyk, kontroluje tylko pierwszy dotyk na joysticku
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      const joystickRect = joystick.getBoundingClientRect();
      if(touch.clientX && touch.clientX!==undefined){
      if (
        touch.clientX >= joystickRect.left &&
        touch.clientX <= joystickRect.right &&
        touch.clientY >= joystickRect.top &&
        touch.clientY <= joystickRect.bottom
      ) {
        currentTouchIndex = i; // Przypisanie aktywnego dotyku
        break;
      }
    }}
  }

  // Obliczanie pozycji thumba
  const joystickRect = joystick.getBoundingClientRect();
  let deltaX = 0
let deltaY = 0
  if(touch.clientX){
   deltaX = touch.clientX - joystickRect.left - 35;
   deltaY = touch.clientY - joystickRect.top - 35;
  }
  // Obliczanie kąta
  let angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI; // Kąt w stopniach

  // Zaokrąglanie kąta do najbliższej wielokrotności 25 stopni
  angle = roundToNearest(angle, 10);

  // Ograniczenie ruchu thumba do obszaru joysticka
  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  if (distance > 30) {
    thumbOffsetX = 30 * Math.cos(angle * Math.PI / 180); // Ustawienie x
    thumbOffsetY = 30 * Math.sin(angle * Math.PI / 180); // Ustawienie y
  } else {
    thumbOffsetX = deltaX;
    thumbOffsetY = deltaY;
  }

  // Ustawienie thumb w nowej pozycji
  thumb.style.left = `${thumbOffsetX + 35 +30/2}px`; // Przesunięcie o połowę szerokości joysticka
  thumb.style.top = `${thumbOffsetY + 35 +30/2}px`; // Przesunięcie o połowę wysokości joysticka

  // Ustalanie kierunku ruchu
  moveLeft = thumbOffsetX < -14
  moveRight = thumbOffsetX >14
  moveUp = thumbOffsetY < -14
  moveDown = thumbOffsetY > 14
});

joystick.addEventListener('touchend', (e) => {
  e.stopPropagation();
  e.preventDefault();

  if (!joystickActive) return;
jebacszkole=0
jebacszkole5=0
  joystickActive = false;
  thumb.style.display = 'none'; // Ukryj thumb
  thumb.style.left = '20px'; // Reset pozycji thumba
  thumb.style.top = '20px';
  thumbOffsetX = 0; // Reset wartości
  thumbOffsetY = 0; // Reset wartości
  moveLeft = moveRight = moveUp = moveDown = false;

  // Resetowanie śledzenia dotyku
  currentTouchIndex = null;
  secondTouchIndex = null;
});


// Poruszanie gracza za pomocą klawiatury
document.addEventListener('keydown', (e) => {
    if (e.key === 'a') moveLeft = true;
    if (e.key === 'd') moveRight = true;
    if (e.key === 'w') moveUp = true;
    if (e.key === 's') moveDown = true;
});
document.addEventListener('keyup', (e) => {
    if (e.key === 'a') moveLeft = false;
    if (e.key === 'd') moveRight = false;
    if (e.key === 'w') moveUp = false;
    if (e.key === 's') moveDown = false;
});

    </script>
    


<div id="fpsCounter" style="position: fixed; bottom: 10px; right: 10px; color: white; background: rgba(0, 0, 0, 0.5); padding: 5px; font-family: Arial, sans-serif; font-size: 8px;">
  FPS: 0
</div>
<script>
  let lastFrameTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateFPS() {
    const now = performance.now();
    frameCount++;

    // Sprawdzenie, ile czasu minęło od ostatniej aktualizacji
    const deltaTime = now - lastFrameTime;
    
    if (deltaTime >= 1000) { // Co sekundę aktualizujemy FPS
        fps = (frameCount / deltaTime) * 1000;
        frameCount = 0;
        lastFrameTime = now;
        document.getElementById('fpsCounter').textContent = `FPS: ${fps.toFixed(1)}`;
    }

    requestAnimationFrame(updateFPS); // Kontynuuj obliczanie FPS
}

// Start miernika FPS
updateFPS();

</script>

<div id="confirmationModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:100vw; font:'Courier New' monospace; height:100vh ; background: rgba(0, 0, 0, 0.5); color:white ; border:1px solid black; padding:20px; z-index:999999999;">
    <h3>Please confirm the code:</h3>
    <p>Code: <span id="confirmationCode" style="font-weight:bold;"></span></p>
    <input id="confirmationInput" type="text" placeholder="Enter the code here">
    <button id="confirmCodeButton">Confirm</button>
    <button id="cancelCodeButton">Cancel</button>
</div>

<div id="achievement" style="position: fixed; z-index:9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999; width:90vw; height:30px; background:  rgb(20,20,20); top:0; left:50vw;transform: translate(-50%,0);">  
<pre id="achievementTEXT" style="margin-left:35px; margin-top: 0; position : absolute; color:white; width: calc(100% - 30px); white-space: pre-wrap; "></pre>
<div style="width:30px; height:100%; background: rgb(50,50,50); background-size:100% 100%; image-rendering: pixelated;"><div style="width:30px; height:100%; background-image: url('./diamond.gif'); background-size:100% 100%; image-rendering: pixelated;" id="achievementimg"></div></div>
</div>
<div id="allachievements" style="position: absolute; z-index:9999999999999999999999999999; width:100vw; height:100vh; background:  rgb(5,10,10); top:0; left:50vw;transform: translate(-50%,0);   ">
    <div onclick="document.getElementById('allachievements').style.display='none' " style="position: absolute; width:9px; height:9px; background:  rgb(100,10,10); top:5px; right:5px; padding :6px; color:white;">x</div>
    <div id="allachievements2"></div>
</div>